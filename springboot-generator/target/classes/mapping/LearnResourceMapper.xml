<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="mapper.LearnResourceMapper">
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="PATH" jdbcType="VARCHAR" property="path" />
    <result column="SPACE" jdbcType="VARBINARY" property="space" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_DATAFILES (PATH, SPACE)
    values (#{path,jdbcType=VARCHAR}, #{space,jdbcType=VARBINARY})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select PATH, SPACE
    from INNODB_DATAFILES
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="cid" jdbcType="BIGINT" property="cid" />
    <result column="tip" jdbcType="VARCHAR" property="tip" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from contexttip
    where cid = #{cid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into contexttip (cid, tip)
    values (#{cid,jdbcType=BIGINT}, #{tip,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update contexttip
    set tip = #{tip,jdbcType=VARCHAR}
    where cid = #{cid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select cid, tip
    from contexttip
    where cid = #{cid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select cid, tip
    from contexttip
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="table_schema" jdbcType="VARCHAR" property="tableSchema" />
    <result column="table_name" jdbcType="VARCHAR" property="tableName" />
    <result column="count_read" jdbcType="DECIMAL" property="countRead" />
    <result column="sum_number_of_bytes_read" jdbcType="DECIMAL" property="sumNumberOfBytesRead" />
    <result column="sum_timer_read" jdbcType="DECIMAL" property="sumTimerRead" />
    <result column="count_write" jdbcType="DECIMAL" property="countWrite" />
    <result column="sum_number_of_bytes_write" jdbcType="DECIMAL" property="sumNumberOfBytesWrite" />
    <result column="sum_timer_write" jdbcType="DECIMAL" property="sumTimerWrite" />
    <result column="count_misc" jdbcType="DECIMAL" property="countMisc" />
    <result column="sum_timer_misc" jdbcType="DECIMAL" property="sumTimerMisc" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$ps_schema_table_statistics_io (table_schema, table_name, count_read, 
      sum_number_of_bytes_read, sum_timer_read, count_write, 
      sum_number_of_bytes_write, sum_timer_write, count_misc, 
      sum_timer_misc)
    values (#{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, #{countRead,jdbcType=DECIMAL}, 
      #{sumNumberOfBytesRead,jdbcType=DECIMAL}, #{sumTimerRead,jdbcType=DECIMAL}, #{countWrite,jdbcType=DECIMAL}, 
      #{sumNumberOfBytesWrite,jdbcType=DECIMAL}, #{sumTimerWrite,jdbcType=DECIMAL}, #{countMisc,jdbcType=DECIMAL}, 
      #{sumTimerMisc,jdbcType=DECIMAL})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select table_schema, table_name, count_read, sum_number_of_bytes_read, sum_timer_read, 
    count_write, sum_number_of_bytes_write, sum_timer_write, count_misc, sum_timer_misc
    from x$ps_schema_table_statistics_io
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="aid" jdbcType="BIGINT" property="aid" />
    <result column="url" jdbcType="VARCHAR" property="url" />
    <result column="eid" jdbcType="BIGINT" property="eid" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from auth
    where aid = #{aid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into auth (aid, url, eid)
    values (#{aid,jdbcType=BIGINT}, #{url,jdbcType=VARCHAR}, #{eid,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update auth
    set url = #{url,jdbcType=VARCHAR},
      eid = #{eid,jdbcType=BIGINT}
    where aid = #{aid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select aid, url, eid
    from auth
    where aid = #{aid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select aid, url, eid
    from auth
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="TABLE_CATALOG" jdbcType="VARCHAR" property="tableCatalog" />
    <result column="TABLE_SCHEMA" jdbcType="VARCHAR" property="tableSchema" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
    <result column="PARTITION_NAME" jdbcType="VARCHAR" property="partitionName" />
    <result column="SUBPARTITION_NAME" jdbcType="VARCHAR" property="subpartitionName" />
    <result column="PARTITION_ORDINAL_POSITION" jdbcType="INTEGER" property="partitionOrdinalPosition" />
    <result column="SUBPARTITION_ORDINAL_POSITION" jdbcType="INTEGER" property="subpartitionOrdinalPosition" />
    <result column="PARTITION_METHOD" jdbcType="VARCHAR" property="partitionMethod" />
    <result column="SUBPARTITION_METHOD" jdbcType="VARCHAR" property="subpartitionMethod" />
    <result column="PARTITION_EXPRESSION" jdbcType="VARCHAR" property="partitionExpression" />
    <result column="SUBPARTITION_EXPRESSION" jdbcType="VARCHAR" property="subpartitionExpression" />
    <result column="TABLE_ROWS" jdbcType="BIGINT" property="tableRows" />
    <result column="AVG_ROW_LENGTH" jdbcType="BIGINT" property="avgRowLength" />
    <result column="DATA_LENGTH" jdbcType="BIGINT" property="dataLength" />
    <result column="MAX_DATA_LENGTH" jdbcType="BIGINT" property="maxDataLength" />
    <result column="INDEX_LENGTH" jdbcType="BIGINT" property="indexLength" />
    <result column="DATA_FREE" jdbcType="BIGINT" property="dataFree" />
    <result column="CREATE_TIME" jdbcType="TIMESTAMP" property="createTime" />
    <result column="UPDATE_TIME" jdbcType="TIMESTAMP" property="updateTime" />
    <result column="CHECK_TIME" jdbcType="TIMESTAMP" property="checkTime" />
    <result column="CHECKSUM" jdbcType="BIGINT" property="checksum" />
    <result column="NODEGROUP" jdbcType="VARCHAR" property="nodegroup" />
    <result column="TABLESPACE_NAME" jdbcType="VARCHAR" property="tablespaceName" />
    <result column="PARTITION_DESCRIPTION" jdbcType="LONGVARCHAR" property="partitionDescription" />
    <result column="PARTITION_COMMENT" jdbcType="LONGVARCHAR" property="partitionComment" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into PARTITIONS (TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, 
      PARTITION_NAME, SUBPARTITION_NAME, PARTITION_ORDINAL_POSITION, 
      SUBPARTITION_ORDINAL_POSITION, PARTITION_METHOD, 
      SUBPARTITION_METHOD, PARTITION_EXPRESSION, 
      SUBPARTITION_EXPRESSION, TABLE_ROWS, AVG_ROW_LENGTH, 
      DATA_LENGTH, MAX_DATA_LENGTH, INDEX_LENGTH, 
      DATA_FREE, CREATE_TIME, UPDATE_TIME, 
      CHECK_TIME, CHECKSUM, NODEGROUP, 
      TABLESPACE_NAME, PARTITION_DESCRIPTION, 
      PARTITION_COMMENT)
    values (#{tableCatalog,jdbcType=VARCHAR}, #{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, 
      #{partitionName,jdbcType=VARCHAR}, #{subpartitionName,jdbcType=VARCHAR}, #{partitionOrdinalPosition,jdbcType=INTEGER}, 
      #{subpartitionOrdinalPosition,jdbcType=INTEGER}, #{partitionMethod,jdbcType=VARCHAR}, 
      #{subpartitionMethod,jdbcType=VARCHAR}, #{partitionExpression,jdbcType=VARCHAR}, 
      #{subpartitionExpression,jdbcType=VARCHAR}, #{tableRows,jdbcType=BIGINT}, #{avgRowLength,jdbcType=BIGINT}, 
      #{dataLength,jdbcType=BIGINT}, #{maxDataLength,jdbcType=BIGINT}, #{indexLength,jdbcType=BIGINT}, 
      #{dataFree,jdbcType=BIGINT}, #{createTime,jdbcType=TIMESTAMP}, #{updateTime,jdbcType=TIMESTAMP}, 
      #{checkTime,jdbcType=TIMESTAMP}, #{checksum,jdbcType=BIGINT}, #{nodegroup,jdbcType=VARCHAR}, 
      #{tablespaceName,jdbcType=VARCHAR}, #{partitionDescription,jdbcType=LONGVARCHAR}, 
      #{partitionComment,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, PARTITION_NAME, SUBPARTITION_NAME, 
    PARTITION_ORDINAL_POSITION, SUBPARTITION_ORDINAL_POSITION, PARTITION_METHOD, SUBPARTITION_METHOD, 
    PARTITION_EXPRESSION, SUBPARTITION_EXPRESSION, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH, 
    MAX_DATA_LENGTH, INDEX_LENGTH, DATA_FREE, CREATE_TIME, UPDATE_TIME, CHECK_TIME, CHECKSUM, 
    NODEGROUP, TABLESPACE_NAME, PARTITION_DESCRIPTION, PARTITION_COMMENT
    from PARTITIONS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <result column="EVENT_ID" jdbcType="BIGINT" property="eventId" />
    <result column="END_EVENT_ID" jdbcType="BIGINT" property="endEventId" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="STATE" jdbcType="CHAR" property="state" />
    <result column="TRX_ID" jdbcType="BIGINT" property="trxId" />
    <result column="GTID" jdbcType="VARCHAR" property="gtid" />
    <result column="XID_FORMAT_ID" jdbcType="INTEGER" property="xidFormatId" />
    <result column="XID_GTRID" jdbcType="VARCHAR" property="xidGtrid" />
    <result column="XID_BQUAL" jdbcType="VARCHAR" property="xidBqual" />
    <result column="XA_STATE" jdbcType="VARCHAR" property="xaState" />
    <result column="SOURCE" jdbcType="VARCHAR" property="source" />
    <result column="TIMER_START" jdbcType="BIGINT" property="timerStart" />
    <result column="TIMER_END" jdbcType="BIGINT" property="timerEnd" />
    <result column="TIMER_WAIT" jdbcType="BIGINT" property="timerWait" />
    <result column="ACCESS_MODE" jdbcType="CHAR" property="accessMode" />
    <result column="ISOLATION_LEVEL" jdbcType="VARCHAR" property="isolationLevel" />
    <result column="AUTOCOMMIT" jdbcType="CHAR" property="autocommit" />
    <result column="NUMBER_OF_SAVEPOINTS" jdbcType="BIGINT" property="numberOfSavepoints" />
    <result column="NUMBER_OF_ROLLBACK_TO_SAVEPOINT" jdbcType="BIGINT" property="numberOfRollbackToSavepoint" />
    <result column="NUMBER_OF_RELEASE_SAVEPOINT" jdbcType="BIGINT" property="numberOfReleaseSavepoint" />
    <result column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="NESTING_EVENT_ID" jdbcType="BIGINT" property="nestingEventId" />
    <result column="NESTING_EVENT_TYPE" jdbcType="CHAR" property="nestingEventType" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_transactions_history_long (THREAD_ID, EVENT_ID, END_EVENT_ID, 
      EVENT_NAME, STATE, TRX_ID, 
      GTID, XID_FORMAT_ID, XID_GTRID, 
      XID_BQUAL, XA_STATE, SOURCE, 
      TIMER_START, TIMER_END, TIMER_WAIT, 
      ACCESS_MODE, ISOLATION_LEVEL, AUTOCOMMIT, 
      NUMBER_OF_SAVEPOINTS, NUMBER_OF_ROLLBACK_TO_SAVEPOINT, 
      NUMBER_OF_RELEASE_SAVEPOINT, OBJECT_INSTANCE_BEGIN, 
      NESTING_EVENT_ID, NESTING_EVENT_TYPE)
    values (#{threadId,jdbcType=BIGINT}, #{eventId,jdbcType=BIGINT}, #{endEventId,jdbcType=BIGINT}, 
      #{eventName,jdbcType=VARCHAR}, #{state,jdbcType=CHAR}, #{trxId,jdbcType=BIGINT}, 
      #{gtid,jdbcType=VARCHAR}, #{xidFormatId,jdbcType=INTEGER}, #{xidGtrid,jdbcType=VARCHAR}, 
      #{xidBqual,jdbcType=VARCHAR}, #{xaState,jdbcType=VARCHAR}, #{source,jdbcType=VARCHAR}, 
      #{timerStart,jdbcType=BIGINT}, #{timerEnd,jdbcType=BIGINT}, #{timerWait,jdbcType=BIGINT}, 
      #{accessMode,jdbcType=CHAR}, #{isolationLevel,jdbcType=VARCHAR}, #{autocommit,jdbcType=CHAR}, 
      #{numberOfSavepoints,jdbcType=BIGINT}, #{numberOfRollbackToSavepoint,jdbcType=BIGINT}, 
      #{numberOfReleaseSavepoint,jdbcType=BIGINT}, #{objectInstanceBegin,jdbcType=BIGINT}, 
      #{nestingEventId,jdbcType=BIGINT}, #{nestingEventType,jdbcType=CHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, STATE, TRX_ID, GTID, XID_FORMAT_ID, 
    XID_GTRID, XID_BQUAL, XA_STATE, SOURCE, TIMER_START, TIMER_END, TIMER_WAIT, ACCESS_MODE, 
    ISOLATION_LEVEL, AUTOCOMMIT, NUMBER_OF_SAVEPOINTS, NUMBER_OF_ROLLBACK_TO_SAVEPOINT, 
    NUMBER_OF_RELEASE_SAVEPOINT, OBJECT_INSTANCE_BEGIN, NESTING_EVENT_ID, NESTING_EVENT_TYPE
    from events_transactions_history_long
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="NAME" jdbcType="VARCHAR" property="name" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from cond_instances
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into cond_instances (OBJECT_INSTANCE_BEGIN, NAME)
    values (#{objectInstanceBegin,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update cond_instances
    set NAME = #{name,jdbcType=VARCHAR}
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, NAME
    from cond_instances
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, NAME
    from cond_instances
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="lid" jdbcType="BIGINT" property="lid" />
    <result column="changes" jdbcType="TIMESTAMP" property="changes" />
    <result column="cid" jdbcType="BIGINT" property="cid" />
    <result column="mark" jdbcType="LONGVARCHAR" property="mark" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from problog
    where lid = #{lid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into problog (lid, changes, cid, 
      mark)
    values (#{lid,jdbcType=BIGINT}, #{changes,jdbcType=TIMESTAMP}, #{cid,jdbcType=BIGINT}, 
      #{mark,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update problog
    set changes = #{changes,jdbcType=TIMESTAMP},
      cid = #{cid,jdbcType=BIGINT},
      mark = #{mark,jdbcType=LONGVARCHAR}
    where lid = #{lid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select lid, changes, cid, mark
    from problog
    where lid = #{lid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select lid, changes, cid, mark
    from problog
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="gid" jdbcType="INTEGER" property="gid" />
    <result column="gname" jdbcType="VARCHAR" property="gname" />
    <result column="gmaxnum" jdbcType="INTEGER" property="gmaxnum" />
    <result column="gminnum" jdbcType="INTEGER" property="gminnum" />
    <result column="gcount" jdbcType="INTEGER" property="gcount" />
    <result column="ginfo" jdbcType="VARCHAR" property="ginfo" />
    <result column="gauthor" jdbcType="VARCHAR" property="gauthor" />
    <result column="ggroup" jdbcType="VARCHAR" property="ggroup" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from goods
    where gid = #{gid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into goods (gid, gname, gmaxnum, 
      gminnum, gcount, ginfo, 
      gauthor, ggroup)
    values (#{gid,jdbcType=INTEGER}, #{gname,jdbcType=VARCHAR}, #{gmaxnum,jdbcType=INTEGER}, 
      #{gminnum,jdbcType=INTEGER}, #{gcount,jdbcType=INTEGER}, #{ginfo,jdbcType=VARCHAR}, 
      #{gauthor,jdbcType=VARCHAR}, #{ggroup,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update goods
    set gname = #{gname,jdbcType=VARCHAR},
      gmaxnum = #{gmaxnum,jdbcType=INTEGER},
      gminnum = #{gminnum,jdbcType=INTEGER},
      gcount = #{gcount,jdbcType=INTEGER},
      ginfo = #{ginfo,jdbcType=VARCHAR},
      gauthor = #{gauthor,jdbcType=VARCHAR},
      ggroup = #{ggroup,jdbcType=VARCHAR}
    where gid = #{gid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select gid, gname, gmaxnum, gminnum, gcount, ginfo, gauthor, ggroup
    from goods
    where gid = #{gid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select gid, gname, gmaxnum, gminnum, gcount, ginfo, gauthor, ggroup
    from goods
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="EVENT_ID" jdbcType="BIGINT" property="eventId" />
    <result column="END_EVENT_ID" jdbcType="BIGINT" property="endEventId" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="SOURCE" jdbcType="VARCHAR" property="source" />
    <result column="TIMER_START" jdbcType="BIGINT" property="timerStart" />
    <result column="TIMER_END" jdbcType="BIGINT" property="timerEnd" />
    <result column="TIMER_WAIT" jdbcType="BIGINT" property="timerWait" />
    <result column="LOCK_TIME" jdbcType="BIGINT" property="lockTime" />
    <result column="DIGEST" jdbcType="VARCHAR" property="digest" />
    <result column="CURRENT_SCHEMA" jdbcType="VARCHAR" property="currentSchema" />
    <result column="OBJECT_TYPE" jdbcType="VARCHAR" property="objectType" />
    <result column="OBJECT_SCHEMA" jdbcType="VARCHAR" property="objectSchema" />
    <result column="OBJECT_NAME" jdbcType="VARCHAR" property="objectName" />
    <result column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="MYSQL_ERRNO" jdbcType="INTEGER" property="mysqlErrno" />
    <result column="RETURNED_SQLSTATE" jdbcType="VARCHAR" property="returnedSqlstate" />
    <result column="MESSAGE_TEXT" jdbcType="VARCHAR" property="messageText" />
    <result column="ERRORS" jdbcType="BIGINT" property="errors" />
    <result column="WARNINGS" jdbcType="BIGINT" property="warnings" />
    <result column="ROWS_AFFECTED" jdbcType="BIGINT" property="rowsAffected" />
    <result column="ROWS_SENT" jdbcType="BIGINT" property="rowsSent" />
    <result column="ROWS_EXAMINED" jdbcType="BIGINT" property="rowsExamined" />
    <result column="CREATED_TMP_DISK_TABLES" jdbcType="BIGINT" property="createdTmpDiskTables" />
    <result column="CREATED_TMP_TABLES" jdbcType="BIGINT" property="createdTmpTables" />
    <result column="SELECT_FULL_JOIN" jdbcType="BIGINT" property="selectFullJoin" />
    <result column="SELECT_FULL_RANGE_JOIN" jdbcType="BIGINT" property="selectFullRangeJoin" />
    <result column="SELECT_RANGE" jdbcType="BIGINT" property="selectRange" />
    <result column="SELECT_RANGE_CHECK" jdbcType="BIGINT" property="selectRangeCheck" />
    <result column="SELECT_SCAN" jdbcType="BIGINT" property="selectScan" />
    <result column="SORT_MERGE_PASSES" jdbcType="BIGINT" property="sortMergePasses" />
    <result column="SORT_RANGE" jdbcType="BIGINT" property="sortRange" />
    <result column="SORT_ROWS" jdbcType="BIGINT" property="sortRows" />
    <result column="SORT_SCAN" jdbcType="BIGINT" property="sortScan" />
    <result column="NO_INDEX_USED" jdbcType="BIGINT" property="noIndexUsed" />
    <result column="NO_GOOD_INDEX_USED" jdbcType="BIGINT" property="noGoodIndexUsed" />
    <result column="NESTING_EVENT_ID" jdbcType="BIGINT" property="nestingEventId" />
    <result column="NESTING_EVENT_TYPE" jdbcType="CHAR" property="nestingEventType" />
    <result column="NESTING_EVENT_LEVEL" jdbcType="INTEGER" property="nestingEventLevel" />
    <result column="STATEMENT_ID" jdbcType="BIGINT" property="statementId" />
    <result column="SQL_TEXT" jdbcType="LONGVARCHAR" property="sqlText" />
    <result column="DIGEST_TEXT" jdbcType="LONGVARCHAR" property="digestText" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from events_statements_history
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_statements_history (THREAD_ID, EVENT_ID, END_EVENT_ID, 
      EVENT_NAME, SOURCE, TIMER_START, 
      TIMER_END, TIMER_WAIT, LOCK_TIME, 
      DIGEST, CURRENT_SCHEMA, OBJECT_TYPE, 
      OBJECT_SCHEMA, OBJECT_NAME, OBJECT_INSTANCE_BEGIN, 
      MYSQL_ERRNO, RETURNED_SQLSTATE, MESSAGE_TEXT, 
      ERRORS, WARNINGS, ROWS_AFFECTED, 
      ROWS_SENT, ROWS_EXAMINED, CREATED_TMP_DISK_TABLES, 
      CREATED_TMP_TABLES, SELECT_FULL_JOIN, SELECT_FULL_RANGE_JOIN, 
      SELECT_RANGE, SELECT_RANGE_CHECK, SELECT_SCAN, 
      SORT_MERGE_PASSES, SORT_RANGE, SORT_ROWS, 
      SORT_SCAN, NO_INDEX_USED, NO_GOOD_INDEX_USED, 
      NESTING_EVENT_ID, NESTING_EVENT_TYPE, NESTING_EVENT_LEVEL, 
      STATEMENT_ID, SQL_TEXT, DIGEST_TEXT
      )
    values (#{threadId,jdbcType=BIGINT}, #{eventId,jdbcType=BIGINT}, #{endEventId,jdbcType=BIGINT}, 
      #{eventName,jdbcType=VARCHAR}, #{source,jdbcType=VARCHAR}, #{timerStart,jdbcType=BIGINT}, 
      #{timerEnd,jdbcType=BIGINT}, #{timerWait,jdbcType=BIGINT}, #{lockTime,jdbcType=BIGINT}, 
      #{digest,jdbcType=VARCHAR}, #{currentSchema,jdbcType=VARCHAR}, #{objectType,jdbcType=VARCHAR}, 
      #{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, #{objectInstanceBegin,jdbcType=BIGINT}, 
      #{mysqlErrno,jdbcType=INTEGER}, #{returnedSqlstate,jdbcType=VARCHAR}, #{messageText,jdbcType=VARCHAR}, 
      #{errors,jdbcType=BIGINT}, #{warnings,jdbcType=BIGINT}, #{rowsAffected,jdbcType=BIGINT}, 
      #{rowsSent,jdbcType=BIGINT}, #{rowsExamined,jdbcType=BIGINT}, #{createdTmpDiskTables,jdbcType=BIGINT}, 
      #{createdTmpTables,jdbcType=BIGINT}, #{selectFullJoin,jdbcType=BIGINT}, #{selectFullRangeJoin,jdbcType=BIGINT}, 
      #{selectRange,jdbcType=BIGINT}, #{selectRangeCheck,jdbcType=BIGINT}, #{selectScan,jdbcType=BIGINT}, 
      #{sortMergePasses,jdbcType=BIGINT}, #{sortRange,jdbcType=BIGINT}, #{sortRows,jdbcType=BIGINT}, 
      #{sortScan,jdbcType=BIGINT}, #{noIndexUsed,jdbcType=BIGINT}, #{noGoodIndexUsed,jdbcType=BIGINT}, 
      #{nestingEventId,jdbcType=BIGINT}, #{nestingEventType,jdbcType=CHAR}, #{nestingEventLevel,jdbcType=INTEGER}, 
      #{statementId,jdbcType=BIGINT}, #{sqlText,jdbcType=LONGVARCHAR}, #{digestText,jdbcType=LONGVARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_statements_history
    set END_EVENT_ID = #{endEventId,jdbcType=BIGINT},
      EVENT_NAME = #{eventName,jdbcType=VARCHAR},
      SOURCE = #{source,jdbcType=VARCHAR},
      TIMER_START = #{timerStart,jdbcType=BIGINT},
      TIMER_END = #{timerEnd,jdbcType=BIGINT},
      TIMER_WAIT = #{timerWait,jdbcType=BIGINT},
      LOCK_TIME = #{lockTime,jdbcType=BIGINT},
      DIGEST = #{digest,jdbcType=VARCHAR},
      CURRENT_SCHEMA = #{currentSchema,jdbcType=VARCHAR},
      OBJECT_TYPE = #{objectType,jdbcType=VARCHAR},
      OBJECT_SCHEMA = #{objectSchema,jdbcType=VARCHAR},
      OBJECT_NAME = #{objectName,jdbcType=VARCHAR},
      OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT},
      MYSQL_ERRNO = #{mysqlErrno,jdbcType=INTEGER},
      RETURNED_SQLSTATE = #{returnedSqlstate,jdbcType=VARCHAR},
      MESSAGE_TEXT = #{messageText,jdbcType=VARCHAR},
      ERRORS = #{errors,jdbcType=BIGINT},
      WARNINGS = #{warnings,jdbcType=BIGINT},
      ROWS_AFFECTED = #{rowsAffected,jdbcType=BIGINT},
      ROWS_SENT = #{rowsSent,jdbcType=BIGINT},
      ROWS_EXAMINED = #{rowsExamined,jdbcType=BIGINT},
      CREATED_TMP_DISK_TABLES = #{createdTmpDiskTables,jdbcType=BIGINT},
      CREATED_TMP_TABLES = #{createdTmpTables,jdbcType=BIGINT},
      SELECT_FULL_JOIN = #{selectFullJoin,jdbcType=BIGINT},
      SELECT_FULL_RANGE_JOIN = #{selectFullRangeJoin,jdbcType=BIGINT},
      SELECT_RANGE = #{selectRange,jdbcType=BIGINT},
      SELECT_RANGE_CHECK = #{selectRangeCheck,jdbcType=BIGINT},
      SELECT_SCAN = #{selectScan,jdbcType=BIGINT},
      SORT_MERGE_PASSES = #{sortMergePasses,jdbcType=BIGINT},
      SORT_RANGE = #{sortRange,jdbcType=BIGINT},
      SORT_ROWS = #{sortRows,jdbcType=BIGINT},
      SORT_SCAN = #{sortScan,jdbcType=BIGINT},
      NO_INDEX_USED = #{noIndexUsed,jdbcType=BIGINT},
      NO_GOOD_INDEX_USED = #{noGoodIndexUsed,jdbcType=BIGINT},
      NESTING_EVENT_ID = #{nestingEventId,jdbcType=BIGINT},
      NESTING_EVENT_TYPE = #{nestingEventType,jdbcType=CHAR},
      NESTING_EVENT_LEVEL = #{nestingEventLevel,jdbcType=INTEGER},
      STATEMENT_ID = #{statementId,jdbcType=BIGINT},
      SQL_TEXT = #{sqlText,jdbcType=LONGVARCHAR},
      DIGEST_TEXT = #{digestText,jdbcType=LONGVARCHAR}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, SOURCE, TIMER_START, TIMER_END, 
    TIMER_WAIT, LOCK_TIME, DIGEST, CURRENT_SCHEMA, OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, 
    OBJECT_INSTANCE_BEGIN, MYSQL_ERRNO, RETURNED_SQLSTATE, MESSAGE_TEXT, ERRORS, WARNINGS, 
    ROWS_AFFECTED, ROWS_SENT, ROWS_EXAMINED, CREATED_TMP_DISK_TABLES, CREATED_TMP_TABLES, 
    SELECT_FULL_JOIN, SELECT_FULL_RANGE_JOIN, SELECT_RANGE, SELECT_RANGE_CHECK, SELECT_SCAN, 
    SORT_MERGE_PASSES, SORT_RANGE, SORT_ROWS, SORT_SCAN, NO_INDEX_USED, NO_GOOD_INDEX_USED, 
    NESTING_EVENT_ID, NESTING_EVENT_TYPE, NESTING_EVENT_LEVEL, STATEMENT_ID, SQL_TEXT, 
    DIGEST_TEXT
    from events_statements_history
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, SOURCE, TIMER_START, TIMER_END, 
    TIMER_WAIT, LOCK_TIME, DIGEST, CURRENT_SCHEMA, OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, 
    OBJECT_INSTANCE_BEGIN, MYSQL_ERRNO, RETURNED_SQLSTATE, MESSAGE_TEXT, ERRORS, WARNINGS, 
    ROWS_AFFECTED, ROWS_SENT, ROWS_EXAMINED, CREATED_TMP_DISK_TABLES, CREATED_TMP_TABLES, 
    SELECT_FULL_JOIN, SELECT_FULL_RANGE_JOIN, SELECT_RANGE, SELECT_RANGE_CHECK, SELECT_SCAN, 
    SORT_MERGE_PASSES, SORT_RANGE, SORT_ROWS, SORT_SCAN, NO_INDEX_USED, NO_GOOD_INDEX_USED, 
    NESTING_EVENT_ID, NESTING_EVENT_TYPE, NESTING_EVENT_LEVEL, STATEMENT_ID, SQL_TEXT, 
    DIGEST_TEXT
    from events_statements_history
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="TABLE_CATALOG" jdbcType="VARCHAR" property="tableCatalog" />
    <result column="TABLE_SCHEMA" jdbcType="VARCHAR" property="tableSchema" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
    <result column="CHECK_OPTION" jdbcType="CHAR" property="checkOption" />
    <result column="IS_UPDATABLE" jdbcType="CHAR" property="isUpdatable" />
    <result column="DEFINER" jdbcType="VARCHAR" property="definer" />
    <result column="SECURITY_TYPE" jdbcType="VARCHAR" property="securityType" />
    <result column="CHARACTER_SET_CLIENT" jdbcType="VARCHAR" property="characterSetClient" />
    <result column="COLLATION_CONNECTION" jdbcType="VARCHAR" property="collationConnection" />
    <result column="VIEW_DEFINITION" jdbcType="LONGVARCHAR" property="viewDefinition" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into VIEWS (TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, 
      CHECK_OPTION, IS_UPDATABLE, DEFINER, 
      SECURITY_TYPE, CHARACTER_SET_CLIENT, COLLATION_CONNECTION, 
      VIEW_DEFINITION)
    values (#{tableCatalog,jdbcType=VARCHAR}, #{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, 
      #{checkOption,jdbcType=CHAR}, #{isUpdatable,jdbcType=CHAR}, #{definer,jdbcType=VARCHAR}, 
      #{securityType,jdbcType=VARCHAR}, #{characterSetClient,jdbcType=VARCHAR}, #{collationConnection,jdbcType=VARCHAR}, 
      #{viewDefinition,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, CHECK_OPTION, IS_UPDATABLE, DEFINER, 
    SECURITY_TYPE, CHARACTER_SET_CLIENT, COLLATION_CONNECTION, VIEW_DEFINITION
    from VIEWS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="total" jdbcType="DECIMAL" property="total" />
    <result column="rows_sent" jdbcType="DECIMAL" property="rowsSent" />
    <result column="rows_examined" jdbcType="DECIMAL" property="rowsExamined" />
    <result column="rows_affected" jdbcType="DECIMAL" property="rowsAffected" />
    <result column="full_scans" jdbcType="DECIMAL" property="fullScans" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
    <result column="lock_latency" jdbcType="LONGVARCHAR" property="lockLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into user_summary_by_statement_latency (user, total, rows_sent, 
      rows_examined, rows_affected, full_scans, 
      total_latency, max_latency, lock_latency
      )
    values (#{user,jdbcType=VARCHAR}, #{total,jdbcType=DECIMAL}, #{rowsSent,jdbcType=DECIMAL}, 
      #{rowsExamined,jdbcType=DECIMAL}, #{rowsAffected,jdbcType=DECIMAL}, #{fullScans,jdbcType=DECIMAL}, 
      #{totalLatency,jdbcType=LONGVARCHAR}, #{maxLatency,jdbcType=LONGVARCHAR}, #{lockLatency,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, total, rows_sent, rows_examined, rows_affected, full_scans, total_latency, 
    max_latency, lock_latency
    from user_summary_by_statement_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="thread_id" jdbcType="BIGINT" property="threadId" />
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="current_count_used" jdbcType="DECIMAL" property="currentCountUsed" />
    <result column="current_allocated" jdbcType="LONGVARCHAR" property="currentAllocated" />
    <result column="current_avg_alloc" jdbcType="LONGVARCHAR" property="currentAvgAlloc" />
    <result column="current_max_alloc" jdbcType="LONGVARCHAR" property="currentMaxAlloc" />
    <result column="total_allocated" jdbcType="LONGVARCHAR" property="totalAllocated" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into memory_by_thread_by_current_bytes (thread_id, user, current_count_used, 
      current_allocated, current_avg_alloc, 
      current_max_alloc, total_allocated
      )
    values (#{threadId,jdbcType=BIGINT}, #{user,jdbcType=VARCHAR}, #{currentCountUsed,jdbcType=DECIMAL}, 
      #{currentAllocated,jdbcType=LONGVARCHAR}, #{currentAvgAlloc,jdbcType=LONGVARCHAR}, 
      #{currentMaxAlloc,jdbcType=LONGVARCHAR}, #{totalAllocated,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select thread_id, user, current_count_used, current_allocated, current_avg_alloc, 
    current_max_alloc, total_allocated
    from memory_by_thread_by_current_bytes
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="OBJECT_TYPE" jdbcType="VARCHAR" property="objectType" />
    <result column="OBJECT_SCHEMA" jdbcType="VARCHAR" property="objectSchema" />
    <result column="OBJECT_NAME" jdbcType="VARCHAR" property="objectName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="COUNT_READ" jdbcType="BIGINT" property="countRead" />
    <result column="SUM_TIMER_READ" jdbcType="BIGINT" property="sumTimerRead" />
    <result column="MIN_TIMER_READ" jdbcType="BIGINT" property="minTimerRead" />
    <result column="AVG_TIMER_READ" jdbcType="BIGINT" property="avgTimerRead" />
    <result column="MAX_TIMER_READ" jdbcType="BIGINT" property="maxTimerRead" />
    <result column="COUNT_WRITE" jdbcType="BIGINT" property="countWrite" />
    <result column="SUM_TIMER_WRITE" jdbcType="BIGINT" property="sumTimerWrite" />
    <result column="MIN_TIMER_WRITE" jdbcType="BIGINT" property="minTimerWrite" />
    <result column="AVG_TIMER_WRITE" jdbcType="BIGINT" property="avgTimerWrite" />
    <result column="MAX_TIMER_WRITE" jdbcType="BIGINT" property="maxTimerWrite" />
    <result column="COUNT_READ_NORMAL" jdbcType="BIGINT" property="countReadNormal" />
    <result column="SUM_TIMER_READ_NORMAL" jdbcType="BIGINT" property="sumTimerReadNormal" />
    <result column="MIN_TIMER_READ_NORMAL" jdbcType="BIGINT" property="minTimerReadNormal" />
    <result column="AVG_TIMER_READ_NORMAL" jdbcType="BIGINT" property="avgTimerReadNormal" />
    <result column="MAX_TIMER_READ_NORMAL" jdbcType="BIGINT" property="maxTimerReadNormal" />
    <result column="COUNT_READ_WITH_SHARED_LOCKS" jdbcType="BIGINT" property="countReadWithSharedLocks" />
    <result column="SUM_TIMER_READ_WITH_SHARED_LOCKS" jdbcType="BIGINT" property="sumTimerReadWithSharedLocks" />
    <result column="MIN_TIMER_READ_WITH_SHARED_LOCKS" jdbcType="BIGINT" property="minTimerReadWithSharedLocks" />
    <result column="AVG_TIMER_READ_WITH_SHARED_LOCKS" jdbcType="BIGINT" property="avgTimerReadWithSharedLocks" />
    <result column="MAX_TIMER_READ_WITH_SHARED_LOCKS" jdbcType="BIGINT" property="maxTimerReadWithSharedLocks" />
    <result column="COUNT_READ_HIGH_PRIORITY" jdbcType="BIGINT" property="countReadHighPriority" />
    <result column="SUM_TIMER_READ_HIGH_PRIORITY" jdbcType="BIGINT" property="sumTimerReadHighPriority" />
    <result column="MIN_TIMER_READ_HIGH_PRIORITY" jdbcType="BIGINT" property="minTimerReadHighPriority" />
    <result column="AVG_TIMER_READ_HIGH_PRIORITY" jdbcType="BIGINT" property="avgTimerReadHighPriority" />
    <result column="MAX_TIMER_READ_HIGH_PRIORITY" jdbcType="BIGINT" property="maxTimerReadHighPriority" />
    <result column="COUNT_READ_NO_INSERT" jdbcType="BIGINT" property="countReadNoInsert" />
    <result column="SUM_TIMER_READ_NO_INSERT" jdbcType="BIGINT" property="sumTimerReadNoInsert" />
    <result column="MIN_TIMER_READ_NO_INSERT" jdbcType="BIGINT" property="minTimerReadNoInsert" />
    <result column="AVG_TIMER_READ_NO_INSERT" jdbcType="BIGINT" property="avgTimerReadNoInsert" />
    <result column="MAX_TIMER_READ_NO_INSERT" jdbcType="BIGINT" property="maxTimerReadNoInsert" />
    <result column="COUNT_READ_EXTERNAL" jdbcType="BIGINT" property="countReadExternal" />
    <result column="SUM_TIMER_READ_EXTERNAL" jdbcType="BIGINT" property="sumTimerReadExternal" />
    <result column="MIN_TIMER_READ_EXTERNAL" jdbcType="BIGINT" property="minTimerReadExternal" />
    <result column="AVG_TIMER_READ_EXTERNAL" jdbcType="BIGINT" property="avgTimerReadExternal" />
    <result column="MAX_TIMER_READ_EXTERNAL" jdbcType="BIGINT" property="maxTimerReadExternal" />
    <result column="COUNT_WRITE_ALLOW_WRITE" jdbcType="BIGINT" property="countWriteAllowWrite" />
    <result column="SUM_TIMER_WRITE_ALLOW_WRITE" jdbcType="BIGINT" property="sumTimerWriteAllowWrite" />
    <result column="MIN_TIMER_WRITE_ALLOW_WRITE" jdbcType="BIGINT" property="minTimerWriteAllowWrite" />
    <result column="AVG_TIMER_WRITE_ALLOW_WRITE" jdbcType="BIGINT" property="avgTimerWriteAllowWrite" />
    <result column="MAX_TIMER_WRITE_ALLOW_WRITE" jdbcType="BIGINT" property="maxTimerWriteAllowWrite" />
    <result column="COUNT_WRITE_CONCURRENT_INSERT" jdbcType="BIGINT" property="countWriteConcurrentInsert" />
    <result column="SUM_TIMER_WRITE_CONCURRENT_INSERT" jdbcType="BIGINT" property="sumTimerWriteConcurrentInsert" />
    <result column="MIN_TIMER_WRITE_CONCURRENT_INSERT" jdbcType="BIGINT" property="minTimerWriteConcurrentInsert" />
    <result column="AVG_TIMER_WRITE_CONCURRENT_INSERT" jdbcType="BIGINT" property="avgTimerWriteConcurrentInsert" />
    <result column="MAX_TIMER_WRITE_CONCURRENT_INSERT" jdbcType="BIGINT" property="maxTimerWriteConcurrentInsert" />
    <result column="COUNT_WRITE_LOW_PRIORITY" jdbcType="BIGINT" property="countWriteLowPriority" />
    <result column="SUM_TIMER_WRITE_LOW_PRIORITY" jdbcType="BIGINT" property="sumTimerWriteLowPriority" />
    <result column="MIN_TIMER_WRITE_LOW_PRIORITY" jdbcType="BIGINT" property="minTimerWriteLowPriority" />
    <result column="AVG_TIMER_WRITE_LOW_PRIORITY" jdbcType="BIGINT" property="avgTimerWriteLowPriority" />
    <result column="MAX_TIMER_WRITE_LOW_PRIORITY" jdbcType="BIGINT" property="maxTimerWriteLowPriority" />
    <result column="COUNT_WRITE_NORMAL" jdbcType="BIGINT" property="countWriteNormal" />
    <result column="SUM_TIMER_WRITE_NORMAL" jdbcType="BIGINT" property="sumTimerWriteNormal" />
    <result column="MIN_TIMER_WRITE_NORMAL" jdbcType="BIGINT" property="minTimerWriteNormal" />
    <result column="AVG_TIMER_WRITE_NORMAL" jdbcType="BIGINT" property="avgTimerWriteNormal" />
    <result column="MAX_TIMER_WRITE_NORMAL" jdbcType="BIGINT" property="maxTimerWriteNormal" />
    <result column="COUNT_WRITE_EXTERNAL" jdbcType="BIGINT" property="countWriteExternal" />
    <result column="SUM_TIMER_WRITE_EXTERNAL" jdbcType="BIGINT" property="sumTimerWriteExternal" />
    <result column="MIN_TIMER_WRITE_EXTERNAL" jdbcType="BIGINT" property="minTimerWriteExternal" />
    <result column="AVG_TIMER_WRITE_EXTERNAL" jdbcType="BIGINT" property="avgTimerWriteExternal" />
    <result column="MAX_TIMER_WRITE_EXTERNAL" jdbcType="BIGINT" property="maxTimerWriteExternal" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into table_lock_waits_summary_by_table (OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, 
      COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
      AVG_TIMER_WAIT, MAX_TIMER_WAIT, COUNT_READ, 
      SUM_TIMER_READ, MIN_TIMER_READ, AVG_TIMER_READ, 
      MAX_TIMER_READ, COUNT_WRITE, SUM_TIMER_WRITE, 
      MIN_TIMER_WRITE, AVG_TIMER_WRITE, MAX_TIMER_WRITE, 
      COUNT_READ_NORMAL, SUM_TIMER_READ_NORMAL, MIN_TIMER_READ_NORMAL, 
      AVG_TIMER_READ_NORMAL, MAX_TIMER_READ_NORMAL, COUNT_READ_WITH_SHARED_LOCKS, 
      SUM_TIMER_READ_WITH_SHARED_LOCKS, MIN_TIMER_READ_WITH_SHARED_LOCKS, 
      AVG_TIMER_READ_WITH_SHARED_LOCKS, MAX_TIMER_READ_WITH_SHARED_LOCKS, 
      COUNT_READ_HIGH_PRIORITY, SUM_TIMER_READ_HIGH_PRIORITY, 
      MIN_TIMER_READ_HIGH_PRIORITY, AVG_TIMER_READ_HIGH_PRIORITY, 
      MAX_TIMER_READ_HIGH_PRIORITY, COUNT_READ_NO_INSERT, 
      SUM_TIMER_READ_NO_INSERT, MIN_TIMER_READ_NO_INSERT, 
      AVG_TIMER_READ_NO_INSERT, MAX_TIMER_READ_NO_INSERT, 
      COUNT_READ_EXTERNAL, SUM_TIMER_READ_EXTERNAL, 
      MIN_TIMER_READ_EXTERNAL, AVG_TIMER_READ_EXTERNAL, 
      MAX_TIMER_READ_EXTERNAL, COUNT_WRITE_ALLOW_WRITE, 
      SUM_TIMER_WRITE_ALLOW_WRITE, MIN_TIMER_WRITE_ALLOW_WRITE, 
      AVG_TIMER_WRITE_ALLOW_WRITE, MAX_TIMER_WRITE_ALLOW_WRITE, 
      COUNT_WRITE_CONCURRENT_INSERT, SUM_TIMER_WRITE_CONCURRENT_INSERT, 
      MIN_TIMER_WRITE_CONCURRENT_INSERT, AVG_TIMER_WRITE_CONCURRENT_INSERT, 
      MAX_TIMER_WRITE_CONCURRENT_INSERT, COUNT_WRITE_LOW_PRIORITY, 
      SUM_TIMER_WRITE_LOW_PRIORITY, MIN_TIMER_WRITE_LOW_PRIORITY, 
      AVG_TIMER_WRITE_LOW_PRIORITY, MAX_TIMER_WRITE_LOW_PRIORITY, 
      COUNT_WRITE_NORMAL, SUM_TIMER_WRITE_NORMAL, MIN_TIMER_WRITE_NORMAL, 
      AVG_TIMER_WRITE_NORMAL, MAX_TIMER_WRITE_NORMAL, 
      COUNT_WRITE_EXTERNAL, SUM_TIMER_WRITE_EXTERNAL, 
      MIN_TIMER_WRITE_EXTERNAL, AVG_TIMER_WRITE_EXTERNAL, 
      MAX_TIMER_WRITE_EXTERNAL)
    values (#{objectType,jdbcType=VARCHAR}, #{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, 
      #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, 
      #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT}, #{countRead,jdbcType=BIGINT}, 
      #{sumTimerRead,jdbcType=BIGINT}, #{minTimerRead,jdbcType=BIGINT}, #{avgTimerRead,jdbcType=BIGINT}, 
      #{maxTimerRead,jdbcType=BIGINT}, #{countWrite,jdbcType=BIGINT}, #{sumTimerWrite,jdbcType=BIGINT}, 
      #{minTimerWrite,jdbcType=BIGINT}, #{avgTimerWrite,jdbcType=BIGINT}, #{maxTimerWrite,jdbcType=BIGINT}, 
      #{countReadNormal,jdbcType=BIGINT}, #{sumTimerReadNormal,jdbcType=BIGINT}, #{minTimerReadNormal,jdbcType=BIGINT}, 
      #{avgTimerReadNormal,jdbcType=BIGINT}, #{maxTimerReadNormal,jdbcType=BIGINT}, #{countReadWithSharedLocks,jdbcType=BIGINT}, 
      #{sumTimerReadWithSharedLocks,jdbcType=BIGINT}, #{minTimerReadWithSharedLocks,jdbcType=BIGINT}, 
      #{avgTimerReadWithSharedLocks,jdbcType=BIGINT}, #{maxTimerReadWithSharedLocks,jdbcType=BIGINT}, 
      #{countReadHighPriority,jdbcType=BIGINT}, #{sumTimerReadHighPriority,jdbcType=BIGINT}, 
      #{minTimerReadHighPriority,jdbcType=BIGINT}, #{avgTimerReadHighPriority,jdbcType=BIGINT}, 
      #{maxTimerReadHighPriority,jdbcType=BIGINT}, #{countReadNoInsert,jdbcType=BIGINT}, 
      #{sumTimerReadNoInsert,jdbcType=BIGINT}, #{minTimerReadNoInsert,jdbcType=BIGINT}, 
      #{avgTimerReadNoInsert,jdbcType=BIGINT}, #{maxTimerReadNoInsert,jdbcType=BIGINT}, 
      #{countReadExternal,jdbcType=BIGINT}, #{sumTimerReadExternal,jdbcType=BIGINT}, 
      #{minTimerReadExternal,jdbcType=BIGINT}, #{avgTimerReadExternal,jdbcType=BIGINT}, 
      #{maxTimerReadExternal,jdbcType=BIGINT}, #{countWriteAllowWrite,jdbcType=BIGINT}, 
      #{sumTimerWriteAllowWrite,jdbcType=BIGINT}, #{minTimerWriteAllowWrite,jdbcType=BIGINT}, 
      #{avgTimerWriteAllowWrite,jdbcType=BIGINT}, #{maxTimerWriteAllowWrite,jdbcType=BIGINT}, 
      #{countWriteConcurrentInsert,jdbcType=BIGINT}, #{sumTimerWriteConcurrentInsert,jdbcType=BIGINT}, 
      #{minTimerWriteConcurrentInsert,jdbcType=BIGINT}, #{avgTimerWriteConcurrentInsert,jdbcType=BIGINT}, 
      #{maxTimerWriteConcurrentInsert,jdbcType=BIGINT}, #{countWriteLowPriority,jdbcType=BIGINT}, 
      #{sumTimerWriteLowPriority,jdbcType=BIGINT}, #{minTimerWriteLowPriority,jdbcType=BIGINT}, 
      #{avgTimerWriteLowPriority,jdbcType=BIGINT}, #{maxTimerWriteLowPriority,jdbcType=BIGINT}, 
      #{countWriteNormal,jdbcType=BIGINT}, #{sumTimerWriteNormal,jdbcType=BIGINT}, #{minTimerWriteNormal,jdbcType=BIGINT}, 
      #{avgTimerWriteNormal,jdbcType=BIGINT}, #{maxTimerWriteNormal,jdbcType=BIGINT}, 
      #{countWriteExternal,jdbcType=BIGINT}, #{sumTimerWriteExternal,jdbcType=BIGINT}, 
      #{minTimerWriteExternal,jdbcType=BIGINT}, #{avgTimerWriteExternal,jdbcType=BIGINT}, 
      #{maxTimerWriteExternal,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
    AVG_TIMER_WAIT, MAX_TIMER_WAIT, COUNT_READ, SUM_TIMER_READ, MIN_TIMER_READ, AVG_TIMER_READ, 
    MAX_TIMER_READ, COUNT_WRITE, SUM_TIMER_WRITE, MIN_TIMER_WRITE, AVG_TIMER_WRITE, MAX_TIMER_WRITE, 
    COUNT_READ_NORMAL, SUM_TIMER_READ_NORMAL, MIN_TIMER_READ_NORMAL, AVG_TIMER_READ_NORMAL, 
    MAX_TIMER_READ_NORMAL, COUNT_READ_WITH_SHARED_LOCKS, SUM_TIMER_READ_WITH_SHARED_LOCKS, 
    MIN_TIMER_READ_WITH_SHARED_LOCKS, AVG_TIMER_READ_WITH_SHARED_LOCKS, MAX_TIMER_READ_WITH_SHARED_LOCKS, 
    COUNT_READ_HIGH_PRIORITY, SUM_TIMER_READ_HIGH_PRIORITY, MIN_TIMER_READ_HIGH_PRIORITY, 
    AVG_TIMER_READ_HIGH_PRIORITY, MAX_TIMER_READ_HIGH_PRIORITY, COUNT_READ_NO_INSERT, 
    SUM_TIMER_READ_NO_INSERT, MIN_TIMER_READ_NO_INSERT, AVG_TIMER_READ_NO_INSERT, MAX_TIMER_READ_NO_INSERT, 
    COUNT_READ_EXTERNAL, SUM_TIMER_READ_EXTERNAL, MIN_TIMER_READ_EXTERNAL, AVG_TIMER_READ_EXTERNAL, 
    MAX_TIMER_READ_EXTERNAL, COUNT_WRITE_ALLOW_WRITE, SUM_TIMER_WRITE_ALLOW_WRITE, MIN_TIMER_WRITE_ALLOW_WRITE, 
    AVG_TIMER_WRITE_ALLOW_WRITE, MAX_TIMER_WRITE_ALLOW_WRITE, COUNT_WRITE_CONCURRENT_INSERT, 
    SUM_TIMER_WRITE_CONCURRENT_INSERT, MIN_TIMER_WRITE_CONCURRENT_INSERT, AVG_TIMER_WRITE_CONCURRENT_INSERT, 
    MAX_TIMER_WRITE_CONCURRENT_INSERT, COUNT_WRITE_LOW_PRIORITY, SUM_TIMER_WRITE_LOW_PRIORITY, 
    MIN_TIMER_WRITE_LOW_PRIORITY, AVG_TIMER_WRITE_LOW_PRIORITY, MAX_TIMER_WRITE_LOW_PRIORITY, 
    COUNT_WRITE_NORMAL, SUM_TIMER_WRITE_NORMAL, MIN_TIMER_WRITE_NORMAL, AVG_TIMER_WRITE_NORMAL, 
    MAX_TIMER_WRITE_NORMAL, COUNT_WRITE_EXTERNAL, SUM_TIMER_WRITE_EXTERNAL, MIN_TIMER_WRITE_EXTERNAL, 
    AVG_TIMER_WRITE_EXTERNAL, MAX_TIMER_WRITE_EXTERNAL
    from table_lock_waits_summary_by_table
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="SPECIFIC_CATALOG" jdbcType="VARCHAR" property="specificCatalog" />
    <result column="SPECIFIC_SCHEMA" jdbcType="VARCHAR" property="specificSchema" />
    <result column="SPECIFIC_NAME" jdbcType="VARCHAR" property="specificName" />
    <result column="ORDINAL_POSITION" jdbcType="BIGINT" property="ordinalPosition" />
    <result column="PARAMETER_MODE" jdbcType="VARCHAR" property="parameterMode" />
    <result column="PARAMETER_NAME" jdbcType="VARCHAR" property="parameterName" />
    <result column="CHARACTER_MAXIMUM_LENGTH" jdbcType="BIGINT" property="characterMaximumLength" />
    <result column="CHARACTER_OCTET_LENGTH" jdbcType="BIGINT" property="characterOctetLength" />
    <result column="NUMERIC_PRECISION" jdbcType="INTEGER" property="numericPrecision" />
    <result column="NUMERIC_SCALE" jdbcType="BIGINT" property="numericScale" />
    <result column="DATETIME_PRECISION" jdbcType="INTEGER" property="datetimePrecision" />
    <result column="CHARACTER_SET_NAME" jdbcType="VARCHAR" property="characterSetName" />
    <result column="COLLATION_NAME" jdbcType="VARCHAR" property="collationName" />
    <result column="ROUTINE_TYPE" jdbcType="CHAR" property="routineType" />
    <result column="DATA_TYPE" jdbcType="LONGVARCHAR" property="dataType" />
    <result column="DTD_IDENTIFIER" jdbcType="LONGVARCHAR" property="dtdIdentifier" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into PARAMETERS (SPECIFIC_CATALOG, SPECIFIC_SCHEMA, 
      SPECIFIC_NAME, ORDINAL_POSITION, PARAMETER_MODE, 
      PARAMETER_NAME, CHARACTER_MAXIMUM_LENGTH, CHARACTER_OCTET_LENGTH, 
      NUMERIC_PRECISION, NUMERIC_SCALE, DATETIME_PRECISION, 
      CHARACTER_SET_NAME, COLLATION_NAME, ROUTINE_TYPE, 
      DATA_TYPE, DTD_IDENTIFIER)
    values (#{specificCatalog,jdbcType=VARCHAR}, #{specificSchema,jdbcType=VARCHAR}, 
      #{specificName,jdbcType=VARCHAR}, #{ordinalPosition,jdbcType=BIGINT}, #{parameterMode,jdbcType=VARCHAR}, 
      #{parameterName,jdbcType=VARCHAR}, #{characterMaximumLength,jdbcType=BIGINT}, #{characterOctetLength,jdbcType=BIGINT}, 
      #{numericPrecision,jdbcType=INTEGER}, #{numericScale,jdbcType=BIGINT}, #{datetimePrecision,jdbcType=INTEGER}, 
      #{characterSetName,jdbcType=VARCHAR}, #{collationName,jdbcType=VARCHAR}, #{routineType,jdbcType=CHAR}, 
      #{dataType,jdbcType=LONGVARCHAR}, #{dtdIdentifier,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select SPECIFIC_CATALOG, SPECIFIC_SCHEMA, SPECIFIC_NAME, ORDINAL_POSITION, PARAMETER_MODE, 
    PARAMETER_NAME, CHARACTER_MAXIMUM_LENGTH, CHARACTER_OCTET_LENGTH, NUMERIC_PRECISION, 
    NUMERIC_SCALE, DATETIME_PRECISION, CHARACTER_SET_NAME, COLLATION_NAME, ROUTINE_TYPE, 
    DATA_TYPE, DTD_IDENTIFIER
    from PARAMETERS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="full_scan" jdbcType="VARCHAR" property="fullScan" />
    <result column="exec_count" jdbcType="BIGINT" property="execCount" />
    <result column="err_count" jdbcType="BIGINT" property="errCount" />
    <result column="warn_count" jdbcType="BIGINT" property="warnCount" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="max_latency" jdbcType="BIGINT" property="maxLatency" />
    <result column="avg_latency" jdbcType="BIGINT" property="avgLatency" />
    <result column="rows_sent" jdbcType="BIGINT" property="rowsSent" />
    <result column="rows_sent_avg" jdbcType="DECIMAL" property="rowsSentAvg" />
    <result column="rows_examined" jdbcType="BIGINT" property="rowsExamined" />
    <result column="rows_examined_avg" jdbcType="DECIMAL" property="rowsExaminedAvg" />
    <result column="first_seen" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="last_seen" jdbcType="TIMESTAMP" property="lastSeen" />
    <result column="digest" jdbcType="VARCHAR" property="digest" />
    <result column="query" jdbcType="LONGVARCHAR" property="query" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$statements_with_runtimes_in_95th_percentile (db, full_scan, exec_count, 
      err_count, warn_count, total_latency, 
      max_latency, avg_latency, rows_sent, 
      rows_sent_avg, rows_examined, rows_examined_avg, 
      first_seen, last_seen, digest, 
      query)
    values (#{db,jdbcType=VARCHAR}, #{fullScan,jdbcType=VARCHAR}, #{execCount,jdbcType=BIGINT}, 
      #{errCount,jdbcType=BIGINT}, #{warnCount,jdbcType=BIGINT}, #{totalLatency,jdbcType=BIGINT}, 
      #{maxLatency,jdbcType=BIGINT}, #{avgLatency,jdbcType=BIGINT}, #{rowsSent,jdbcType=BIGINT}, 
      #{rowsSentAvg,jdbcType=DECIMAL}, #{rowsExamined,jdbcType=BIGINT}, #{rowsExaminedAvg,jdbcType=DECIMAL}, 
      #{firstSeen,jdbcType=TIMESTAMP}, #{lastSeen,jdbcType=TIMESTAMP}, #{digest,jdbcType=VARCHAR}, 
      #{query,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select db, full_scan, exec_count, err_count, warn_count, total_latency, max_latency, 
    avg_latency, rows_sent, rows_sent_avg, rows_examined, rows_examined_avg, first_seen, 
    last_seen, digest, query
    from x$statements_with_runtimes_in_95th_percentile
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="xid" jdbcType="INTEGER" property="xid" />
    <result column="fid" jdbcType="INTEGER" property="fid" />
    <result column="tid" jdbcType="INTEGER" property="tid" />
    <result column="eid" jdbcType="INTEGER" property="eid" />
    <result column="begintime" jdbcType="VARCHAR" property="begintime" />
    <result column="Endtime" jdbcType="VARCHAR" property="endtime" />
    <result column="xmoney" jdbcType="REAL" property="xmoney" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from broad
    where xid = #{xid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into broad (xid, fid, tid, 
      eid, begintime, Endtime, 
      xmoney)
    values (#{xid,jdbcType=INTEGER}, #{fid,jdbcType=INTEGER}, #{tid,jdbcType=INTEGER}, 
      #{eid,jdbcType=INTEGER}, #{begintime,jdbcType=VARCHAR}, #{endtime,jdbcType=VARCHAR}, 
      #{xmoney,jdbcType=REAL})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update broad
    set fid = #{fid,jdbcType=INTEGER},
      tid = #{tid,jdbcType=INTEGER},
      eid = #{eid,jdbcType=INTEGER},
      begintime = #{begintime,jdbcType=VARCHAR},
      Endtime = #{endtime,jdbcType=VARCHAR},
      xmoney = #{xmoney,jdbcType=REAL}
    where xid = #{xid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select xid, fid, tid, eid, begintime, Endtime, xmoney
    from broad
    where xid = #{xid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select xid, fid, tid, eid, begintime, Endtime, xmoney
    from broad
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Host" jdbcType="CHAR" property="host" />
    <id column="User" jdbcType="CHAR" property="user" />
    <id column="Proxied_host" jdbcType="CHAR" property="proxiedHost" />
    <id column="Proxied_user" jdbcType="CHAR" property="proxiedUser" />
    <result column="With_grant" jdbcType="BIT" property="withGrant" />
    <result column="Grantor" jdbcType="CHAR" property="grantor" />
    <result column="Timestamp" jdbcType="TIMESTAMP" property="timestamp" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from proxies_priv
    where Host = #{host,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
      and Proxied_host = #{proxiedHost,jdbcType=CHAR}
      and Proxied_user = #{proxiedUser,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into proxies_priv (Host, User, Proxied_host, 
      Proxied_user, With_grant, Grantor, 
      Timestamp)
    values (#{host,jdbcType=CHAR}, #{user,jdbcType=CHAR}, #{proxiedHost,jdbcType=CHAR}, 
      #{proxiedUser,jdbcType=CHAR}, #{withGrant,jdbcType=BIT}, #{grantor,jdbcType=CHAR}, 
      #{timestamp,jdbcType=TIMESTAMP})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update proxies_priv
    set With_grant = #{withGrant,jdbcType=BIT},
      Grantor = #{grantor,jdbcType=CHAR},
      Timestamp = #{timestamp,jdbcType=TIMESTAMP}
    where Host = #{host,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
      and Proxied_host = #{proxiedHost,jdbcType=CHAR}
      and Proxied_user = #{proxiedUser,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select Host, User, Proxied_host, Proxied_user, With_grant, Grantor, Timestamp
    from proxies_priv
    where Host = #{host,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
      and Proxied_host = #{proxiedHost,jdbcType=CHAR}
      and Proxied_user = #{proxiedUser,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Host, User, Proxied_host, Proxied_user, With_grant, Grantor, Timestamp
    from proxies_priv
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="sid" jdbcType="INTEGER" property="sid" />
    <result column="sname" jdbcType="VARCHAR" property="sname" />
    <result column="sex" jdbcType="VARCHAR" property="sex" />
    <result column="age" jdbcType="INTEGER" property="age" />
    <result column="classes" jdbcType="VARCHAR" property="classes" />
    <result column="sgroups" jdbcType="VARCHAR" property="sgroups" />
    <result column="dorm" jdbcType="VARCHAR" property="dorm" />
    <result column="tel" jdbcType="VARCHAR" property="tel" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from stu_info
    where sid = #{sid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into stu_info (sid, sname, sex, 
      age, classes, sgroups, 
      dorm, tel)
    values (#{sid,jdbcType=INTEGER}, #{sname,jdbcType=VARCHAR}, #{sex,jdbcType=VARCHAR}, 
      #{age,jdbcType=INTEGER}, #{classes,jdbcType=VARCHAR}, #{sgroups,jdbcType=VARCHAR}, 
      #{dorm,jdbcType=VARCHAR}, #{tel,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update stu_info
    set sname = #{sname,jdbcType=VARCHAR},
      sex = #{sex,jdbcType=VARCHAR},
      age = #{age,jdbcType=INTEGER},
      classes = #{classes,jdbcType=VARCHAR},
      sgroups = #{sgroups,jdbcType=VARCHAR},
      dorm = #{dorm,jdbcType=VARCHAR},
      tel = #{tel,jdbcType=VARCHAR}
    where sid = #{sid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select sid, sname, sex, age, classes, sgroups, dorm, tel
    from stu_info
    where sid = #{sid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select sid, sname, sex, age, classes, sgroups, dorm, tel
    from stu_info
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="event_name" jdbcType="VARCHAR" property="eventName" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="avg_latency" jdbcType="BIGINT" property="avgLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$host_summary_by_stages (host, event_name, total, 
      total_latency, avg_latency)
    values (#{host,jdbcType=VARCHAR}, #{eventName,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{totalLatency,jdbcType=BIGINT}, #{avgLatency,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, event_name, total, total_latency, avg_latency
    from x$host_summary_by_stages
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Host" jdbcType="CHAR" property="host" />
    <id column="Db" jdbcType="CHAR" property="db" />
    <id column="User" jdbcType="CHAR" property="user" />
    <id column="Table_name" jdbcType="CHAR" property="tableName" />
    <result column="Grantor" jdbcType="CHAR" property="grantor" />
    <result column="Timestamp" jdbcType="TIMESTAMP" property="timestamp" />
    <result column="Table_priv" jdbcType="CHAR" property="tablePriv" />
    <result column="Column_priv" jdbcType="CHAR" property="columnPriv" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from tables_priv
    where Host = #{host,jdbcType=CHAR}
      and Db = #{db,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
      and Table_name = #{tableName,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into tables_priv (Host, Db, User, Table_name, 
      Grantor, Timestamp, Table_priv, 
      Column_priv)
    values (#{host,jdbcType=CHAR}, #{db,jdbcType=CHAR}, #{user,jdbcType=CHAR}, #{tableName,jdbcType=CHAR}, 
      #{grantor,jdbcType=CHAR}, #{timestamp,jdbcType=TIMESTAMP}, #{tablePriv,jdbcType=CHAR}, 
      #{columnPriv,jdbcType=CHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update tables_priv
    set Grantor = #{grantor,jdbcType=CHAR},
      Timestamp = #{timestamp,jdbcType=TIMESTAMP},
      Table_priv = #{tablePriv,jdbcType=CHAR},
      Column_priv = #{columnPriv,jdbcType=CHAR}
    where Host = #{host,jdbcType=CHAR}
      and Db = #{db,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
      and Table_name = #{tableName,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select Host, Db, User, Table_name, Grantor, Timestamp, Table_priv, Column_priv
    from tables_priv
    where Host = #{host,jdbcType=CHAR}
      and Db = #{db,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
      and Table_name = #{tableName,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Host, Db, User, Table_name, Grantor, Timestamp, Table_priv, Column_priv
    from tables_priv
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <result column="ERROR_NUMBER" jdbcType="INTEGER" property="errorNumber" />
    <result column="ERROR_NAME" jdbcType="VARCHAR" property="errorName" />
    <result column="SQL_STATE" jdbcType="VARCHAR" property="sqlState" />
    <result column="SUM_ERROR_RAISED" jdbcType="BIGINT" property="sumErrorRaised" />
    <result column="SUM_ERROR_HANDLED" jdbcType="BIGINT" property="sumErrorHandled" />
    <result column="FIRST_SEEN" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="LAST_SEEN" jdbcType="TIMESTAMP" property="lastSeen" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_errors_summary_by_thread_by_error (THREAD_ID, ERROR_NUMBER, ERROR_NAME, 
      SQL_STATE, SUM_ERROR_RAISED, SUM_ERROR_HANDLED, 
      FIRST_SEEN, LAST_SEEN)
    values (#{threadId,jdbcType=BIGINT}, #{errorNumber,jdbcType=INTEGER}, #{errorName,jdbcType=VARCHAR}, 
      #{sqlState,jdbcType=VARCHAR}, #{sumErrorRaised,jdbcType=BIGINT}, #{sumErrorHandled,jdbcType=BIGINT}, 
      #{firstSeen,jdbcType=TIMESTAMP}, #{lastSeen,jdbcType=TIMESTAMP})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, ERROR_NUMBER, ERROR_NAME, SQL_STATE, SUM_ERROR_RAISED, SUM_ERROR_HANDLED, 
    FIRST_SEEN, LAST_SEEN
    from events_errors_summary_by_thread_by_error
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="ERROR_NUMBER" jdbcType="INTEGER" property="errorNumber" />
    <result column="ERROR_NAME" jdbcType="VARCHAR" property="errorName" />
    <result column="SQL_STATE" jdbcType="VARCHAR" property="sqlState" />
    <result column="SUM_ERROR_RAISED" jdbcType="BIGINT" property="sumErrorRaised" />
    <result column="SUM_ERROR_HANDLED" jdbcType="BIGINT" property="sumErrorHandled" />
    <result column="FIRST_SEEN" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="LAST_SEEN" jdbcType="TIMESTAMP" property="lastSeen" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_errors_summary_by_host_by_error (HOST, ERROR_NUMBER, ERROR_NAME, 
      SQL_STATE, SUM_ERROR_RAISED, SUM_ERROR_HANDLED, 
      FIRST_SEEN, LAST_SEEN)
    values (#{host,jdbcType=CHAR}, #{errorNumber,jdbcType=INTEGER}, #{errorName,jdbcType=VARCHAR}, 
      #{sqlState,jdbcType=VARCHAR}, #{sumErrorRaised,jdbcType=BIGINT}, #{sumErrorHandled,jdbcType=BIGINT}, 
      #{firstSeen,jdbcType=TIMESTAMP}, #{lastSeen,jdbcType=TIMESTAMP})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select HOST, ERROR_NUMBER, ERROR_NAME, SQL_STATE, SUM_ERROR_RAISED, SUM_ERROR_HANDLED, 
    FIRST_SEEN, LAST_SEEN
    from events_errors_summary_by_host_by_error
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="FILE_NAME" jdbcType="VARCHAR" property="fileName" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="OPEN_COUNT" jdbcType="INTEGER" property="openCount" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from file_instances
    where FILE_NAME = #{fileName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into file_instances (FILE_NAME, EVENT_NAME, OPEN_COUNT
      )
    values (#{fileName,jdbcType=VARCHAR}, #{eventName,jdbcType=VARCHAR}, #{openCount,jdbcType=INTEGER}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update file_instances
    set EVENT_NAME = #{eventName,jdbcType=VARCHAR},
      OPEN_COUNT = #{openCount,jdbcType=INTEGER}
    where FILE_NAME = #{fileName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select FILE_NAME, EVENT_NAME, OPEN_COUNT
    from file_instances
    where FILE_NAME = #{fileName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select FILE_NAME, EVENT_NAME, OPEN_COUNT
    from file_instances
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="OBJECT_TYPE" jdbcType="VARCHAR" property="objectType" />
    <result column="OBJECT_SCHEMA" jdbcType="VARCHAR" property="objectSchema" />
    <result column="OBJECT_NAME" jdbcType="VARCHAR" property="objectName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="COUNT_READ" jdbcType="BIGINT" property="countRead" />
    <result column="SUM_TIMER_READ" jdbcType="BIGINT" property="sumTimerRead" />
    <result column="MIN_TIMER_READ" jdbcType="BIGINT" property="minTimerRead" />
    <result column="AVG_TIMER_READ" jdbcType="BIGINT" property="avgTimerRead" />
    <result column="MAX_TIMER_READ" jdbcType="BIGINT" property="maxTimerRead" />
    <result column="COUNT_WRITE" jdbcType="BIGINT" property="countWrite" />
    <result column="SUM_TIMER_WRITE" jdbcType="BIGINT" property="sumTimerWrite" />
    <result column="MIN_TIMER_WRITE" jdbcType="BIGINT" property="minTimerWrite" />
    <result column="AVG_TIMER_WRITE" jdbcType="BIGINT" property="avgTimerWrite" />
    <result column="MAX_TIMER_WRITE" jdbcType="BIGINT" property="maxTimerWrite" />
    <result column="COUNT_FETCH" jdbcType="BIGINT" property="countFetch" />
    <result column="SUM_TIMER_FETCH" jdbcType="BIGINT" property="sumTimerFetch" />
    <result column="MIN_TIMER_FETCH" jdbcType="BIGINT" property="minTimerFetch" />
    <result column="AVG_TIMER_FETCH" jdbcType="BIGINT" property="avgTimerFetch" />
    <result column="MAX_TIMER_FETCH" jdbcType="BIGINT" property="maxTimerFetch" />
    <result column="COUNT_INSERT" jdbcType="BIGINT" property="countInsert" />
    <result column="SUM_TIMER_INSERT" jdbcType="BIGINT" property="sumTimerInsert" />
    <result column="MIN_TIMER_INSERT" jdbcType="BIGINT" property="minTimerInsert" />
    <result column="AVG_TIMER_INSERT" jdbcType="BIGINT" property="avgTimerInsert" />
    <result column="MAX_TIMER_INSERT" jdbcType="BIGINT" property="maxTimerInsert" />
    <result column="COUNT_UPDATE" jdbcType="BIGINT" property="countUpdate" />
    <result column="SUM_TIMER_UPDATE" jdbcType="BIGINT" property="sumTimerUpdate" />
    <result column="MIN_TIMER_UPDATE" jdbcType="BIGINT" property="minTimerUpdate" />
    <result column="AVG_TIMER_UPDATE" jdbcType="BIGINT" property="avgTimerUpdate" />
    <result column="MAX_TIMER_UPDATE" jdbcType="BIGINT" property="maxTimerUpdate" />
    <result column="COUNT_DELETE" jdbcType="BIGINT" property="countDelete" />
    <result column="SUM_TIMER_DELETE" jdbcType="BIGINT" property="sumTimerDelete" />
    <result column="MIN_TIMER_DELETE" jdbcType="BIGINT" property="minTimerDelete" />
    <result column="AVG_TIMER_DELETE" jdbcType="BIGINT" property="avgTimerDelete" />
    <result column="MAX_TIMER_DELETE" jdbcType="BIGINT" property="maxTimerDelete" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into table_io_waits_summary_by_table (OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, 
      COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
      AVG_TIMER_WAIT, MAX_TIMER_WAIT, COUNT_READ, 
      SUM_TIMER_READ, MIN_TIMER_READ, AVG_TIMER_READ, 
      MAX_TIMER_READ, COUNT_WRITE, SUM_TIMER_WRITE, 
      MIN_TIMER_WRITE, AVG_TIMER_WRITE, MAX_TIMER_WRITE, 
      COUNT_FETCH, SUM_TIMER_FETCH, MIN_TIMER_FETCH, 
      AVG_TIMER_FETCH, MAX_TIMER_FETCH, COUNT_INSERT, 
      SUM_TIMER_INSERT, MIN_TIMER_INSERT, AVG_TIMER_INSERT, 
      MAX_TIMER_INSERT, COUNT_UPDATE, SUM_TIMER_UPDATE, 
      MIN_TIMER_UPDATE, AVG_TIMER_UPDATE, MAX_TIMER_UPDATE, 
      COUNT_DELETE, SUM_TIMER_DELETE, MIN_TIMER_DELETE, 
      AVG_TIMER_DELETE, MAX_TIMER_DELETE)
    values (#{objectType,jdbcType=VARCHAR}, #{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, 
      #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, 
      #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT}, #{countRead,jdbcType=BIGINT}, 
      #{sumTimerRead,jdbcType=BIGINT}, #{minTimerRead,jdbcType=BIGINT}, #{avgTimerRead,jdbcType=BIGINT}, 
      #{maxTimerRead,jdbcType=BIGINT}, #{countWrite,jdbcType=BIGINT}, #{sumTimerWrite,jdbcType=BIGINT}, 
      #{minTimerWrite,jdbcType=BIGINT}, #{avgTimerWrite,jdbcType=BIGINT}, #{maxTimerWrite,jdbcType=BIGINT}, 
      #{countFetch,jdbcType=BIGINT}, #{sumTimerFetch,jdbcType=BIGINT}, #{minTimerFetch,jdbcType=BIGINT}, 
      #{avgTimerFetch,jdbcType=BIGINT}, #{maxTimerFetch,jdbcType=BIGINT}, #{countInsert,jdbcType=BIGINT}, 
      #{sumTimerInsert,jdbcType=BIGINT}, #{minTimerInsert,jdbcType=BIGINT}, #{avgTimerInsert,jdbcType=BIGINT}, 
      #{maxTimerInsert,jdbcType=BIGINT}, #{countUpdate,jdbcType=BIGINT}, #{sumTimerUpdate,jdbcType=BIGINT}, 
      #{minTimerUpdate,jdbcType=BIGINT}, #{avgTimerUpdate,jdbcType=BIGINT}, #{maxTimerUpdate,jdbcType=BIGINT}, 
      #{countDelete,jdbcType=BIGINT}, #{sumTimerDelete,jdbcType=BIGINT}, #{minTimerDelete,jdbcType=BIGINT}, 
      #{avgTimerDelete,jdbcType=BIGINT}, #{maxTimerDelete,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
    AVG_TIMER_WAIT, MAX_TIMER_WAIT, COUNT_READ, SUM_TIMER_READ, MIN_TIMER_READ, AVG_TIMER_READ, 
    MAX_TIMER_READ, COUNT_WRITE, SUM_TIMER_WRITE, MIN_TIMER_WRITE, AVG_TIMER_WRITE, MAX_TIMER_WRITE, 
    COUNT_FETCH, SUM_TIMER_FETCH, MIN_TIMER_FETCH, AVG_TIMER_FETCH, MAX_TIMER_FETCH, 
    COUNT_INSERT, SUM_TIMER_INSERT, MIN_TIMER_INSERT, AVG_TIMER_INSERT, MAX_TIMER_INSERT, 
    COUNT_UPDATE, SUM_TIMER_UPDATE, MIN_TIMER_UPDATE, AVG_TIMER_UPDATE, MAX_TIMER_UPDATE, 
    COUNT_DELETE, SUM_TIMER_DELETE, MIN_TIMER_DELETE, AVG_TIMER_DELETE, MAX_TIMER_DELETE
    from table_io_waits_summary_by_table
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="pid" jdbcType="BIGINT" property="pid" />
    <result column="name" jdbcType="VARCHAR" property="name" />
    <result column="email" jdbcType="VARCHAR" property="email" />
    <result column="comtime" jdbcType="TIMESTAMP" property="comtime" />
    <result column="lid" jdbcType="BIGINT" property="lid" />
    <result column="uid" jdbcType="BIGINT" property="uid" />
    <result column="message" jdbcType="LONGVARCHAR" property="message" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from procomment
    where pid = #{pid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into procomment (pid, name, email, 
      comtime, lid, uid, 
      message)
    values (#{pid,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{email,jdbcType=VARCHAR}, 
      #{comtime,jdbcType=TIMESTAMP}, #{lid,jdbcType=BIGINT}, #{uid,jdbcType=BIGINT}, 
      #{message,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update procomment
    set name = #{name,jdbcType=VARCHAR},
      email = #{email,jdbcType=VARCHAR},
      comtime = #{comtime,jdbcType=TIMESTAMP},
      lid = #{lid,jdbcType=BIGINT},
      uid = #{uid,jdbcType=BIGINT},
      message = #{message,jdbcType=LONGVARCHAR}
    where pid = #{pid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select pid, name, email, comtime, lid, uid, message
    from procomment
    where pid = #{pid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select pid, name, email, comtime, lid, uid, message
    from procomment
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="OBJECT_TYPE" jdbcType="VARCHAR" property="objectType" />
    <result column="OBJECT_SCHEMA" jdbcType="VARCHAR" property="objectSchema" />
    <result column="OBJECT_NAME" jdbcType="VARCHAR" property="objectName" />
    <result column="COLUMN_NAME" jdbcType="VARCHAR" property="columnName" />
    <result column="LOCK_TYPE" jdbcType="VARCHAR" property="lockType" />
    <result column="LOCK_DURATION" jdbcType="VARCHAR" property="lockDuration" />
    <result column="LOCK_STATUS" jdbcType="VARCHAR" property="lockStatus" />
    <result column="SOURCE" jdbcType="VARCHAR" property="source" />
    <result column="OWNER_THREAD_ID" jdbcType="BIGINT" property="ownerThreadId" />
    <result column="OWNER_EVENT_ID" jdbcType="BIGINT" property="ownerEventId" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from metadata_locks
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into metadata_locks (OBJECT_INSTANCE_BEGIN, OBJECT_TYPE, OBJECT_SCHEMA, 
      OBJECT_NAME, COLUMN_NAME, LOCK_TYPE, 
      LOCK_DURATION, LOCK_STATUS, SOURCE, 
      OWNER_THREAD_ID, OWNER_EVENT_ID)
    values (#{objectInstanceBegin,jdbcType=BIGINT}, #{objectType,jdbcType=VARCHAR}, #{objectSchema,jdbcType=VARCHAR}, 
      #{objectName,jdbcType=VARCHAR}, #{columnName,jdbcType=VARCHAR}, #{lockType,jdbcType=VARCHAR}, 
      #{lockDuration,jdbcType=VARCHAR}, #{lockStatus,jdbcType=VARCHAR}, #{source,jdbcType=VARCHAR}, 
      #{ownerThreadId,jdbcType=BIGINT}, #{ownerEventId,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update metadata_locks
    set OBJECT_TYPE = #{objectType,jdbcType=VARCHAR},
      OBJECT_SCHEMA = #{objectSchema,jdbcType=VARCHAR},
      OBJECT_NAME = #{objectName,jdbcType=VARCHAR},
      COLUMN_NAME = #{columnName,jdbcType=VARCHAR},
      LOCK_TYPE = #{lockType,jdbcType=VARCHAR},
      LOCK_DURATION = #{lockDuration,jdbcType=VARCHAR},
      LOCK_STATUS = #{lockStatus,jdbcType=VARCHAR},
      SOURCE = #{source,jdbcType=VARCHAR},
      OWNER_THREAD_ID = #{ownerThreadId,jdbcType=BIGINT},
      OWNER_EVENT_ID = #{ownerEventId,jdbcType=BIGINT}
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, COLUMN_NAME, 
    LOCK_TYPE, LOCK_DURATION, LOCK_STATUS, SOURCE, OWNER_THREAD_ID, OWNER_EVENT_ID
    from metadata_locks
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, COLUMN_NAME, 
    LOCK_TYPE, LOCK_DURATION, LOCK_STATUS, SOURCE, OWNER_THREAD_ID, OWNER_EVENT_ID
    from metadata_locks
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="EVENT_ID" jdbcType="BIGINT" property="eventId" />
    <result column="END_EVENT_ID" jdbcType="BIGINT" property="endEventId" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="SOURCE" jdbcType="VARCHAR" property="source" />
    <result column="TIMER_START" jdbcType="BIGINT" property="timerStart" />
    <result column="TIMER_END" jdbcType="BIGINT" property="timerEnd" />
    <result column="TIMER_WAIT" jdbcType="BIGINT" property="timerWait" />
    <result column="WORK_COMPLETED" jdbcType="BIGINT" property="workCompleted" />
    <result column="WORK_ESTIMATED" jdbcType="BIGINT" property="workEstimated" />
    <result column="NESTING_EVENT_ID" jdbcType="BIGINT" property="nestingEventId" />
    <result column="NESTING_EVENT_TYPE" jdbcType="CHAR" property="nestingEventType" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from events_stages_current
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_stages_current (THREAD_ID, EVENT_ID, END_EVENT_ID, 
      EVENT_NAME, SOURCE, TIMER_START, 
      TIMER_END, TIMER_WAIT, WORK_COMPLETED, 
      WORK_ESTIMATED, NESTING_EVENT_ID, NESTING_EVENT_TYPE
      )
    values (#{threadId,jdbcType=BIGINT}, #{eventId,jdbcType=BIGINT}, #{endEventId,jdbcType=BIGINT}, 
      #{eventName,jdbcType=VARCHAR}, #{source,jdbcType=VARCHAR}, #{timerStart,jdbcType=BIGINT}, 
      #{timerEnd,jdbcType=BIGINT}, #{timerWait,jdbcType=BIGINT}, #{workCompleted,jdbcType=BIGINT}, 
      #{workEstimated,jdbcType=BIGINT}, #{nestingEventId,jdbcType=BIGINT}, #{nestingEventType,jdbcType=CHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_stages_current
    set END_EVENT_ID = #{endEventId,jdbcType=BIGINT},
      EVENT_NAME = #{eventName,jdbcType=VARCHAR},
      SOURCE = #{source,jdbcType=VARCHAR},
      TIMER_START = #{timerStart,jdbcType=BIGINT},
      TIMER_END = #{timerEnd,jdbcType=BIGINT},
      TIMER_WAIT = #{timerWait,jdbcType=BIGINT},
      WORK_COMPLETED = #{workCompleted,jdbcType=BIGINT},
      WORK_ESTIMATED = #{workEstimated,jdbcType=BIGINT},
      NESTING_EVENT_ID = #{nestingEventId,jdbcType=BIGINT},
      NESTING_EVENT_TYPE = #{nestingEventType,jdbcType=CHAR}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, SOURCE, TIMER_START, TIMER_END, 
    TIMER_WAIT, WORK_COMPLETED, WORK_ESTIMATED, NESTING_EVENT_ID, NESTING_EVENT_TYPE
    from events_stages_current
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, SOURCE, TIMER_START, TIMER_END, 
    TIMER_WAIT, WORK_COMPLETED, WORK_ESTIMATED, NESTING_EVENT_ID, NESTING_EVENT_TYPE
    from events_stages_current
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="CHANNEL_NAME" jdbcType="CHAR" property="channelName" />
    <result column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <result column="SERVICE_STATE" jdbcType="CHAR" property="serviceState" />
    <result column="LAST_ERROR_NUMBER" jdbcType="INTEGER" property="lastErrorNumber" />
    <result column="LAST_ERROR_MESSAGE" jdbcType="VARCHAR" property="lastErrorMessage" />
    <result column="LAST_ERROR_TIMESTAMP" jdbcType="TIMESTAMP" property="lastErrorTimestamp" />
    <result column="LAST_PROCESSED_TRANSACTION" jdbcType="CHAR" property="lastProcessedTransaction" />
    <result column="LAST_PROCESSED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP" jdbcType="TIMESTAMP" property="lastProcessedTransactionOriginalCommitTimestamp" />
    <result column="LAST_PROCESSED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP" jdbcType="TIMESTAMP" property="lastProcessedTransactionImmediateCommitTimestamp" />
    <result column="LAST_PROCESSED_TRANSACTION_START_BUFFER_TIMESTAMP" jdbcType="TIMESTAMP" property="lastProcessedTransactionStartBufferTimestamp" />
    <result column="LAST_PROCESSED_TRANSACTION_END_BUFFER_TIMESTAMP" jdbcType="TIMESTAMP" property="lastProcessedTransactionEndBufferTimestamp" />
    <result column="PROCESSING_TRANSACTION" jdbcType="CHAR" property="processingTransaction" />
    <result column="PROCESSING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP" jdbcType="TIMESTAMP" property="processingTransactionOriginalCommitTimestamp" />
    <result column="PROCESSING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP" jdbcType="TIMESTAMP" property="processingTransactionImmediateCommitTimestamp" />
    <result column="PROCESSING_TRANSACTION_START_BUFFER_TIMESTAMP" jdbcType="TIMESTAMP" property="processingTransactionStartBufferTimestamp" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from replication_applier_status_by_coordinator
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into replication_applier_status_by_coordinator (CHANNEL_NAME, THREAD_ID, SERVICE_STATE, 
      LAST_ERROR_NUMBER, LAST_ERROR_MESSAGE, LAST_ERROR_TIMESTAMP, 
      LAST_PROCESSED_TRANSACTION, LAST_PROCESSED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, 
      LAST_PROCESSED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, LAST_PROCESSED_TRANSACTION_START_BUFFER_TIMESTAMP, 
      LAST_PROCESSED_TRANSACTION_END_BUFFER_TIMESTAMP, PROCESSING_TRANSACTION, 
      PROCESSING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, PROCESSING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, 
      PROCESSING_TRANSACTION_START_BUFFER_TIMESTAMP)
    values (#{channelName,jdbcType=CHAR}, #{threadId,jdbcType=BIGINT}, #{serviceState,jdbcType=CHAR}, 
      #{lastErrorNumber,jdbcType=INTEGER}, #{lastErrorMessage,jdbcType=VARCHAR}, #{lastErrorTimestamp,jdbcType=TIMESTAMP}, 
      #{lastProcessedTransaction,jdbcType=CHAR}, #{lastProcessedTransactionOriginalCommitTimestamp,jdbcType=TIMESTAMP}, 
      #{lastProcessedTransactionImmediateCommitTimestamp,jdbcType=TIMESTAMP}, #{lastProcessedTransactionStartBufferTimestamp,jdbcType=TIMESTAMP}, 
      #{lastProcessedTransactionEndBufferTimestamp,jdbcType=TIMESTAMP}, #{processingTransaction,jdbcType=CHAR}, 
      #{processingTransactionOriginalCommitTimestamp,jdbcType=TIMESTAMP}, #{processingTransactionImmediateCommitTimestamp,jdbcType=TIMESTAMP}, 
      #{processingTransactionStartBufferTimestamp,jdbcType=TIMESTAMP})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update replication_applier_status_by_coordinator
    set THREAD_ID = #{threadId,jdbcType=BIGINT},
      SERVICE_STATE = #{serviceState,jdbcType=CHAR},
      LAST_ERROR_NUMBER = #{lastErrorNumber,jdbcType=INTEGER},
      LAST_ERROR_MESSAGE = #{lastErrorMessage,jdbcType=VARCHAR},
      LAST_ERROR_TIMESTAMP = #{lastErrorTimestamp,jdbcType=TIMESTAMP},
      LAST_PROCESSED_TRANSACTION = #{lastProcessedTransaction,jdbcType=CHAR},
      LAST_PROCESSED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP = #{lastProcessedTransactionOriginalCommitTimestamp,jdbcType=TIMESTAMP},
      LAST_PROCESSED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP = #{lastProcessedTransactionImmediateCommitTimestamp,jdbcType=TIMESTAMP},
      LAST_PROCESSED_TRANSACTION_START_BUFFER_TIMESTAMP = #{lastProcessedTransactionStartBufferTimestamp,jdbcType=TIMESTAMP},
      LAST_PROCESSED_TRANSACTION_END_BUFFER_TIMESTAMP = #{lastProcessedTransactionEndBufferTimestamp,jdbcType=TIMESTAMP},
      PROCESSING_TRANSACTION = #{processingTransaction,jdbcType=CHAR},
      PROCESSING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP = #{processingTransactionOriginalCommitTimestamp,jdbcType=TIMESTAMP},
      PROCESSING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP = #{processingTransactionImmediateCommitTimestamp,jdbcType=TIMESTAMP},
      PROCESSING_TRANSACTION_START_BUFFER_TIMESTAMP = #{processingTransactionStartBufferTimestamp,jdbcType=TIMESTAMP}
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select CHANNEL_NAME, THREAD_ID, SERVICE_STATE, LAST_ERROR_NUMBER, LAST_ERROR_MESSAGE, 
    LAST_ERROR_TIMESTAMP, LAST_PROCESSED_TRANSACTION, LAST_PROCESSED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, 
    LAST_PROCESSED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, LAST_PROCESSED_TRANSACTION_START_BUFFER_TIMESTAMP, 
    LAST_PROCESSED_TRANSACTION_END_BUFFER_TIMESTAMP, PROCESSING_TRANSACTION, PROCESSING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, 
    PROCESSING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, PROCESSING_TRANSACTION_START_BUFFER_TIMESTAMP
    from replication_applier_status_by_coordinator
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select CHANNEL_NAME, THREAD_ID, SERVICE_STATE, LAST_ERROR_NUMBER, LAST_ERROR_MESSAGE, 
    LAST_ERROR_TIMESTAMP, LAST_PROCESSED_TRANSACTION, LAST_PROCESSED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, 
    LAST_PROCESSED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, LAST_PROCESSED_TRANSACTION_START_BUFFER_TIMESTAMP, 
    LAST_PROCESSED_TRANSACTION_END_BUFFER_TIMESTAMP, PROCESSING_TRANSACTION, PROCESSING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, 
    PROCESSING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, PROCESSING_TRANSACTION_START_BUFFER_TIMESTAMP
    from replication_applier_status_by_coordinator
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Host" jdbcType="CHAR" property="host" />
    <id column="Db" jdbcType="CHAR" property="db" />
    <id column="User" jdbcType="CHAR" property="user" />
    <id column="Routine_name" jdbcType="CHAR" property="routineName" />
    <id column="Routine_type" jdbcType="CHAR" property="routineType" />
    <result column="Grantor" jdbcType="CHAR" property="grantor" />
    <result column="Proc_priv" jdbcType="CHAR" property="procPriv" />
    <result column="Timestamp" jdbcType="TIMESTAMP" property="timestamp" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from procs_priv
    where Host = #{host,jdbcType=CHAR}
      and Db = #{db,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
      and Routine_name = #{routineName,jdbcType=CHAR}
      and Routine_type = #{routineType,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into procs_priv (Host, Db, User, Routine_name, 
      Routine_type, Grantor, Proc_priv, 
      Timestamp)
    values (#{host,jdbcType=CHAR}, #{db,jdbcType=CHAR}, #{user,jdbcType=CHAR}, #{routineName,jdbcType=CHAR}, 
      #{routineType,jdbcType=CHAR}, #{grantor,jdbcType=CHAR}, #{procPriv,jdbcType=CHAR}, 
      #{timestamp,jdbcType=TIMESTAMP})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update procs_priv
    set Grantor = #{grantor,jdbcType=CHAR},
      Proc_priv = #{procPriv,jdbcType=CHAR},
      Timestamp = #{timestamp,jdbcType=TIMESTAMP}
    where Host = #{host,jdbcType=CHAR}
      and Db = #{db,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
      and Routine_name = #{routineName,jdbcType=CHAR}
      and Routine_type = #{routineType,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select Host, Db, User, Routine_name, Routine_type, Grantor, Proc_priv, Timestamp
    from procs_priv
    where Host = #{host,jdbcType=CHAR}
      and Db = #{db,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
      and Routine_name = #{routineName,jdbcType=CHAR}
      and Routine_type = #{routineType,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Host, Db, User, Routine_name, Routine_type, Grantor, Proc_priv, Timestamp
    from procs_priv
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="table_schema" jdbcType="VARCHAR" property="tableSchema" />
    <result column="table_name" jdbcType="VARCHAR" property="tableName" />
    <result column="index_name" jdbcType="VARCHAR" property="indexName" />
    <result column="rows_selected" jdbcType="BIGINT" property="rowsSelected" />
    <result column="select_latency" jdbcType="BIGINT" property="selectLatency" />
    <result column="rows_inserted" jdbcType="BIGINT" property="rowsInserted" />
    <result column="insert_latency" jdbcType="BIGINT" property="insertLatency" />
    <result column="rows_updated" jdbcType="BIGINT" property="rowsUpdated" />
    <result column="update_latency" jdbcType="BIGINT" property="updateLatency" />
    <result column="rows_deleted" jdbcType="BIGINT" property="rowsDeleted" />
    <result column="delete_latency" jdbcType="BIGINT" property="deleteLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$schema_index_statistics (table_schema, table_name, index_name, 
      rows_selected, select_latency, rows_inserted, 
      insert_latency, rows_updated, update_latency, 
      rows_deleted, delete_latency)
    values (#{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, #{indexName,jdbcType=VARCHAR}, 
      #{rowsSelected,jdbcType=BIGINT}, #{selectLatency,jdbcType=BIGINT}, #{rowsInserted,jdbcType=BIGINT}, 
      #{insertLatency,jdbcType=BIGINT}, #{rowsUpdated,jdbcType=BIGINT}, #{updateLatency,jdbcType=BIGINT}, 
      #{rowsDeleted,jdbcType=BIGINT}, #{deleteLatency,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select table_schema, table_name, index_name, rows_selected, select_latency, rows_inserted, 
    insert_latency, rows_updated, update_latency, rows_deleted, delete_latency
    from x$schema_index_statistics
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="EVENT_CATALOG" jdbcType="VARCHAR" property="eventCatalog" />
    <result column="EVENT_SCHEMA" jdbcType="VARCHAR" property="eventSchema" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="DEFINER" jdbcType="VARCHAR" property="definer" />
    <result column="TIME_ZONE" jdbcType="VARCHAR" property="timeZone" />
    <result column="EVENT_BODY" jdbcType="VARCHAR" property="eventBody" />
    <result column="EVENT_TYPE" jdbcType="VARCHAR" property="eventType" />
    <result column="EXECUTE_AT" jdbcType="TIMESTAMP" property="executeAt" />
    <result column="INTERVAL_VALUE" jdbcType="VARCHAR" property="intervalValue" />
    <result column="INTERVAL_FIELD" jdbcType="CHAR" property="intervalField" />
    <result column="SQL_MODE" jdbcType="CHAR" property="sqlMode" />
    <result column="STARTS" jdbcType="TIMESTAMP" property="starts" />
    <result column="ENDS" jdbcType="TIMESTAMP" property="ends" />
    <result column="STATUS" jdbcType="CHAR" property="status" />
    <result column="ON_COMPLETION" jdbcType="VARCHAR" property="onCompletion" />
    <result column="CREATED" jdbcType="TIMESTAMP" property="created" />
    <result column="LAST_ALTERED" jdbcType="TIMESTAMP" property="lastAltered" />
    <result column="LAST_EXECUTED" jdbcType="TIMESTAMP" property="lastExecuted" />
    <result column="EVENT_COMMENT" jdbcType="VARCHAR" property="eventComment" />
    <result column="ORIGINATOR" jdbcType="INTEGER" property="originator" />
    <result column="CHARACTER_SET_CLIENT" jdbcType="VARCHAR" property="characterSetClient" />
    <result column="COLLATION_CONNECTION" jdbcType="VARCHAR" property="collationConnection" />
    <result column="DATABASE_COLLATION" jdbcType="VARCHAR" property="databaseCollation" />
    <result column="EVENT_DEFINITION" jdbcType="LONGVARCHAR" property="eventDefinition" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into EVENTS (EVENT_CATALOG, EVENT_SCHEMA, EVENT_NAME, 
      DEFINER, TIME_ZONE, EVENT_BODY, 
      EVENT_TYPE, EXECUTE_AT, INTERVAL_VALUE, 
      INTERVAL_FIELD, SQL_MODE, STARTS, 
      ENDS, STATUS, ON_COMPLETION, 
      CREATED, LAST_ALTERED, LAST_EXECUTED, 
      EVENT_COMMENT, ORIGINATOR, CHARACTER_SET_CLIENT, 
      COLLATION_CONNECTION, DATABASE_COLLATION, 
      EVENT_DEFINITION)
    values (#{eventCatalog,jdbcType=VARCHAR}, #{eventSchema,jdbcType=VARCHAR}, #{eventName,jdbcType=VARCHAR}, 
      #{definer,jdbcType=VARCHAR}, #{timeZone,jdbcType=VARCHAR}, #{eventBody,jdbcType=VARCHAR}, 
      #{eventType,jdbcType=VARCHAR}, #{executeAt,jdbcType=TIMESTAMP}, #{intervalValue,jdbcType=VARCHAR}, 
      #{intervalField,jdbcType=CHAR}, #{sqlMode,jdbcType=CHAR}, #{starts,jdbcType=TIMESTAMP}, 
      #{ends,jdbcType=TIMESTAMP}, #{status,jdbcType=CHAR}, #{onCompletion,jdbcType=VARCHAR}, 
      #{created,jdbcType=TIMESTAMP}, #{lastAltered,jdbcType=TIMESTAMP}, #{lastExecuted,jdbcType=TIMESTAMP}, 
      #{eventComment,jdbcType=VARCHAR}, #{originator,jdbcType=INTEGER}, #{characterSetClient,jdbcType=VARCHAR}, 
      #{collationConnection,jdbcType=VARCHAR}, #{databaseCollation,jdbcType=VARCHAR}, 
      #{eventDefinition,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select EVENT_CATALOG, EVENT_SCHEMA, EVENT_NAME, DEFINER, TIME_ZONE, EVENT_BODY, EVENT_TYPE, 
    EXECUTE_AT, INTERVAL_VALUE, INTERVAL_FIELD, SQL_MODE, STARTS, ENDS, STATUS, ON_COMPLETION, 
    CREATED, LAST_ALTERED, LAST_EXECUTED, EVENT_COMMENT, ORIGINATOR, CHARACTER_SET_CLIENT, 
    COLLATION_CONNECTION, DATABASE_COLLATION, EVENT_DEFINITION
    from EVENTS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="object_schema" jdbcType="VARCHAR" property="objectSchema" />
    <result column="object_name" jdbcType="VARCHAR" property="objectName" />
    <result column="rows_full_scanned" jdbcType="BIGINT" property="rowsFullScanned" />
    <result column="latency" jdbcType="BIGINT" property="latency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$schema_tables_with_full_table_scans (object_schema, object_name, rows_full_scanned, 
      latency)
    values (#{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, #{rowsFullScanned,jdbcType=BIGINT}, 
      #{latency,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select object_schema, object_name, rows_full_scanned, latency
    from x$schema_tables_with_full_table_scans
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_stages_summary_by_user_by_event_name (USER, EVENT_NAME, COUNT_STAR, 
      SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
      MAX_TIMER_WAIT)
    values (#{user,jdbcType=CHAR}, #{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, 
      #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, 
      #{maxTimerWait,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT
    from events_stages_summary_by_user_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="utid" jdbcType="INTEGER" property="utid" />
    <result column="uid" jdbcType="VARCHAR" property="uid" />
    <result column="password" jdbcType="VARCHAR" property="password" />
    <result column="tel" jdbcType="VARCHAR" property="tel" />
    <result column="name" jdbcType="VARCHAR" property="name" />
    <result column="address" jdbcType="VARCHAR" property="address" />
    <result column="addrName" jdbcType="VARCHAR" property="addrname" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from users2
    where utid = #{utid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into users2 (utid, uid, password, 
      tel, name, address, 
      addrName)
    values (#{utid,jdbcType=INTEGER}, #{uid,jdbcType=VARCHAR}, #{password,jdbcType=VARCHAR}, 
      #{tel,jdbcType=VARCHAR}, #{name,jdbcType=VARCHAR}, #{address,jdbcType=VARCHAR}, 
      #{addrname,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update users2
    set uid = #{uid,jdbcType=VARCHAR},
      password = #{password,jdbcType=VARCHAR},
      tel = #{tel,jdbcType=VARCHAR},
      name = #{name,jdbcType=VARCHAR},
      address = #{address,jdbcType=VARCHAR},
      addrName = #{addrname,jdbcType=VARCHAR}
    where utid = #{utid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select utid, uid, password, tel, name, address, addrName
    from users2
    where utid = #{utid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select utid, uid, password, tel, name, address, addrName
    from users2
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="event_name" jdbcType="VARCHAR" property="eventName" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="count_read" jdbcType="BIGINT" property="countRead" />
    <result column="count_write" jdbcType="BIGINT" property="countWrite" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="min_latency" jdbcType="LONGVARCHAR" property="minLatency" />
    <result column="avg_latency" jdbcType="LONGVARCHAR" property="avgLatency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
    <result column="total_read" jdbcType="LONGVARCHAR" property="totalRead" />
    <result column="avg_read" jdbcType="LONGVARCHAR" property="avgRead" />
    <result column="total_written" jdbcType="LONGVARCHAR" property="totalWritten" />
    <result column="avg_written" jdbcType="LONGVARCHAR" property="avgWritten" />
    <result column="total_requested" jdbcType="LONGVARCHAR" property="totalRequested" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into io_global_by_wait_by_bytes (event_name, total, count_read, 
      count_write, total_latency, min_latency, 
      avg_latency, max_latency, total_read, 
      avg_read, total_written, avg_written, 
      total_requested)
    values (#{eventName,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, #{countRead,jdbcType=BIGINT}, 
      #{countWrite,jdbcType=BIGINT}, #{totalLatency,jdbcType=LONGVARCHAR}, #{minLatency,jdbcType=LONGVARCHAR}, 
      #{avgLatency,jdbcType=LONGVARCHAR}, #{maxLatency,jdbcType=LONGVARCHAR}, #{totalRead,jdbcType=LONGVARCHAR}, 
      #{avgRead,jdbcType=LONGVARCHAR}, #{totalWritten,jdbcType=LONGVARCHAR}, #{avgWritten,jdbcType=LONGVARCHAR}, 
      #{totalRequested,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select event_name, total, count_read, count_write, total_latency, min_latency, avg_latency, 
    max_latency, total_read, avg_read, total_written, avg_written, total_requested
    from io_global_by_wait_by_bytes
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="utid" jdbcType="INTEGER" property="utid" />
    <result column="uid" jdbcType="VARCHAR" property="uid" />
    <result column="password" jdbcType="VARCHAR" property="password" />
    <result column="tel" jdbcType="VARCHAR" property="tel" />
    <result column="name" jdbcType="VARCHAR" property="name" />
    <result column="address" jdbcType="VARCHAR" property="address" />
    <result column="addrName" jdbcType="VARCHAR" property="addrname" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into users3 (utid, uid, password, 
      tel, name, address, 
      addrName)
    values (#{utid,jdbcType=INTEGER}, #{uid,jdbcType=VARCHAR}, #{password,jdbcType=VARCHAR}, 
      #{tel,jdbcType=VARCHAR}, #{name,jdbcType=VARCHAR}, #{address,jdbcType=VARCHAR}, 
      #{addrname,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select utid, uid, password, tel, name, address, addrName
    from users3
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="uid" jdbcType="BIGINT" property="uid" />
    <result column="name" jdbcType="VARCHAR" property="name" />
    <result column="password" jdbcType="VARCHAR" property="password" />
    <result column="createDate" jdbcType="TIMESTAMP" property="createdate" />
    <result column="endDate" jdbcType="TIMESTAMP" property="enddate" />
    <result column="realName" jdbcType="VARCHAR" property="realname" />
    <result column="birthday" jdbcType="TIMESTAMP" property="birthday" />
    <result column="email" jdbcType="VARCHAR" property="email" />
    <result column="tel" jdbcType="VARCHAR" property="tel" />
    <result column="status" jdbcType="CHAR" property="status" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from userinfo
    where uid = #{uid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into userinfo (uid, name, password, 
      createDate, endDate, realName, 
      birthday, email, tel, 
      status)
    values (#{uid,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{password,jdbcType=VARCHAR}, 
      #{createdate,jdbcType=TIMESTAMP}, #{enddate,jdbcType=TIMESTAMP}, #{realname,jdbcType=VARCHAR}, 
      #{birthday,jdbcType=TIMESTAMP}, #{email,jdbcType=VARCHAR}, #{tel,jdbcType=VARCHAR}, 
      #{status,jdbcType=CHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update userinfo
    set name = #{name,jdbcType=VARCHAR},
      password = #{password,jdbcType=VARCHAR},
      createDate = #{createdate,jdbcType=TIMESTAMP},
      endDate = #{enddate,jdbcType=TIMESTAMP},
      realName = #{realname,jdbcType=VARCHAR},
      birthday = #{birthday,jdbcType=TIMESTAMP},
      email = #{email,jdbcType=VARCHAR},
      tel = #{tel,jdbcType=VARCHAR},
      status = #{status,jdbcType=CHAR}
    where uid = #{uid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select uid, name, password, createDate, endDate, realName, birthday, email, tel, 
    status
    from userinfo
    where uid = #{uid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select uid, name, password, createDate, endDate, realName, birthday, email, tel, 
    status
    from userinfo
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="SUM_LOCK_TIME" jdbcType="BIGINT" property="sumLockTime" />
    <result column="SUM_ERRORS" jdbcType="BIGINT" property="sumErrors" />
    <result column="SUM_WARNINGS" jdbcType="BIGINT" property="sumWarnings" />
    <result column="SUM_ROWS_AFFECTED" jdbcType="BIGINT" property="sumRowsAffected" />
    <result column="SUM_ROWS_SENT" jdbcType="BIGINT" property="sumRowsSent" />
    <result column="SUM_ROWS_EXAMINED" jdbcType="BIGINT" property="sumRowsExamined" />
    <result column="SUM_CREATED_TMP_DISK_TABLES" jdbcType="BIGINT" property="sumCreatedTmpDiskTables" />
    <result column="SUM_CREATED_TMP_TABLES" jdbcType="BIGINT" property="sumCreatedTmpTables" />
    <result column="SUM_SELECT_FULL_JOIN" jdbcType="BIGINT" property="sumSelectFullJoin" />
    <result column="SUM_SELECT_FULL_RANGE_JOIN" jdbcType="BIGINT" property="sumSelectFullRangeJoin" />
    <result column="SUM_SELECT_RANGE" jdbcType="BIGINT" property="sumSelectRange" />
    <result column="SUM_SELECT_RANGE_CHECK" jdbcType="BIGINT" property="sumSelectRangeCheck" />
    <result column="SUM_SELECT_SCAN" jdbcType="BIGINT" property="sumSelectScan" />
    <result column="SUM_SORT_MERGE_PASSES" jdbcType="BIGINT" property="sumSortMergePasses" />
    <result column="SUM_SORT_RANGE" jdbcType="BIGINT" property="sumSortRange" />
    <result column="SUM_SORT_ROWS" jdbcType="BIGINT" property="sumSortRows" />
    <result column="SUM_SORT_SCAN" jdbcType="BIGINT" property="sumSortScan" />
    <result column="SUM_NO_INDEX_USED" jdbcType="BIGINT" property="sumNoIndexUsed" />
    <result column="SUM_NO_GOOD_INDEX_USED" jdbcType="BIGINT" property="sumNoGoodIndexUsed" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_statements_summary_by_host_by_event_name (HOST, EVENT_NAME, COUNT_STAR, 
      SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
      MAX_TIMER_WAIT, SUM_LOCK_TIME, SUM_ERRORS, 
      SUM_WARNINGS, SUM_ROWS_AFFECTED, SUM_ROWS_SENT, 
      SUM_ROWS_EXAMINED, SUM_CREATED_TMP_DISK_TABLES, 
      SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, SUM_SELECT_FULL_RANGE_JOIN, 
      SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, 
      SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, 
      SUM_SORT_SCAN, SUM_NO_INDEX_USED, SUM_NO_GOOD_INDEX_USED
      )
    values (#{host,jdbcType=CHAR}, #{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, 
      #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, 
      #{maxTimerWait,jdbcType=BIGINT}, #{sumLockTime,jdbcType=BIGINT}, #{sumErrors,jdbcType=BIGINT}, 
      #{sumWarnings,jdbcType=BIGINT}, #{sumRowsAffected,jdbcType=BIGINT}, #{sumRowsSent,jdbcType=BIGINT}, 
      #{sumRowsExamined,jdbcType=BIGINT}, #{sumCreatedTmpDiskTables,jdbcType=BIGINT}, 
      #{sumCreatedTmpTables,jdbcType=BIGINT}, #{sumSelectFullJoin,jdbcType=BIGINT}, #{sumSelectFullRangeJoin,jdbcType=BIGINT}, 
      #{sumSelectRange,jdbcType=BIGINT}, #{sumSelectRangeCheck,jdbcType=BIGINT}, #{sumSelectScan,jdbcType=BIGINT}, 
      #{sumSortMergePasses,jdbcType=BIGINT}, #{sumSortRange,jdbcType=BIGINT}, #{sumSortRows,jdbcType=BIGINT}, 
      #{sumSortScan,jdbcType=BIGINT}, #{sumNoIndexUsed,jdbcType=BIGINT}, #{sumNoGoodIndexUsed,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select HOST, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT, SUM_LOCK_TIME, SUM_ERRORS, SUM_WARNINGS, SUM_ROWS_AFFECTED, SUM_ROWS_SENT, 
    SUM_ROWS_EXAMINED, SUM_CREATED_TMP_DISK_TABLES, SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, 
    SUM_SELECT_FULL_RANGE_JOIN, SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, 
    SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, SUM_SORT_SCAN, SUM_NO_INDEX_USED, 
    SUM_NO_GOOD_INDEX_USED
    from events_statements_summary_by_host_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="tid" jdbcType="INTEGER" property="tid" />
    <result column="tname" jdbcType="VARCHAR" property="tname" />
    <result column="start_uid" jdbcType="INTEGER" property="startUid" />
    <result column="start_time" jdbcType="TIMESTAMP" property="startTime" />
    <result column="state" jdbcType="VARCHAR" property="state" />
    <result column="end_uid" jdbcType="INTEGER" property="endUid" />
    <result column="task_money" jdbcType="INTEGER" property="taskMoney" />
    <result column="end_time" jdbcType="TIMESTAMP" property="endTime" />
    <result column="contact" jdbcType="VARCHAR" property="contact" />
    <result column="t_img" jdbcType="VARCHAR" property="tImg" />
    <result column="start_user_tel" jdbcType="VARCHAR" property="startUserTel" />
    <result column="end_user_tel" jdbcType="VARCHAR" property="endUserTel" />
    <result column="content" jdbcType="LONGVARCHAR" property="content" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from task
    where tid = #{tid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into task (tid, tname, start_uid, 
      start_time, state, end_uid, 
      task_money, end_time, contact, 
      t_img, start_user_tel, end_user_tel, 
      content)
    values (#{tid,jdbcType=INTEGER}, #{tname,jdbcType=VARCHAR}, #{startUid,jdbcType=INTEGER}, 
      #{startTime,jdbcType=TIMESTAMP}, #{state,jdbcType=VARCHAR}, #{endUid,jdbcType=INTEGER}, 
      #{taskMoney,jdbcType=INTEGER}, #{endTime,jdbcType=TIMESTAMP}, #{contact,jdbcType=VARCHAR}, 
      #{tImg,jdbcType=VARCHAR}, #{startUserTel,jdbcType=VARCHAR}, #{endUserTel,jdbcType=VARCHAR}, 
      #{content,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update task
    set tname = #{tname,jdbcType=VARCHAR},
      start_uid = #{startUid,jdbcType=INTEGER},
      start_time = #{startTime,jdbcType=TIMESTAMP},
      state = #{state,jdbcType=VARCHAR},
      end_uid = #{endUid,jdbcType=INTEGER},
      task_money = #{taskMoney,jdbcType=INTEGER},
      end_time = #{endTime,jdbcType=TIMESTAMP},
      contact = #{contact,jdbcType=VARCHAR},
      t_img = #{tImg,jdbcType=VARCHAR},
      start_user_tel = #{startUserTel,jdbcType=VARCHAR},
      end_user_tel = #{endUserTel,jdbcType=VARCHAR},
      content = #{content,jdbcType=LONGVARCHAR}
    where tid = #{tid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select tid, tname, start_uid, start_time, state, end_uid, task_money, end_time, contact, 
    t_img, start_user_tel, end_user_tel, content
    from task
    where tid = #{tid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select tid, tname, start_uid, start_time, state, end_uid, task_money, end_time, contact, 
    t_img, start_user_tel, end_user_tel, content
    from task
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="mid" jdbcType="BIGINT" property="mid" />
    <result column="mmsg" jdbcType="VARCHAR" property="mmsg" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from msgtoday
    where mid = #{mid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into msgtoday (mid, mmsg)
    values (#{mid,jdbcType=BIGINT}, #{mmsg,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update msgtoday
    set mmsg = #{mmsg,jdbcType=VARCHAR}
    where mid = #{mid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select mid, mmsg
    from msgtoday
    where mid = #{mid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select mid, mmsg
    from msgtoday
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="thread_id" jdbcType="BIGINT" property="threadId" />
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="current_count_used" jdbcType="DECIMAL" property="currentCountUsed" />
    <result column="current_allocated" jdbcType="DECIMAL" property="currentAllocated" />
    <result column="current_avg_alloc" jdbcType="DECIMAL" property="currentAvgAlloc" />
    <result column="current_max_alloc" jdbcType="BIGINT" property="currentMaxAlloc" />
    <result column="total_allocated" jdbcType="DECIMAL" property="totalAllocated" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$memory_by_thread_by_current_bytes (thread_id, user, current_count_used, 
      current_allocated, current_avg_alloc, current_max_alloc, 
      total_allocated)
    values (#{threadId,jdbcType=BIGINT}, #{user,jdbcType=VARCHAR}, #{currentCountUsed,jdbcType=DECIMAL}, 
      #{currentAllocated,jdbcType=DECIMAL}, #{currentAvgAlloc,jdbcType=DECIMAL}, #{currentMaxAlloc,jdbcType=BIGINT}, 
      #{totalAllocated,jdbcType=DECIMAL})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select thread_id, user, current_count_used, current_allocated, current_avg_alloc, 
    current_max_alloc, total_allocated
    from x$memory_by_thread_by_current_bytes
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="event_name" jdbcType="VARCHAR" property="eventName" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="max_latency" jdbcType="BIGINT" property="maxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$host_summary_by_file_io_type (host, event_name, total, 
      total_latency, max_latency)
    values (#{host,jdbcType=VARCHAR}, #{eventName,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{totalLatency,jdbcType=BIGINT}, #{maxLatency,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, event_name, total, total_latency, max_latency
    from x$host_summary_by_file_io_type
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="statements" jdbcType="DECIMAL" property="statements" />
    <result column="table_scans" jdbcType="DECIMAL" property="tableScans" />
    <result column="file_ios" jdbcType="DECIMAL" property="fileIos" />
    <result column="current_connections" jdbcType="DECIMAL" property="currentConnections" />
    <result column="total_connections" jdbcType="DECIMAL" property="totalConnections" />
    <result column="unique_users" jdbcType="BIGINT" property="uniqueUsers" />
    <result column="statement_latency" jdbcType="LONGVARCHAR" property="statementLatency" />
    <result column="statement_avg_latency" jdbcType="LONGVARCHAR" property="statementAvgLatency" />
    <result column="file_io_latency" jdbcType="LONGVARCHAR" property="fileIoLatency" />
    <result column="current_memory" jdbcType="LONGVARCHAR" property="currentMemory" />
    <result column="total_memory_allocated" jdbcType="LONGVARCHAR" property="totalMemoryAllocated" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into host_summary (host, statements, table_scans, 
      file_ios, current_connections, total_connections, 
      unique_users, statement_latency, statement_avg_latency, 
      file_io_latency, current_memory, total_memory_allocated
      )
    values (#{host,jdbcType=VARCHAR}, #{statements,jdbcType=DECIMAL}, #{tableScans,jdbcType=DECIMAL}, 
      #{fileIos,jdbcType=DECIMAL}, #{currentConnections,jdbcType=DECIMAL}, #{totalConnections,jdbcType=DECIMAL}, 
      #{uniqueUsers,jdbcType=BIGINT}, #{statementLatency,jdbcType=LONGVARCHAR}, #{statementAvgLatency,jdbcType=LONGVARCHAR}, 
      #{fileIoLatency,jdbcType=LONGVARCHAR}, #{currentMemory,jdbcType=LONGVARCHAR}, #{totalMemoryAllocated,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, statements, table_scans, file_ios, current_connections, total_connections, 
    unique_users, statement_latency, statement_avg_latency, file_io_latency, current_memory, 
    total_memory_allocated
    from host_summary
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="sid" jdbcType="BIGINT" property="sid" />
    <result column="name" jdbcType="VARCHAR" property="name" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from students
    where sid = #{sid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into students (sid, name)
    values (#{sid,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update students
    set name = #{name,jdbcType=VARCHAR}
    where sid = #{sid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select sid, name
    from students
    where sid = #{sid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select sid, name
    from students
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="ENGINE_LOCK_ID" jdbcType="VARCHAR" property="engineLockId" />
    <id column="ENGINE" jdbcType="VARCHAR" property="engine" />
    <result column="ENGINE_TRANSACTION_ID" jdbcType="BIGINT" property="engineTransactionId" />
    <result column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <result column="EVENT_ID" jdbcType="BIGINT" property="eventId" />
    <result column="OBJECT_SCHEMA" jdbcType="VARCHAR" property="objectSchema" />
    <result column="OBJECT_NAME" jdbcType="VARCHAR" property="objectName" />
    <result column="PARTITION_NAME" jdbcType="VARCHAR" property="partitionName" />
    <result column="SUBPARTITION_NAME" jdbcType="VARCHAR" property="subpartitionName" />
    <result column="INDEX_NAME" jdbcType="VARCHAR" property="indexName" />
    <result column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="LOCK_TYPE" jdbcType="VARCHAR" property="lockType" />
    <result column="LOCK_MODE" jdbcType="VARCHAR" property="lockMode" />
    <result column="LOCK_STATUS" jdbcType="VARCHAR" property="lockStatus" />
    <result column="LOCK_DATA" jdbcType="VARCHAR" property="lockData" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from data_locks
    where ENGINE_LOCK_ID = #{engineLockId,jdbcType=VARCHAR}
      and ENGINE = #{engine,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into data_locks (ENGINE_LOCK_ID, ENGINE, ENGINE_TRANSACTION_ID, 
      THREAD_ID, EVENT_ID, OBJECT_SCHEMA, 
      OBJECT_NAME, PARTITION_NAME, SUBPARTITION_NAME, 
      INDEX_NAME, OBJECT_INSTANCE_BEGIN, LOCK_TYPE, 
      LOCK_MODE, LOCK_STATUS, LOCK_DATA
      )
    values (#{engineLockId,jdbcType=VARCHAR}, #{engine,jdbcType=VARCHAR}, #{engineTransactionId,jdbcType=BIGINT}, 
      #{threadId,jdbcType=BIGINT}, #{eventId,jdbcType=BIGINT}, #{objectSchema,jdbcType=VARCHAR}, 
      #{objectName,jdbcType=VARCHAR}, #{partitionName,jdbcType=VARCHAR}, #{subpartitionName,jdbcType=VARCHAR}, 
      #{indexName,jdbcType=VARCHAR}, #{objectInstanceBegin,jdbcType=BIGINT}, #{lockType,jdbcType=VARCHAR}, 
      #{lockMode,jdbcType=VARCHAR}, #{lockStatus,jdbcType=VARCHAR}, #{lockData,jdbcType=VARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update data_locks
    set ENGINE_TRANSACTION_ID = #{engineTransactionId,jdbcType=BIGINT},
      THREAD_ID = #{threadId,jdbcType=BIGINT},
      EVENT_ID = #{eventId,jdbcType=BIGINT},
      OBJECT_SCHEMA = #{objectSchema,jdbcType=VARCHAR},
      OBJECT_NAME = #{objectName,jdbcType=VARCHAR},
      PARTITION_NAME = #{partitionName,jdbcType=VARCHAR},
      SUBPARTITION_NAME = #{subpartitionName,jdbcType=VARCHAR},
      INDEX_NAME = #{indexName,jdbcType=VARCHAR},
      OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT},
      LOCK_TYPE = #{lockType,jdbcType=VARCHAR},
      LOCK_MODE = #{lockMode,jdbcType=VARCHAR},
      LOCK_STATUS = #{lockStatus,jdbcType=VARCHAR},
      LOCK_DATA = #{lockData,jdbcType=VARCHAR}
    where ENGINE_LOCK_ID = #{engineLockId,jdbcType=VARCHAR}
      and ENGINE = #{engine,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select ENGINE_LOCK_ID, ENGINE, ENGINE_TRANSACTION_ID, THREAD_ID, EVENT_ID, OBJECT_SCHEMA, 
    OBJECT_NAME, PARTITION_NAME, SUBPARTITION_NAME, INDEX_NAME, OBJECT_INSTANCE_BEGIN, 
    LOCK_TYPE, LOCK_MODE, LOCK_STATUS, LOCK_DATA
    from data_locks
    where ENGINE_LOCK_ID = #{engineLockId,jdbcType=VARCHAR}
      and ENGINE = #{engine,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select ENGINE_LOCK_ID, ENGINE, ENGINE_TRANSACTION_ID, THREAD_ID, EVENT_ID, OBJECT_SCHEMA, 
    OBJECT_NAME, PARTITION_NAME, SUBPARTITION_NAME, INDEX_NAME, OBJECT_INSTANCE_BEGIN, 
    LOCK_TYPE, LOCK_MODE, LOCK_STATUS, LOCK_DATA
    from data_locks
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="CURRENT_CONNECTIONS" jdbcType="BIGINT" property="currentConnections" />
    <result column="TOTAL_CONNECTIONS" jdbcType="BIGINT" property="totalConnections" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into users (USER, CURRENT_CONNECTIONS, TOTAL_CONNECTIONS
      )
    values (#{user,jdbcType=CHAR}, #{currentConnections,jdbcType=BIGINT}, #{totalConnections,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, CURRENT_CONNECTIONS, TOTAL_CONNECTIONS
    from users
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="uid" jdbcType="INTEGER" property="uid" />
    <result column="username" jdbcType="VARCHAR" property="username" />
    <result column="password" jdbcType="VARCHAR" property="password" />
    <result column="email" jdbcType="VARCHAR" property="email" />
    <result column="homeUrl" jdbcType="VARCHAR" property="homeurl" />
    <result column="screenName" jdbcType="VARCHAR" property="screenname" />
    <result column="created" jdbcType="INTEGER" property="created" />
    <result column="activated" jdbcType="INTEGER" property="activated" />
    <result column="logged" jdbcType="INTEGER" property="logged" />
    <result column="groupName" jdbcType="VARCHAR" property="groupname" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from t_users
    where uid = #{uid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into t_users (uid, username, password, 
      email, homeUrl, screenName, 
      created, activated, logged, 
      groupName)
    values (#{uid,jdbcType=INTEGER}, #{username,jdbcType=VARCHAR}, #{password,jdbcType=VARCHAR}, 
      #{email,jdbcType=VARCHAR}, #{homeurl,jdbcType=VARCHAR}, #{screenname,jdbcType=VARCHAR}, 
      #{created,jdbcType=INTEGER}, #{activated,jdbcType=INTEGER}, #{logged,jdbcType=INTEGER}, 
      #{groupname,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update t_users
    set username = #{username,jdbcType=VARCHAR},
      password = #{password,jdbcType=VARCHAR},
      email = #{email,jdbcType=VARCHAR},
      homeUrl = #{homeurl,jdbcType=VARCHAR},
      screenName = #{screenname,jdbcType=VARCHAR},
      created = #{created,jdbcType=INTEGER},
      activated = #{activated,jdbcType=INTEGER},
      logged = #{logged,jdbcType=INTEGER},
      groupName = #{groupname,jdbcType=VARCHAR}
    where uid = #{uid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select uid, username, password, email, homeUrl, screenName, created, activated, logged, 
    groupName
    from t_users
    where uid = #{uid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select uid, username, password, email, homeUrl, screenName, created, activated, logged, 
    groupName
    from t_users
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="FROM_HOST" jdbcType="CHAR" property="fromHost" />
    <id column="FROM_USER" jdbcType="CHAR" property="fromUser" />
    <id column="TO_HOST" jdbcType="CHAR" property="toHost" />
    <id column="TO_USER" jdbcType="CHAR" property="toUser" />
    <result column="WITH_ADMIN_OPTION" jdbcType="CHAR" property="withAdminOption" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from role_edges
    where FROM_HOST = #{fromHost,jdbcType=CHAR}
      and FROM_USER = #{fromUser,jdbcType=CHAR}
      and TO_HOST = #{toHost,jdbcType=CHAR}
      and TO_USER = #{toUser,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into role_edges (FROM_HOST, FROM_USER, TO_HOST, 
      TO_USER, WITH_ADMIN_OPTION)
    values (#{fromHost,jdbcType=CHAR}, #{fromUser,jdbcType=CHAR}, #{toHost,jdbcType=CHAR}, 
      #{toUser,jdbcType=CHAR}, #{withAdminOption,jdbcType=CHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update role_edges
    set WITH_ADMIN_OPTION = #{withAdminOption,jdbcType=CHAR}
    where FROM_HOST = #{fromHost,jdbcType=CHAR}
      and FROM_USER = #{fromUser,jdbcType=CHAR}
      and TO_HOST = #{toHost,jdbcType=CHAR}
      and TO_USER = #{toUser,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select FROM_HOST, FROM_USER, TO_HOST, TO_USER, WITH_ADMIN_OPTION
    from role_edges
    where FROM_HOST = #{fromHost,jdbcType=CHAR}
      and FROM_USER = #{fromUser,jdbcType=CHAR}
      and TO_HOST = #{toHost,jdbcType=CHAR}
      and TO_USER = #{toUser,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select FROM_HOST, FROM_USER, TO_HOST, TO_USER, WITH_ADMIN_OPTION
    from role_edges
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from events_waits_summary_global_by_event_name
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_waits_summary_global_by_event_name (EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, 
      MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT
      )
    values (#{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, 
      #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_waits_summary_global_by_event_name
    set COUNT_STAR = #{countStar,jdbcType=BIGINT},
      SUM_TIMER_WAIT = #{sumTimerWait,jdbcType=BIGINT},
      MIN_TIMER_WAIT = #{minTimerWait,jdbcType=BIGINT},
      AVG_TIMER_WAIT = #{avgTimerWait,jdbcType=BIGINT},
      MAX_TIMER_WAIT = #{maxTimerWait,jdbcType=BIGINT}
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT
    from events_waits_summary_global_by_event_name
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT
    from events_waits_summary_global_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="ERROR_NUMBER" jdbcType="INTEGER" property="errorNumber" />
    <result column="ERROR_NAME" jdbcType="VARCHAR" property="errorName" />
    <result column="SQL_STATE" jdbcType="VARCHAR" property="sqlState" />
    <result column="SUM_ERROR_RAISED" jdbcType="BIGINT" property="sumErrorRaised" />
    <result column="SUM_ERROR_HANDLED" jdbcType="BIGINT" property="sumErrorHandled" />
    <result column="FIRST_SEEN" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="LAST_SEEN" jdbcType="TIMESTAMP" property="lastSeen" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_errors_summary_by_user_by_error (USER, ERROR_NUMBER, ERROR_NAME, 
      SQL_STATE, SUM_ERROR_RAISED, SUM_ERROR_HANDLED, 
      FIRST_SEEN, LAST_SEEN)
    values (#{user,jdbcType=CHAR}, #{errorNumber,jdbcType=INTEGER}, #{errorName,jdbcType=VARCHAR}, 
      #{sqlState,jdbcType=VARCHAR}, #{sumErrorRaised,jdbcType=BIGINT}, #{sumErrorHandled,jdbcType=BIGINT}, 
      #{firstSeen,jdbcType=TIMESTAMP}, #{lastSeen,jdbcType=TIMESTAMP})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, ERROR_NUMBER, ERROR_NAME, SQL_STATE, SUM_ERROR_RAISED, SUM_ERROR_HANDLED, 
    FIRST_SEEN, LAST_SEEN
    from events_errors_summary_by_user_by_error
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="CHANNEL_NAME" jdbcType="CHAR" property="channelName" />
    <result column="SERVICE_STATE" jdbcType="CHAR" property="serviceState" />
    <result column="REMAINING_DELAY" jdbcType="INTEGER" property="remainingDelay" />
    <result column="COUNT_TRANSACTIONS_RETRIES" jdbcType="BIGINT" property="countTransactionsRetries" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from replication_applier_status
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into replication_applier_status (CHANNEL_NAME, SERVICE_STATE, REMAINING_DELAY, 
      COUNT_TRANSACTIONS_RETRIES)
    values (#{channelName,jdbcType=CHAR}, #{serviceState,jdbcType=CHAR}, #{remainingDelay,jdbcType=INTEGER}, 
      #{countTransactionsRetries,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update replication_applier_status
    set SERVICE_STATE = #{serviceState,jdbcType=CHAR},
      REMAINING_DELAY = #{remainingDelay,jdbcType=INTEGER},
      COUNT_TRANSACTIONS_RETRIES = #{countTransactionsRetries,jdbcType=BIGINT}
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select CHANNEL_NAME, SERVICE_STATE, REMAINING_DELAY, COUNT_TRANSACTIONS_RETRIES
    from replication_applier_status
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select CHANNEL_NAME, SERVICE_STATE, REMAINING_DELAY, COUNT_TRANSACTIONS_RETRIES
    from replication_applier_status
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_ALLOC" jdbcType="BIGINT" property="countAlloc" />
    <result column="COUNT_FREE" jdbcType="BIGINT" property="countFree" />
    <result column="SUM_NUMBER_OF_BYTES_ALLOC" jdbcType="BIGINT" property="sumNumberOfBytesAlloc" />
    <result column="SUM_NUMBER_OF_BYTES_FREE" jdbcType="BIGINT" property="sumNumberOfBytesFree" />
    <result column="LOW_COUNT_USED" jdbcType="BIGINT" property="lowCountUsed" />
    <result column="CURRENT_COUNT_USED" jdbcType="BIGINT" property="currentCountUsed" />
    <result column="HIGH_COUNT_USED" jdbcType="BIGINT" property="highCountUsed" />
    <result column="LOW_NUMBER_OF_BYTES_USED" jdbcType="BIGINT" property="lowNumberOfBytesUsed" />
    <result column="CURRENT_NUMBER_OF_BYTES_USED" jdbcType="BIGINT" property="currentNumberOfBytesUsed" />
    <result column="HIGH_NUMBER_OF_BYTES_USED" jdbcType="BIGINT" property="highNumberOfBytesUsed" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from memory_summary_global_by_event_name
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into memory_summary_global_by_event_name (EVENT_NAME, COUNT_ALLOC, COUNT_FREE, 
      SUM_NUMBER_OF_BYTES_ALLOC, SUM_NUMBER_OF_BYTES_FREE, 
      LOW_COUNT_USED, CURRENT_COUNT_USED, HIGH_COUNT_USED, 
      LOW_NUMBER_OF_BYTES_USED, CURRENT_NUMBER_OF_BYTES_USED, 
      HIGH_NUMBER_OF_BYTES_USED)
    values (#{eventName,jdbcType=VARCHAR}, #{countAlloc,jdbcType=BIGINT}, #{countFree,jdbcType=BIGINT}, 
      #{sumNumberOfBytesAlloc,jdbcType=BIGINT}, #{sumNumberOfBytesFree,jdbcType=BIGINT}, 
      #{lowCountUsed,jdbcType=BIGINT}, #{currentCountUsed,jdbcType=BIGINT}, #{highCountUsed,jdbcType=BIGINT}, 
      #{lowNumberOfBytesUsed,jdbcType=BIGINT}, #{currentNumberOfBytesUsed,jdbcType=BIGINT}, 
      #{highNumberOfBytesUsed,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update memory_summary_global_by_event_name
    set COUNT_ALLOC = #{countAlloc,jdbcType=BIGINT},
      COUNT_FREE = #{countFree,jdbcType=BIGINT},
      SUM_NUMBER_OF_BYTES_ALLOC = #{sumNumberOfBytesAlloc,jdbcType=BIGINT},
      SUM_NUMBER_OF_BYTES_FREE = #{sumNumberOfBytesFree,jdbcType=BIGINT},
      LOW_COUNT_USED = #{lowCountUsed,jdbcType=BIGINT},
      CURRENT_COUNT_USED = #{currentCountUsed,jdbcType=BIGINT},
      HIGH_COUNT_USED = #{highCountUsed,jdbcType=BIGINT},
      LOW_NUMBER_OF_BYTES_USED = #{lowNumberOfBytesUsed,jdbcType=BIGINT},
      CURRENT_NUMBER_OF_BYTES_USED = #{currentNumberOfBytesUsed,jdbcType=BIGINT},
      HIGH_NUMBER_OF_BYTES_USED = #{highNumberOfBytesUsed,jdbcType=BIGINT}
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select EVENT_NAME, COUNT_ALLOC, COUNT_FREE, SUM_NUMBER_OF_BYTES_ALLOC, SUM_NUMBER_OF_BYTES_FREE, 
    LOW_COUNT_USED, CURRENT_COUNT_USED, HIGH_COUNT_USED, LOW_NUMBER_OF_BYTES_USED, CURRENT_NUMBER_OF_BYTES_USED, 
    HIGH_NUMBER_OF_BYTES_USED
    from memory_summary_global_by_event_name
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select EVENT_NAME, COUNT_ALLOC, COUNT_FREE, SUM_NUMBER_OF_BYTES_ALLOC, SUM_NUMBER_OF_BYTES_FREE, 
    LOW_COUNT_USED, CURRENT_COUNT_USED, HIGH_COUNT_USED, LOW_NUMBER_OF_BYTES_USED, CURRENT_NUMBER_OF_BYTES_USED, 
    HIGH_NUMBER_OF_BYTES_USED
    from memory_summary_global_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="EVENT_ID" jdbcType="BIGINT" property="eventId" />
    <result column="END_EVENT_ID" jdbcType="BIGINT" property="endEventId" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="SOURCE" jdbcType="VARCHAR" property="source" />
    <result column="TIMER_START" jdbcType="BIGINT" property="timerStart" />
    <result column="TIMER_END" jdbcType="BIGINT" property="timerEnd" />
    <result column="TIMER_WAIT" jdbcType="BIGINT" property="timerWait" />
    <result column="SPINS" jdbcType="INTEGER" property="spins" />
    <result column="OBJECT_SCHEMA" jdbcType="VARCHAR" property="objectSchema" />
    <result column="OBJECT_NAME" jdbcType="VARCHAR" property="objectName" />
    <result column="INDEX_NAME" jdbcType="VARCHAR" property="indexName" />
    <result column="OBJECT_TYPE" jdbcType="VARCHAR" property="objectType" />
    <result column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="NESTING_EVENT_ID" jdbcType="BIGINT" property="nestingEventId" />
    <result column="NESTING_EVENT_TYPE" jdbcType="CHAR" property="nestingEventType" />
    <result column="OPERATION" jdbcType="VARCHAR" property="operation" />
    <result column="NUMBER_OF_BYTES" jdbcType="BIGINT" property="numberOfBytes" />
    <result column="FLAGS" jdbcType="INTEGER" property="flags" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from events_waits_history
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_waits_history (THREAD_ID, EVENT_ID, END_EVENT_ID, 
      EVENT_NAME, SOURCE, TIMER_START, 
      TIMER_END, TIMER_WAIT, SPINS, 
      OBJECT_SCHEMA, OBJECT_NAME, INDEX_NAME, 
      OBJECT_TYPE, OBJECT_INSTANCE_BEGIN, NESTING_EVENT_ID, 
      NESTING_EVENT_TYPE, OPERATION, NUMBER_OF_BYTES, 
      FLAGS)
    values (#{threadId,jdbcType=BIGINT}, #{eventId,jdbcType=BIGINT}, #{endEventId,jdbcType=BIGINT}, 
      #{eventName,jdbcType=VARCHAR}, #{source,jdbcType=VARCHAR}, #{timerStart,jdbcType=BIGINT}, 
      #{timerEnd,jdbcType=BIGINT}, #{timerWait,jdbcType=BIGINT}, #{spins,jdbcType=INTEGER}, 
      #{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, #{indexName,jdbcType=VARCHAR}, 
      #{objectType,jdbcType=VARCHAR}, #{objectInstanceBegin,jdbcType=BIGINT}, #{nestingEventId,jdbcType=BIGINT}, 
      #{nestingEventType,jdbcType=CHAR}, #{operation,jdbcType=VARCHAR}, #{numberOfBytes,jdbcType=BIGINT}, 
      #{flags,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_waits_history
    set END_EVENT_ID = #{endEventId,jdbcType=BIGINT},
      EVENT_NAME = #{eventName,jdbcType=VARCHAR},
      SOURCE = #{source,jdbcType=VARCHAR},
      TIMER_START = #{timerStart,jdbcType=BIGINT},
      TIMER_END = #{timerEnd,jdbcType=BIGINT},
      TIMER_WAIT = #{timerWait,jdbcType=BIGINT},
      SPINS = #{spins,jdbcType=INTEGER},
      OBJECT_SCHEMA = #{objectSchema,jdbcType=VARCHAR},
      OBJECT_NAME = #{objectName,jdbcType=VARCHAR},
      INDEX_NAME = #{indexName,jdbcType=VARCHAR},
      OBJECT_TYPE = #{objectType,jdbcType=VARCHAR},
      OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT},
      NESTING_EVENT_ID = #{nestingEventId,jdbcType=BIGINT},
      NESTING_EVENT_TYPE = #{nestingEventType,jdbcType=CHAR},
      OPERATION = #{operation,jdbcType=VARCHAR},
      NUMBER_OF_BYTES = #{numberOfBytes,jdbcType=BIGINT},
      FLAGS = #{flags,jdbcType=INTEGER}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, SOURCE, TIMER_START, TIMER_END, 
    TIMER_WAIT, SPINS, OBJECT_SCHEMA, OBJECT_NAME, INDEX_NAME, OBJECT_TYPE, OBJECT_INSTANCE_BEGIN, 
    NESTING_EVENT_ID, NESTING_EVENT_TYPE, OPERATION, NUMBER_OF_BYTES, FLAGS
    from events_waits_history
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, SOURCE, TIMER_START, TIMER_END, 
    TIMER_WAIT, SPINS, OBJECT_SCHEMA, OBJECT_NAME, INDEX_NAME, OBJECT_TYPE, OBJECT_INSTANCE_BEGIN, 
    NESTING_EVENT_ID, NESTING_EVENT_TYPE, OPERATION, NUMBER_OF_BYTES, FLAGS
    from events_waits_history
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="HOST" jdbcType="CHAR" property="host" />
    <id column="USER" jdbcType="CHAR" property="user" />
    <id column="DEFAULT_ROLE_HOST" jdbcType="CHAR" property="defaultRoleHost" />
    <id column="DEFAULT_ROLE_USER" jdbcType="CHAR" property="defaultRoleUser" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from default_roles
    where HOST = #{host,jdbcType=CHAR}
      and USER = #{user,jdbcType=CHAR}
      and DEFAULT_ROLE_HOST = #{defaultRoleHost,jdbcType=CHAR}
      and DEFAULT_ROLE_USER = #{defaultRoleUser,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into default_roles (HOST, USER, DEFAULT_ROLE_HOST, 
      DEFAULT_ROLE_USER)
    values (#{host,jdbcType=CHAR}, #{user,jdbcType=CHAR}, #{defaultRoleHost,jdbcType=CHAR}, 
      #{defaultRoleUser,jdbcType=CHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select HOST, USER, DEFAULT_ROLE_HOST, DEFAULT_ROLE_USER
    from default_roles
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="TABLE_CATALOG" jdbcType="VARCHAR" property="tableCatalog" />
    <result column="TABLE_SCHEMA" jdbcType="VARCHAR" property="tableSchema" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
    <result column="NON_UNIQUE" jdbcType="INTEGER" property="nonUnique" />
    <result column="INDEX_SCHEMA" jdbcType="VARCHAR" property="indexSchema" />
    <result column="INDEX_NAME" jdbcType="VARCHAR" property="indexName" />
    <result column="SEQ_IN_INDEX" jdbcType="INTEGER" property="seqInIndex" />
    <result column="COLUMN_NAME" jdbcType="VARCHAR" property="columnName" />
    <result column="COLLATION" jdbcType="VARCHAR" property="collation" />
    <result column="CARDINALITY" jdbcType="BIGINT" property="cardinality" />
    <result column="SUB_PART" jdbcType="BIGINT" property="subPart" />
    <result column="NULLABLE" jdbcType="VARCHAR" property="nullable" />
    <result column="INDEX_TYPE" jdbcType="VARCHAR" property="indexType" />
    <result column="COMMENT" jdbcType="VARCHAR" property="comment" />
    <result column="INDEX_COMMENT" jdbcType="VARCHAR" property="indexComment" />
    <result column="IS_VISIBLE" jdbcType="VARCHAR" property="isVisible" />
    <result column="PACKED" jdbcType="BINARY" property="packed" />
    <result column="EXPRESSION" jdbcType="LONGVARCHAR" property="expression" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into STATISTICS (TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, 
      NON_UNIQUE, INDEX_SCHEMA, INDEX_NAME, 
      SEQ_IN_INDEX, COLUMN_NAME, COLLATION, 
      CARDINALITY, SUB_PART, NULLABLE, 
      INDEX_TYPE, COMMENT, INDEX_COMMENT, 
      IS_VISIBLE, PACKED, EXPRESSION
      )
    values (#{tableCatalog,jdbcType=VARCHAR}, #{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, 
      #{nonUnique,jdbcType=INTEGER}, #{indexSchema,jdbcType=VARCHAR}, #{indexName,jdbcType=VARCHAR}, 
      #{seqInIndex,jdbcType=INTEGER}, #{columnName,jdbcType=VARCHAR}, #{collation,jdbcType=VARCHAR}, 
      #{cardinality,jdbcType=BIGINT}, #{subPart,jdbcType=BIGINT}, #{nullable,jdbcType=VARCHAR}, 
      #{indexType,jdbcType=VARCHAR}, #{comment,jdbcType=VARCHAR}, #{indexComment,jdbcType=VARCHAR}, 
      #{isVisible,jdbcType=VARCHAR}, #{packed,jdbcType=BINARY}, #{expression,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, NON_UNIQUE, INDEX_SCHEMA, INDEX_NAME, 
    SEQ_IN_INDEX, COLUMN_NAME, COLLATION, CARDINALITY, SUB_PART, NULLABLE, INDEX_TYPE, 
    COMMENT, INDEX_COMMENT, IS_VISIBLE, PACKED, EXPRESSION
    from STATISTICS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="TABLE_CATALOG" jdbcType="VARCHAR" property="tableCatalog" />
    <result column="TABLE_SCHEMA" jdbcType="VARCHAR" property="tableSchema" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
    <result column="TABLE_TYPE" jdbcType="CHAR" property="tableType" />
    <result column="ENGINE" jdbcType="VARCHAR" property="engine" />
    <result column="VERSION" jdbcType="INTEGER" property="version" />
    <result column="ROW_FORMAT" jdbcType="CHAR" property="rowFormat" />
    <result column="TABLE_ROWS" jdbcType="BIGINT" property="tableRows" />
    <result column="AVG_ROW_LENGTH" jdbcType="BIGINT" property="avgRowLength" />
    <result column="DATA_LENGTH" jdbcType="BIGINT" property="dataLength" />
    <result column="MAX_DATA_LENGTH" jdbcType="BIGINT" property="maxDataLength" />
    <result column="INDEX_LENGTH" jdbcType="BIGINT" property="indexLength" />
    <result column="DATA_FREE" jdbcType="BIGINT" property="dataFree" />
    <result column="AUTO_INCREMENT" jdbcType="BIGINT" property="autoIncrement" />
    <result column="CREATE_TIME" jdbcType="TIMESTAMP" property="createTime" />
    <result column="UPDATE_TIME" jdbcType="TIMESTAMP" property="updateTime" />
    <result column="CHECK_TIME" jdbcType="TIMESTAMP" property="checkTime" />
    <result column="TABLE_COLLATION" jdbcType="VARCHAR" property="tableCollation" />
    <result column="CHECKSUM" jdbcType="BIGINT" property="checksum" />
    <result column="CREATE_OPTIONS" jdbcType="VARCHAR" property="createOptions" />
    <result column="TABLE_COMMENT" jdbcType="LONGVARCHAR" property="tableComment" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into TABLES (TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, 
      TABLE_TYPE, ENGINE, VERSION, 
      ROW_FORMAT, TABLE_ROWS, AVG_ROW_LENGTH, 
      DATA_LENGTH, MAX_DATA_LENGTH, INDEX_LENGTH, 
      DATA_FREE, AUTO_INCREMENT, CREATE_TIME, 
      UPDATE_TIME, CHECK_TIME, TABLE_COLLATION, 
      CHECKSUM, CREATE_OPTIONS, TABLE_COMMENT
      )
    values (#{tableCatalog,jdbcType=VARCHAR}, #{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, 
      #{tableType,jdbcType=CHAR}, #{engine,jdbcType=VARCHAR}, #{version,jdbcType=INTEGER}, 
      #{rowFormat,jdbcType=CHAR}, #{tableRows,jdbcType=BIGINT}, #{avgRowLength,jdbcType=BIGINT}, 
      #{dataLength,jdbcType=BIGINT}, #{maxDataLength,jdbcType=BIGINT}, #{indexLength,jdbcType=BIGINT}, 
      #{dataFree,jdbcType=BIGINT}, #{autoIncrement,jdbcType=BIGINT}, #{createTime,jdbcType=TIMESTAMP}, 
      #{updateTime,jdbcType=TIMESTAMP}, #{checkTime,jdbcType=TIMESTAMP}, #{tableCollation,jdbcType=VARCHAR}, 
      #{checksum,jdbcType=BIGINT}, #{createOptions,jdbcType=VARCHAR}, #{tableComment,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, TABLE_TYPE, ENGINE, VERSION, ROW_FORMAT, 
    TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH, MAX_DATA_LENGTH, INDEX_LENGTH, DATA_FREE, 
    AUTO_INCREMENT, CREATE_TIME, UPDATE_TIME, CHECK_TIME, TABLE_COLLATION, CHECKSUM, 
    CREATE_OPTIONS, TABLE_COMMENT
    from TABLES
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="file" jdbcType="VARCHAR" property="file" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="count_read" jdbcType="BIGINT" property="countRead" />
    <result column="read_latency" jdbcType="BIGINT" property="readLatency" />
    <result column="count_write" jdbcType="BIGINT" property="countWrite" />
    <result column="write_latency" jdbcType="BIGINT" property="writeLatency" />
    <result column="count_misc" jdbcType="BIGINT" property="countMisc" />
    <result column="misc_latency" jdbcType="BIGINT" property="miscLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$io_global_by_file_by_latency (file, total, total_latency, 
      count_read, read_latency, count_write, 
      write_latency, count_misc, misc_latency
      )
    values (#{file,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, #{totalLatency,jdbcType=BIGINT}, 
      #{countRead,jdbcType=BIGINT}, #{readLatency,jdbcType=BIGINT}, #{countWrite,jdbcType=BIGINT}, 
      #{writeLatency,jdbcType=BIGINT}, #{countMisc,jdbcType=BIGINT}, #{miscLatency,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select file, total, total_latency, count_read, read_latency, count_write, write_latency, 
    count_misc, misc_latency
    from x$io_global_by_file_by_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="event_name" jdbcType="VARCHAR" property="eventName" />
    <result column="current_count" jdbcType="BIGINT" property="currentCount" />
    <result column="high_count" jdbcType="BIGINT" property="highCount" />
    <result column="current_alloc" jdbcType="LONGVARCHAR" property="currentAlloc" />
    <result column="current_avg_alloc" jdbcType="LONGVARCHAR" property="currentAvgAlloc" />
    <result column="high_alloc" jdbcType="LONGVARCHAR" property="highAlloc" />
    <result column="high_avg_alloc" jdbcType="LONGVARCHAR" property="highAvgAlloc" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into memory_global_by_current_bytes (event_name, current_count, high_count, 
      current_alloc, current_avg_alloc, 
      high_alloc, high_avg_alloc)
    values (#{eventName,jdbcType=VARCHAR}, #{currentCount,jdbcType=BIGINT}, #{highCount,jdbcType=BIGINT}, 
      #{currentAlloc,jdbcType=LONGVARCHAR}, #{currentAvgAlloc,jdbcType=LONGVARCHAR}, 
      #{highAlloc,jdbcType=LONGVARCHAR}, #{highAvgAlloc,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select event_name, current_count, high_count, current_alloc, current_avg_alloc, high_alloc, 
    high_avg_alloc
    from memory_global_by_current_bytes
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="SUM_LOCK_TIME" jdbcType="BIGINT" property="sumLockTime" />
    <result column="SUM_ERRORS" jdbcType="BIGINT" property="sumErrors" />
    <result column="SUM_WARNINGS" jdbcType="BIGINT" property="sumWarnings" />
    <result column="SUM_ROWS_AFFECTED" jdbcType="BIGINT" property="sumRowsAffected" />
    <result column="SUM_ROWS_SENT" jdbcType="BIGINT" property="sumRowsSent" />
    <result column="SUM_ROWS_EXAMINED" jdbcType="BIGINT" property="sumRowsExamined" />
    <result column="SUM_CREATED_TMP_DISK_TABLES" jdbcType="BIGINT" property="sumCreatedTmpDiskTables" />
    <result column="SUM_CREATED_TMP_TABLES" jdbcType="BIGINT" property="sumCreatedTmpTables" />
    <result column="SUM_SELECT_FULL_JOIN" jdbcType="BIGINT" property="sumSelectFullJoin" />
    <result column="SUM_SELECT_FULL_RANGE_JOIN" jdbcType="BIGINT" property="sumSelectFullRangeJoin" />
    <result column="SUM_SELECT_RANGE" jdbcType="BIGINT" property="sumSelectRange" />
    <result column="SUM_SELECT_RANGE_CHECK" jdbcType="BIGINT" property="sumSelectRangeCheck" />
    <result column="SUM_SELECT_SCAN" jdbcType="BIGINT" property="sumSelectScan" />
    <result column="SUM_SORT_MERGE_PASSES" jdbcType="BIGINT" property="sumSortMergePasses" />
    <result column="SUM_SORT_RANGE" jdbcType="BIGINT" property="sumSortRange" />
    <result column="SUM_SORT_ROWS" jdbcType="BIGINT" property="sumSortRows" />
    <result column="SUM_SORT_SCAN" jdbcType="BIGINT" property="sumSortScan" />
    <result column="SUM_NO_INDEX_USED" jdbcType="BIGINT" property="sumNoIndexUsed" />
    <result column="SUM_NO_GOOD_INDEX_USED" jdbcType="BIGINT" property="sumNoGoodIndexUsed" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_statements_summary_by_account_by_event_name (USER, HOST, EVENT_NAME, 
      COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
      AVG_TIMER_WAIT, MAX_TIMER_WAIT, SUM_LOCK_TIME, 
      SUM_ERRORS, SUM_WARNINGS, SUM_ROWS_AFFECTED, 
      SUM_ROWS_SENT, SUM_ROWS_EXAMINED, SUM_CREATED_TMP_DISK_TABLES, 
      SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, SUM_SELECT_FULL_RANGE_JOIN, 
      SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, 
      SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, 
      SUM_SORT_SCAN, SUM_NO_INDEX_USED, SUM_NO_GOOD_INDEX_USED
      )
    values (#{user,jdbcType=CHAR}, #{host,jdbcType=CHAR}, #{eventName,jdbcType=VARCHAR}, 
      #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, 
      #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT}, #{sumLockTime,jdbcType=BIGINT}, 
      #{sumErrors,jdbcType=BIGINT}, #{sumWarnings,jdbcType=BIGINT}, #{sumRowsAffected,jdbcType=BIGINT}, 
      #{sumRowsSent,jdbcType=BIGINT}, #{sumRowsExamined,jdbcType=BIGINT}, #{sumCreatedTmpDiskTables,jdbcType=BIGINT}, 
      #{sumCreatedTmpTables,jdbcType=BIGINT}, #{sumSelectFullJoin,jdbcType=BIGINT}, #{sumSelectFullRangeJoin,jdbcType=BIGINT}, 
      #{sumSelectRange,jdbcType=BIGINT}, #{sumSelectRangeCheck,jdbcType=BIGINT}, #{sumSelectScan,jdbcType=BIGINT}, 
      #{sumSortMergePasses,jdbcType=BIGINT}, #{sumSortRange,jdbcType=BIGINT}, #{sumSortRows,jdbcType=BIGINT}, 
      #{sumSortScan,jdbcType=BIGINT}, #{sumNoIndexUsed,jdbcType=BIGINT}, #{sumNoGoodIndexUsed,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, HOST, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT, SUM_LOCK_TIME, SUM_ERRORS, SUM_WARNINGS, SUM_ROWS_AFFECTED, SUM_ROWS_SENT, 
    SUM_ROWS_EXAMINED, SUM_CREATED_TMP_DISK_TABLES, SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, 
    SUM_SELECT_FULL_RANGE_JOIN, SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, 
    SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, SUM_SORT_SCAN, SUM_NO_INDEX_USED, 
    SUM_NO_GOOD_INDEX_USED
    from events_statements_summary_by_account_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="variable_name" jdbcType="VARCHAR" property="variableName" />
    <result column="variable_value" jdbcType="VARCHAR" property="variableValue" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into ps_check_lost_instrumentation (variable_name, variable_value)
    values (#{variableName,jdbcType=VARCHAR}, #{variableValue,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select variable_name, variable_value
    from ps_check_lost_instrumentation
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="tid" jdbcType="INTEGER" property="tid" />
    <result column="fraction" jdbcType="INTEGER" property="fraction" />
    <result column="uid" jdbcType="VARCHAR" property="uid" />
    <result column="startTime" jdbcType="TIMESTAMP" property="starttime" />
    <result column="endTime" jdbcType="TIMESTAMP" property="endtime" />
    <result column="answerNumber" jdbcType="INTEGER" property="answernumber" />
    <result column="Subject" jdbcType="VARCHAR" property="subject" />
    <result column="sortId" jdbcType="VARCHAR" property="sortid" />
    <result column="allTopic" jdbcType="LONGVARCHAR" property="alltopic" />
    <result column="correctAnswer" jdbcType="LONGVARCHAR" property="correctanswer" />
    <result column="errorAnswer" jdbcType="LONGVARCHAR" property="erroranswer" />
    <result column="allAnswer" jdbcType="LONGVARCHAR" property="allanswer" />
    <result column="returnJson" jdbcType="LONGVARCHAR" property="returnjson" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from t_statistics
    where tid = #{tid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into t_statistics (tid, fraction, uid, 
      startTime, endTime, answerNumber, 
      Subject, sortId, allTopic, 
      correctAnswer, errorAnswer, allAnswer, 
      returnJson)
    values (#{tid,jdbcType=INTEGER}, #{fraction,jdbcType=INTEGER}, #{uid,jdbcType=VARCHAR}, 
      #{starttime,jdbcType=TIMESTAMP}, #{endtime,jdbcType=TIMESTAMP}, #{answernumber,jdbcType=INTEGER}, 
      #{subject,jdbcType=VARCHAR}, #{sortid,jdbcType=VARCHAR}, #{alltopic,jdbcType=LONGVARCHAR}, 
      #{correctanswer,jdbcType=LONGVARCHAR}, #{erroranswer,jdbcType=LONGVARCHAR}, #{allanswer,jdbcType=LONGVARCHAR}, 
      #{returnjson,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update t_statistics
    set fraction = #{fraction,jdbcType=INTEGER},
      uid = #{uid,jdbcType=VARCHAR},
      startTime = #{starttime,jdbcType=TIMESTAMP},
      endTime = #{endtime,jdbcType=TIMESTAMP},
      answerNumber = #{answernumber,jdbcType=INTEGER},
      Subject = #{subject,jdbcType=VARCHAR},
      sortId = #{sortid,jdbcType=VARCHAR},
      allTopic = #{alltopic,jdbcType=LONGVARCHAR},
      correctAnswer = #{correctanswer,jdbcType=LONGVARCHAR},
      errorAnswer = #{erroranswer,jdbcType=LONGVARCHAR},
      allAnswer = #{allanswer,jdbcType=LONGVARCHAR},
      returnJson = #{returnjson,jdbcType=LONGVARCHAR}
    where tid = #{tid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select tid, fraction, uid, startTime, endTime, answerNumber, Subject, sortId, allTopic, 
    correctAnswer, errorAnswer, allAnswer, returnJson
    from t_statistics
    where tid = #{tid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select tid, fraction, uid, startTime, endTime, answerNumber, Subject, sortId, allTopic, 
    correctAnswer, errorAnswer, allAnswer, returnJson
    from t_statistics
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="thread_id" jdbcType="BIGINT" property="threadId" />
    <result column="ssl_version" jdbcType="VARCHAR" property="sslVersion" />
    <result column="ssl_cipher" jdbcType="VARCHAR" property="sslCipher" />
    <result column="ssl_sessions_reused" jdbcType="VARCHAR" property="sslSessionsReused" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into session_ssl_status (thread_id, ssl_version, ssl_cipher, 
      ssl_sessions_reused)
    values (#{threadId,jdbcType=BIGINT}, #{sslVersion,jdbcType=VARCHAR}, #{sslCipher,jdbcType=VARCHAR}, 
      #{sslSessionsReused,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select thread_id, ssl_version, ssl_cipher, ssl_sessions_reused
    from session_ssl_status
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="exec_count" jdbcType="BIGINT" property="execCount" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="no_index_used_count" jdbcType="BIGINT" property="noIndexUsedCount" />
    <result column="no_good_index_used_count" jdbcType="BIGINT" property="noGoodIndexUsedCount" />
    <result column="no_index_used_pct" jdbcType="DECIMAL" property="noIndexUsedPct" />
    <result column="rows_sent" jdbcType="BIGINT" property="rowsSent" />
    <result column="rows_examined" jdbcType="BIGINT" property="rowsExamined" />
    <result column="rows_sent_avg" jdbcType="DECIMAL" property="rowsSentAvg" />
    <result column="rows_examined_avg" jdbcType="DECIMAL" property="rowsExaminedAvg" />
    <result column="first_seen" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="last_seen" jdbcType="TIMESTAMP" property="lastSeen" />
    <result column="digest" jdbcType="VARCHAR" property="digest" />
    <result column="query" jdbcType="LONGVARCHAR" property="query" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$statements_with_full_table_scans (db, exec_count, total_latency, 
      no_index_used_count, no_good_index_used_count, no_index_used_pct, 
      rows_sent, rows_examined, rows_sent_avg, 
      rows_examined_avg, first_seen, last_seen, 
      digest, query)
    values (#{db,jdbcType=VARCHAR}, #{execCount,jdbcType=BIGINT}, #{totalLatency,jdbcType=BIGINT}, 
      #{noIndexUsedCount,jdbcType=BIGINT}, #{noGoodIndexUsedCount,jdbcType=BIGINT}, #{noIndexUsedPct,jdbcType=DECIMAL}, 
      #{rowsSent,jdbcType=BIGINT}, #{rowsExamined,jdbcType=BIGINT}, #{rowsSentAvg,jdbcType=DECIMAL}, 
      #{rowsExaminedAvg,jdbcType=DECIMAL}, #{firstSeen,jdbcType=TIMESTAMP}, #{lastSeen,jdbcType=TIMESTAMP}, 
      #{digest,jdbcType=VARCHAR}, #{query,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select db, exec_count, total_latency, no_index_used_count, no_good_index_used_count, 
    no_index_used_pct, rows_sent, rows_examined, rows_sent_avg, rows_examined_avg, first_seen, 
    last_seen, digest, query
    from x$statements_with_full_table_scans
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="cost_name" jdbcType="VARCHAR" property="costName" />
    <id column="engine_name" jdbcType="VARCHAR" property="engineName" />
    <id column="device_type" jdbcType="INTEGER" property="deviceType" />
    <result column="cost_value" jdbcType="REAL" property="costValue" />
    <result column="last_update" jdbcType="TIMESTAMP" property="lastUpdate" />
    <result column="comment" jdbcType="VARCHAR" property="comment" />
    <result column="default_value" jdbcType="REAL" property="defaultValue" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from engine_cost
    where cost_name = #{costName,jdbcType=VARCHAR}
      and engine_name = #{engineName,jdbcType=VARCHAR}
      and device_type = #{deviceType,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into engine_cost (cost_name, engine_name, device_type, 
      cost_value, last_update, comment, 
      default_value)
    values (#{costName,jdbcType=VARCHAR}, #{engineName,jdbcType=VARCHAR}, #{deviceType,jdbcType=INTEGER}, 
      #{costValue,jdbcType=REAL}, #{lastUpdate,jdbcType=TIMESTAMP}, #{comment,jdbcType=VARCHAR}, 
      #{defaultValue,jdbcType=REAL})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update engine_cost
    set cost_value = #{costValue,jdbcType=REAL},
      last_update = #{lastUpdate,jdbcType=TIMESTAMP},
      comment = #{comment,jdbcType=VARCHAR},
      default_value = #{defaultValue,jdbcType=REAL}
    where cost_name = #{costName,jdbcType=VARCHAR}
      and engine_name = #{engineName,jdbcType=VARCHAR}
      and device_type = #{deviceType,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select cost_name, engine_name, device_type, cost_value, last_update, comment, default_value
    from engine_cost
    where cost_name = #{costName,jdbcType=VARCHAR}
      and engine_name = #{engineName,jdbcType=VARCHAR}
      and device_type = #{deviceType,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select cost_name, engine_name, device_type, cost_value, last_update, comment, default_value
    from engine_cost
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="full_scan" jdbcType="VARCHAR" property="fullScan" />
    <result column="exec_count" jdbcType="BIGINT" property="execCount" />
    <result column="err_count" jdbcType="BIGINT" property="errCount" />
    <result column="warn_count" jdbcType="BIGINT" property="warnCount" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="max_latency" jdbcType="BIGINT" property="maxLatency" />
    <result column="avg_latency" jdbcType="BIGINT" property="avgLatency" />
    <result column="lock_latency" jdbcType="BIGINT" property="lockLatency" />
    <result column="rows_sent" jdbcType="BIGINT" property="rowsSent" />
    <result column="rows_sent_avg" jdbcType="DECIMAL" property="rowsSentAvg" />
    <result column="rows_examined" jdbcType="BIGINT" property="rowsExamined" />
    <result column="rows_examined_avg" jdbcType="DECIMAL" property="rowsExaminedAvg" />
    <result column="rows_affected" jdbcType="BIGINT" property="rowsAffected" />
    <result column="rows_affected_avg" jdbcType="DECIMAL" property="rowsAffectedAvg" />
    <result column="tmp_tables" jdbcType="BIGINT" property="tmpTables" />
    <result column="tmp_disk_tables" jdbcType="BIGINT" property="tmpDiskTables" />
    <result column="rows_sorted" jdbcType="BIGINT" property="rowsSorted" />
    <result column="sort_merge_passes" jdbcType="BIGINT" property="sortMergePasses" />
    <result column="digest" jdbcType="VARCHAR" property="digest" />
    <result column="first_seen" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="last_seen" jdbcType="TIMESTAMP" property="lastSeen" />
    <result column="query" jdbcType="LONGVARCHAR" property="query" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$statement_analysis (db, full_scan, exec_count, 
      err_count, warn_count, total_latency, 
      max_latency, avg_latency, lock_latency, 
      rows_sent, rows_sent_avg, rows_examined, 
      rows_examined_avg, rows_affected, rows_affected_avg, 
      tmp_tables, tmp_disk_tables, rows_sorted, 
      sort_merge_passes, digest, first_seen, 
      last_seen, query)
    values (#{db,jdbcType=VARCHAR}, #{fullScan,jdbcType=VARCHAR}, #{execCount,jdbcType=BIGINT}, 
      #{errCount,jdbcType=BIGINT}, #{warnCount,jdbcType=BIGINT}, #{totalLatency,jdbcType=BIGINT}, 
      #{maxLatency,jdbcType=BIGINT}, #{avgLatency,jdbcType=BIGINT}, #{lockLatency,jdbcType=BIGINT}, 
      #{rowsSent,jdbcType=BIGINT}, #{rowsSentAvg,jdbcType=DECIMAL}, #{rowsExamined,jdbcType=BIGINT}, 
      #{rowsExaminedAvg,jdbcType=DECIMAL}, #{rowsAffected,jdbcType=BIGINT}, #{rowsAffectedAvg,jdbcType=DECIMAL}, 
      #{tmpTables,jdbcType=BIGINT}, #{tmpDiskTables,jdbcType=BIGINT}, #{rowsSorted,jdbcType=BIGINT}, 
      #{sortMergePasses,jdbcType=BIGINT}, #{digest,jdbcType=VARCHAR}, #{firstSeen,jdbcType=TIMESTAMP}, 
      #{lastSeen,jdbcType=TIMESTAMP}, #{query,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select db, full_scan, exec_count, err_count, warn_count, total_latency, max_latency, 
    avg_latency, lock_latency, rows_sent, rows_sent_avg, rows_examined, rows_examined_avg, 
    rows_affected, rows_affected_avg, tmp_tables, tmp_disk_tables, rows_sorted, sort_merge_passes, 
    digest, first_seen, last_seen, query
    from x$statement_analysis
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="event_name" jdbcType="VARCHAR" property="eventName" />
    <result column="current_count" jdbcType="BIGINT" property="currentCount" />
    <result column="current_alloc" jdbcType="BIGINT" property="currentAlloc" />
    <result column="current_avg_alloc" jdbcType="DECIMAL" property="currentAvgAlloc" />
    <result column="high_count" jdbcType="BIGINT" property="highCount" />
    <result column="high_alloc" jdbcType="BIGINT" property="highAlloc" />
    <result column="high_avg_alloc" jdbcType="DECIMAL" property="highAvgAlloc" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$memory_global_by_current_bytes (event_name, current_count, current_alloc, 
      current_avg_alloc, high_count, high_alloc, 
      high_avg_alloc)
    values (#{eventName,jdbcType=VARCHAR}, #{currentCount,jdbcType=BIGINT}, #{currentAlloc,jdbcType=BIGINT}, 
      #{currentAvgAlloc,jdbcType=DECIMAL}, #{highCount,jdbcType=BIGINT}, #{highAlloc,jdbcType=BIGINT}, 
      #{highAvgAlloc,jdbcType=DECIMAL})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select event_name, current_count, current_alloc, current_avg_alloc, high_count, high_alloc, 
    high_avg_alloc
    from x$memory_global_by_current_bytes
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="allocated" jdbcType="DECIMAL" property="allocated" />
    <result column="data" jdbcType="DECIMAL" property="data" />
    <result column="pages" jdbcType="BIGINT" property="pages" />
    <result column="pages_hashed" jdbcType="BIGINT" property="pagesHashed" />
    <result column="pages_old" jdbcType="BIGINT" property="pagesOld" />
    <result column="rows_cached" jdbcType="DECIMAL" property="rowsCached" />
    <result column="object_schema" jdbcType="LONGVARCHAR" property="objectSchema" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$innodb_buffer_stats_by_schema (allocated, data, pages, 
      pages_hashed, pages_old, rows_cached, 
      object_schema)
    values (#{allocated,jdbcType=DECIMAL}, #{data,jdbcType=DECIMAL}, #{pages,jdbcType=BIGINT}, 
      #{pagesHashed,jdbcType=BIGINT}, #{pagesOld,jdbcType=BIGINT}, #{rowsCached,jdbcType=DECIMAL}, 
      #{objectSchema,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select allocated, data, pages, pages_hashed, pages_old, rows_cached, object_schema
    from x$innodb_buffer_stats_by_schema
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="SRS_NAME" jdbcType="VARCHAR" property="srsName" />
    <result column="SRS_ID" jdbcType="INTEGER" property="srsId" />
    <result column="ORGANIZATION" jdbcType="VARCHAR" property="organization" />
    <result column="ORGANIZATION_COORDSYS_ID" jdbcType="INTEGER" property="organizationCoordsysId" />
    <result column="DEFINITION" jdbcType="VARCHAR" property="definition" />
    <result column="DESCRIPTION" jdbcType="VARCHAR" property="description" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into ST_SPATIAL_REFERENCE_SYSTEMS (SRS_NAME, SRS_ID, ORGANIZATION, 
      ORGANIZATION_COORDSYS_ID, DEFINITION, DESCRIPTION
      )
    values (#{srsName,jdbcType=VARCHAR}, #{srsId,jdbcType=INTEGER}, #{organization,jdbcType=VARCHAR}, 
      #{organizationCoordsysId,jdbcType=INTEGER}, #{definition,jdbcType=VARCHAR}, #{description,jdbcType=VARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select SRS_NAME, SRS_ID, ORGANIZATION, ORGANIZATION_COORDSYS_ID, DEFINITION, DESCRIPTION
    from ST_SPATIAL_REFERENCE_SYSTEMS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="page_size" jdbcType="INTEGER" property="pageSize" />
    <result column="buffer_pool_instance" jdbcType="INTEGER" property="bufferPoolInstance" />
    <result column="pages_used" jdbcType="INTEGER" property="pagesUsed" />
    <result column="pages_free" jdbcType="INTEGER" property="pagesFree" />
    <result column="relocation_ops" jdbcType="BIGINT" property="relocationOps" />
    <result column="relocation_time" jdbcType="INTEGER" property="relocationTime" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_CMPMEM_RESET (page_size, buffer_pool_instance, pages_used, 
      pages_free, relocation_ops, relocation_time
      )
    values (#{pageSize,jdbcType=INTEGER}, #{bufferPoolInstance,jdbcType=INTEGER}, #{pagesUsed,jdbcType=INTEGER}, 
      #{pagesFree,jdbcType=INTEGER}, #{relocationOps,jdbcType=BIGINT}, #{relocationTime,jdbcType=INTEGER}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select page_size, buffer_pool_instance, pages_used, pages_free, relocation_ops, relocation_time
    from INNODB_CMPMEM_RESET
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="event" jdbcType="VARCHAR" property="event" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="avg_latency" jdbcType="BIGINT" property="avgLatency" />
    <result column="max_latency" jdbcType="BIGINT" property="maxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$waits_by_host_by_latency (host, event, total, 
      total_latency, avg_latency, max_latency
      )
    values (#{host,jdbcType=VARCHAR}, #{event,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{totalLatency,jdbcType=BIGINT}, #{avgLatency,jdbcType=BIGINT}, #{maxLatency,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, event, total, total_latency, avg_latency, max_latency
    from x$waits_by_host_by_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="TRIGGER_CATALOG" jdbcType="VARCHAR" property="triggerCatalog" />
    <result column="TRIGGER_SCHEMA" jdbcType="VARCHAR" property="triggerSchema" />
    <result column="TRIGGER_NAME" jdbcType="VARCHAR" property="triggerName" />
    <result column="EVENT_MANIPULATION" jdbcType="CHAR" property="eventManipulation" />
    <result column="EVENT_OBJECT_CATALOG" jdbcType="VARCHAR" property="eventObjectCatalog" />
    <result column="EVENT_OBJECT_SCHEMA" jdbcType="VARCHAR" property="eventObjectSchema" />
    <result column="EVENT_OBJECT_TABLE" jdbcType="VARCHAR" property="eventObjectTable" />
    <result column="ACTION_ORDER" jdbcType="INTEGER" property="actionOrder" />
    <result column="ACTION_ORIENTATION" jdbcType="VARCHAR" property="actionOrientation" />
    <result column="ACTION_TIMING" jdbcType="CHAR" property="actionTiming" />
    <result column="ACTION_REFERENCE_OLD_ROW" jdbcType="VARCHAR" property="actionReferenceOldRow" />
    <result column="ACTION_REFERENCE_NEW_ROW" jdbcType="VARCHAR" property="actionReferenceNewRow" />
    <result column="CREATED" jdbcType="TIMESTAMP" property="created" />
    <result column="SQL_MODE" jdbcType="CHAR" property="sqlMode" />
    <result column="DEFINER" jdbcType="VARCHAR" property="definer" />
    <result column="CHARACTER_SET_CLIENT" jdbcType="VARCHAR" property="characterSetClient" />
    <result column="COLLATION_CONNECTION" jdbcType="VARCHAR" property="collationConnection" />
    <result column="DATABASE_COLLATION" jdbcType="VARCHAR" property="databaseCollation" />
    <result column="ACTION_CONDITION" jdbcType="BINARY" property="actionCondition" />
    <result column="ACTION_STATEMENT" jdbcType="LONGVARCHAR" property="actionStatement" />
    <result column="ACTION_REFERENCE_OLD_TABLE" jdbcType="BINARY" property="actionReferenceOldTable" />
    <result column="ACTION_REFERENCE_NEW_TABLE" jdbcType="BINARY" property="actionReferenceNewTable" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into TRIGGERS (TRIGGER_CATALOG, TRIGGER_SCHEMA, TRIGGER_NAME, 
      EVENT_MANIPULATION, EVENT_OBJECT_CATALOG, EVENT_OBJECT_SCHEMA, 
      EVENT_OBJECT_TABLE, ACTION_ORDER, ACTION_ORIENTATION, 
      ACTION_TIMING, ACTION_REFERENCE_OLD_ROW, ACTION_REFERENCE_NEW_ROW, 
      CREATED, SQL_MODE, DEFINER, 
      CHARACTER_SET_CLIENT, COLLATION_CONNECTION, 
      DATABASE_COLLATION, ACTION_CONDITION, ACTION_STATEMENT, 
      ACTION_REFERENCE_OLD_TABLE, ACTION_REFERENCE_NEW_TABLE
      )
    values (#{triggerCatalog,jdbcType=VARCHAR}, #{triggerSchema,jdbcType=VARCHAR}, #{triggerName,jdbcType=VARCHAR}, 
      #{eventManipulation,jdbcType=CHAR}, #{eventObjectCatalog,jdbcType=VARCHAR}, #{eventObjectSchema,jdbcType=VARCHAR}, 
      #{eventObjectTable,jdbcType=VARCHAR}, #{actionOrder,jdbcType=INTEGER}, #{actionOrientation,jdbcType=VARCHAR}, 
      #{actionTiming,jdbcType=CHAR}, #{actionReferenceOldRow,jdbcType=VARCHAR}, #{actionReferenceNewRow,jdbcType=VARCHAR}, 
      #{created,jdbcType=TIMESTAMP}, #{sqlMode,jdbcType=CHAR}, #{definer,jdbcType=VARCHAR}, 
      #{characterSetClient,jdbcType=VARCHAR}, #{collationConnection,jdbcType=VARCHAR}, 
      #{databaseCollation,jdbcType=VARCHAR}, #{actionCondition,jdbcType=BINARY}, #{actionStatement,jdbcType=LONGVARCHAR}, 
      #{actionReferenceOldTable,jdbcType=BINARY}, #{actionReferenceNewTable,jdbcType=BINARY}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select TRIGGER_CATALOG, TRIGGER_SCHEMA, TRIGGER_NAME, EVENT_MANIPULATION, EVENT_OBJECT_CATALOG, 
    EVENT_OBJECT_SCHEMA, EVENT_OBJECT_TABLE, ACTION_ORDER, ACTION_ORIENTATION, ACTION_TIMING, 
    ACTION_REFERENCE_OLD_ROW, ACTION_REFERENCE_NEW_ROW, CREATED, SQL_MODE, DEFINER, CHARACTER_SET_CLIENT, 
    COLLATION_CONNECTION, DATABASE_COLLATION, ACTION_CONDITION, ACTION_STATEMENT, ACTION_REFERENCE_OLD_TABLE, 
    ACTION_REFERENCE_NEW_TABLE
    from TRIGGERS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="GRANTEE" jdbcType="VARCHAR" property="grantee" />
    <result column="TABLE_CATALOG" jdbcType="VARCHAR" property="tableCatalog" />
    <result column="PRIVILEGE_TYPE" jdbcType="VARCHAR" property="privilegeType" />
    <result column="IS_GRANTABLE" jdbcType="VARCHAR" property="isGrantable" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into USER_PRIVILEGES (GRANTEE, TABLE_CATALOG, PRIVILEGE_TYPE, 
      IS_GRANTABLE)
    values (#{grantee,jdbcType=VARCHAR}, #{tableCatalog,jdbcType=VARCHAR}, #{privilegeType,jdbcType=VARCHAR}, 
      #{isGrantable,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select GRANTEE, TABLE_CATALOG, PRIVILEGE_TYPE, IS_GRANTABLE
    from USER_PRIVILEGES
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="SCHEMA_NAME" jdbcType="VARCHAR" property="schemaName" />
    <result column="DIGEST" jdbcType="VARCHAR" property="digest" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="SUM_LOCK_TIME" jdbcType="BIGINT" property="sumLockTime" />
    <result column="SUM_ERRORS" jdbcType="BIGINT" property="sumErrors" />
    <result column="SUM_WARNINGS" jdbcType="BIGINT" property="sumWarnings" />
    <result column="SUM_ROWS_AFFECTED" jdbcType="BIGINT" property="sumRowsAffected" />
    <result column="SUM_ROWS_SENT" jdbcType="BIGINT" property="sumRowsSent" />
    <result column="SUM_ROWS_EXAMINED" jdbcType="BIGINT" property="sumRowsExamined" />
    <result column="SUM_CREATED_TMP_DISK_TABLES" jdbcType="BIGINT" property="sumCreatedTmpDiskTables" />
    <result column="SUM_CREATED_TMP_TABLES" jdbcType="BIGINT" property="sumCreatedTmpTables" />
    <result column="SUM_SELECT_FULL_JOIN" jdbcType="BIGINT" property="sumSelectFullJoin" />
    <result column="SUM_SELECT_FULL_RANGE_JOIN" jdbcType="BIGINT" property="sumSelectFullRangeJoin" />
    <result column="SUM_SELECT_RANGE" jdbcType="BIGINT" property="sumSelectRange" />
    <result column="SUM_SELECT_RANGE_CHECK" jdbcType="BIGINT" property="sumSelectRangeCheck" />
    <result column="SUM_SELECT_SCAN" jdbcType="BIGINT" property="sumSelectScan" />
    <result column="SUM_SORT_MERGE_PASSES" jdbcType="BIGINT" property="sumSortMergePasses" />
    <result column="SUM_SORT_RANGE" jdbcType="BIGINT" property="sumSortRange" />
    <result column="SUM_SORT_ROWS" jdbcType="BIGINT" property="sumSortRows" />
    <result column="SUM_SORT_SCAN" jdbcType="BIGINT" property="sumSortScan" />
    <result column="SUM_NO_INDEX_USED" jdbcType="BIGINT" property="sumNoIndexUsed" />
    <result column="SUM_NO_GOOD_INDEX_USED" jdbcType="BIGINT" property="sumNoGoodIndexUsed" />
    <result column="FIRST_SEEN" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="LAST_SEEN" jdbcType="TIMESTAMP" property="lastSeen" />
    <result column="QUANTILE_95" jdbcType="BIGINT" property="quantile95" />
    <result column="QUANTILE_99" jdbcType="BIGINT" property="quantile99" />
    <result column="QUANTILE_999" jdbcType="BIGINT" property="quantile999" />
    <result column="QUERY_SAMPLE_SEEN" jdbcType="TIMESTAMP" property="querySampleSeen" />
    <result column="QUERY_SAMPLE_TIMER_WAIT" jdbcType="BIGINT" property="querySampleTimerWait" />
    <result column="DIGEST_TEXT" jdbcType="LONGVARCHAR" property="digestText" />
    <result column="QUERY_SAMPLE_TEXT" jdbcType="LONGVARCHAR" property="querySampleText" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_statements_summary_by_digest (SCHEMA_NAME, DIGEST, COUNT_STAR, 
      SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
      MAX_TIMER_WAIT, SUM_LOCK_TIME, SUM_ERRORS, 
      SUM_WARNINGS, SUM_ROWS_AFFECTED, SUM_ROWS_SENT, 
      SUM_ROWS_EXAMINED, SUM_CREATED_TMP_DISK_TABLES, 
      SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, SUM_SELECT_FULL_RANGE_JOIN, 
      SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, 
      SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, 
      SUM_SORT_SCAN, SUM_NO_INDEX_USED, SUM_NO_GOOD_INDEX_USED, 
      FIRST_SEEN, LAST_SEEN, QUANTILE_95, 
      QUANTILE_99, QUANTILE_999, QUERY_SAMPLE_SEEN, 
      QUERY_SAMPLE_TIMER_WAIT, DIGEST_TEXT, QUERY_SAMPLE_TEXT
      )
    values (#{schemaName,jdbcType=VARCHAR}, #{digest,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, 
      #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, 
      #{maxTimerWait,jdbcType=BIGINT}, #{sumLockTime,jdbcType=BIGINT}, #{sumErrors,jdbcType=BIGINT}, 
      #{sumWarnings,jdbcType=BIGINT}, #{sumRowsAffected,jdbcType=BIGINT}, #{sumRowsSent,jdbcType=BIGINT}, 
      #{sumRowsExamined,jdbcType=BIGINT}, #{sumCreatedTmpDiskTables,jdbcType=BIGINT}, 
      #{sumCreatedTmpTables,jdbcType=BIGINT}, #{sumSelectFullJoin,jdbcType=BIGINT}, #{sumSelectFullRangeJoin,jdbcType=BIGINT}, 
      #{sumSelectRange,jdbcType=BIGINT}, #{sumSelectRangeCheck,jdbcType=BIGINT}, #{sumSelectScan,jdbcType=BIGINT}, 
      #{sumSortMergePasses,jdbcType=BIGINT}, #{sumSortRange,jdbcType=BIGINT}, #{sumSortRows,jdbcType=BIGINT}, 
      #{sumSortScan,jdbcType=BIGINT}, #{sumNoIndexUsed,jdbcType=BIGINT}, #{sumNoGoodIndexUsed,jdbcType=BIGINT}, 
      #{firstSeen,jdbcType=TIMESTAMP}, #{lastSeen,jdbcType=TIMESTAMP}, #{quantile95,jdbcType=BIGINT}, 
      #{quantile99,jdbcType=BIGINT}, #{quantile999,jdbcType=BIGINT}, #{querySampleSeen,jdbcType=TIMESTAMP}, 
      #{querySampleTimerWait,jdbcType=BIGINT}, #{digestText,jdbcType=LONGVARCHAR}, #{querySampleText,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select SCHEMA_NAME, DIGEST, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT, SUM_LOCK_TIME, SUM_ERRORS, SUM_WARNINGS, SUM_ROWS_AFFECTED, SUM_ROWS_SENT, 
    SUM_ROWS_EXAMINED, SUM_CREATED_TMP_DISK_TABLES, SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, 
    SUM_SELECT_FULL_RANGE_JOIN, SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, 
    SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, SUM_SORT_SCAN, SUM_NO_INDEX_USED, 
    SUM_NO_GOOD_INDEX_USED, FIRST_SEEN, LAST_SEEN, QUANTILE_95, QUANTILE_99, QUANTILE_999, 
    QUERY_SAMPLE_SEEN, QUERY_SAMPLE_TIMER_WAIT, DIGEST_TEXT, QUERY_SAMPLE_TEXT
    from events_statements_summary_by_digest
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="exid" jdbcType="BIGINT" property="exid" />
    <result column="err_code" jdbcType="VARCHAR" property="errCode" />
    <result column="createtime" jdbcType="TIMESTAMP" property="createtime" />
    <result column="trigger_ip" jdbcType="VARCHAR" property="triggerIp" />
    <result column="status" jdbcType="INTEGER" property="status" />
    <result column="err_msg" jdbcType="LONGVARCHAR" property="errMsg" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from gloexception
    where exid = #{exid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into gloexception (exid, err_code, createtime, 
      trigger_ip, status, err_msg
      )
    values (#{exid,jdbcType=BIGINT}, #{errCode,jdbcType=VARCHAR}, #{createtime,jdbcType=TIMESTAMP}, 
      #{triggerIp,jdbcType=VARCHAR}, #{status,jdbcType=INTEGER}, #{errMsg,jdbcType=LONGVARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update gloexception
    set err_code = #{errCode,jdbcType=VARCHAR},
      createtime = #{createtime,jdbcType=TIMESTAMP},
      trigger_ip = #{triggerIp,jdbcType=VARCHAR},
      status = #{status,jdbcType=INTEGER},
      err_msg = #{errMsg,jdbcType=LONGVARCHAR}
    where exid = #{exid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select exid, err_code, createtime, trigger_ip, status, err_msg
    from gloexception
    where exid = #{exid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select exid, err_code, createtime, trigger_ip, status, err_msg
    from gloexception
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="courseNO" jdbcType="INTEGER" property="courseno" />
    <result column="courseName" jdbcType="VARCHAR" property="coursename" />
    <result column="marks" jdbcType="INTEGER" property="marks" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into t_course (courseNO, courseName, marks
      )
    values (#{courseno,jdbcType=INTEGER}, #{coursename,jdbcType=VARCHAR}, #{marks,jdbcType=INTEGER}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select courseNO, courseName, marks
    from t_course
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="SUM_LOCK_TIME" jdbcType="BIGINT" property="sumLockTime" />
    <result column="SUM_ERRORS" jdbcType="BIGINT" property="sumErrors" />
    <result column="SUM_WARNINGS" jdbcType="BIGINT" property="sumWarnings" />
    <result column="SUM_ROWS_AFFECTED" jdbcType="BIGINT" property="sumRowsAffected" />
    <result column="SUM_ROWS_SENT" jdbcType="BIGINT" property="sumRowsSent" />
    <result column="SUM_ROWS_EXAMINED" jdbcType="BIGINT" property="sumRowsExamined" />
    <result column="SUM_CREATED_TMP_DISK_TABLES" jdbcType="BIGINT" property="sumCreatedTmpDiskTables" />
    <result column="SUM_CREATED_TMP_TABLES" jdbcType="BIGINT" property="sumCreatedTmpTables" />
    <result column="SUM_SELECT_FULL_JOIN" jdbcType="BIGINT" property="sumSelectFullJoin" />
    <result column="SUM_SELECT_FULL_RANGE_JOIN" jdbcType="BIGINT" property="sumSelectFullRangeJoin" />
    <result column="SUM_SELECT_RANGE" jdbcType="BIGINT" property="sumSelectRange" />
    <result column="SUM_SELECT_RANGE_CHECK" jdbcType="BIGINT" property="sumSelectRangeCheck" />
    <result column="SUM_SELECT_SCAN" jdbcType="BIGINT" property="sumSelectScan" />
    <result column="SUM_SORT_MERGE_PASSES" jdbcType="BIGINT" property="sumSortMergePasses" />
    <result column="SUM_SORT_RANGE" jdbcType="BIGINT" property="sumSortRange" />
    <result column="SUM_SORT_ROWS" jdbcType="BIGINT" property="sumSortRows" />
    <result column="SUM_SORT_SCAN" jdbcType="BIGINT" property="sumSortScan" />
    <result column="SUM_NO_INDEX_USED" jdbcType="BIGINT" property="sumNoIndexUsed" />
    <result column="SUM_NO_GOOD_INDEX_USED" jdbcType="BIGINT" property="sumNoGoodIndexUsed" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from events_statements_summary_by_thread_by_event_name
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_statements_summary_by_thread_by_event_name (THREAD_ID, EVENT_NAME, COUNT_STAR, 
      SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
      MAX_TIMER_WAIT, SUM_LOCK_TIME, SUM_ERRORS, 
      SUM_WARNINGS, SUM_ROWS_AFFECTED, SUM_ROWS_SENT, 
      SUM_ROWS_EXAMINED, SUM_CREATED_TMP_DISK_TABLES, 
      SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, SUM_SELECT_FULL_RANGE_JOIN, 
      SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, 
      SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, 
      SUM_SORT_SCAN, SUM_NO_INDEX_USED, SUM_NO_GOOD_INDEX_USED
      )
    values (#{threadId,jdbcType=BIGINT}, #{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, 
      #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, 
      #{maxTimerWait,jdbcType=BIGINT}, #{sumLockTime,jdbcType=BIGINT}, #{sumErrors,jdbcType=BIGINT}, 
      #{sumWarnings,jdbcType=BIGINT}, #{sumRowsAffected,jdbcType=BIGINT}, #{sumRowsSent,jdbcType=BIGINT}, 
      #{sumRowsExamined,jdbcType=BIGINT}, #{sumCreatedTmpDiskTables,jdbcType=BIGINT}, 
      #{sumCreatedTmpTables,jdbcType=BIGINT}, #{sumSelectFullJoin,jdbcType=BIGINT}, #{sumSelectFullRangeJoin,jdbcType=BIGINT}, 
      #{sumSelectRange,jdbcType=BIGINT}, #{sumSelectRangeCheck,jdbcType=BIGINT}, #{sumSelectScan,jdbcType=BIGINT}, 
      #{sumSortMergePasses,jdbcType=BIGINT}, #{sumSortRange,jdbcType=BIGINT}, #{sumSortRows,jdbcType=BIGINT}, 
      #{sumSortScan,jdbcType=BIGINT}, #{sumNoIndexUsed,jdbcType=BIGINT}, #{sumNoGoodIndexUsed,jdbcType=BIGINT}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_statements_summary_by_thread_by_event_name
    set COUNT_STAR = #{countStar,jdbcType=BIGINT},
      SUM_TIMER_WAIT = #{sumTimerWait,jdbcType=BIGINT},
      MIN_TIMER_WAIT = #{minTimerWait,jdbcType=BIGINT},
      AVG_TIMER_WAIT = #{avgTimerWait,jdbcType=BIGINT},
      MAX_TIMER_WAIT = #{maxTimerWait,jdbcType=BIGINT},
      SUM_LOCK_TIME = #{sumLockTime,jdbcType=BIGINT},
      SUM_ERRORS = #{sumErrors,jdbcType=BIGINT},
      SUM_WARNINGS = #{sumWarnings,jdbcType=BIGINT},
      SUM_ROWS_AFFECTED = #{sumRowsAffected,jdbcType=BIGINT},
      SUM_ROWS_SENT = #{sumRowsSent,jdbcType=BIGINT},
      SUM_ROWS_EXAMINED = #{sumRowsExamined,jdbcType=BIGINT},
      SUM_CREATED_TMP_DISK_TABLES = #{sumCreatedTmpDiskTables,jdbcType=BIGINT},
      SUM_CREATED_TMP_TABLES = #{sumCreatedTmpTables,jdbcType=BIGINT},
      SUM_SELECT_FULL_JOIN = #{sumSelectFullJoin,jdbcType=BIGINT},
      SUM_SELECT_FULL_RANGE_JOIN = #{sumSelectFullRangeJoin,jdbcType=BIGINT},
      SUM_SELECT_RANGE = #{sumSelectRange,jdbcType=BIGINT},
      SUM_SELECT_RANGE_CHECK = #{sumSelectRangeCheck,jdbcType=BIGINT},
      SUM_SELECT_SCAN = #{sumSelectScan,jdbcType=BIGINT},
      SUM_SORT_MERGE_PASSES = #{sumSortMergePasses,jdbcType=BIGINT},
      SUM_SORT_RANGE = #{sumSortRange,jdbcType=BIGINT},
      SUM_SORT_ROWS = #{sumSortRows,jdbcType=BIGINT},
      SUM_SORT_SCAN = #{sumSortScan,jdbcType=BIGINT},
      SUM_NO_INDEX_USED = #{sumNoIndexUsed,jdbcType=BIGINT},
      SUM_NO_GOOD_INDEX_USED = #{sumNoGoodIndexUsed,jdbcType=BIGINT}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT, SUM_LOCK_TIME, SUM_ERRORS, SUM_WARNINGS, SUM_ROWS_AFFECTED, SUM_ROWS_SENT, 
    SUM_ROWS_EXAMINED, SUM_CREATED_TMP_DISK_TABLES, SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, 
    SUM_SELECT_FULL_RANGE_JOIN, SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, 
    SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, SUM_SORT_SCAN, SUM_NO_INDEX_USED, 
    SUM_NO_GOOD_INDEX_USED
    from events_statements_summary_by_thread_by_event_name
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT, SUM_LOCK_TIME, SUM_ERRORS, SUM_WARNINGS, SUM_ROWS_AFFECTED, SUM_ROWS_SENT, 
    SUM_ROWS_EXAMINED, SUM_CREATED_TMP_DISK_TABLES, SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, 
    SUM_SELECT_FULL_RANGE_JOIN, SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, 
    SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, SUM_SORT_SCAN, SUM_NO_INDEX_USED, 
    SUM_NO_GOOD_INDEX_USED
    from events_statements_summary_by_thread_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="statements" jdbcType="DECIMAL" property="statements" />
    <result column="table_scans" jdbcType="DECIMAL" property="tableScans" />
    <result column="file_ios" jdbcType="DECIMAL" property="fileIos" />
    <result column="current_connections" jdbcType="DECIMAL" property="currentConnections" />
    <result column="total_connections" jdbcType="DECIMAL" property="totalConnections" />
    <result column="unique_hosts" jdbcType="BIGINT" property="uniqueHosts" />
    <result column="statement_latency" jdbcType="LONGVARCHAR" property="statementLatency" />
    <result column="statement_avg_latency" jdbcType="LONGVARCHAR" property="statementAvgLatency" />
    <result column="file_io_latency" jdbcType="LONGVARCHAR" property="fileIoLatency" />
    <result column="current_memory" jdbcType="LONGVARCHAR" property="currentMemory" />
    <result column="total_memory_allocated" jdbcType="LONGVARCHAR" property="totalMemoryAllocated" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into user_summary (user, statements, table_scans, 
      file_ios, current_connections, total_connections, 
      unique_hosts, statement_latency, statement_avg_latency, 
      file_io_latency, current_memory, total_memory_allocated
      )
    values (#{user,jdbcType=VARCHAR}, #{statements,jdbcType=DECIMAL}, #{tableScans,jdbcType=DECIMAL}, 
      #{fileIos,jdbcType=DECIMAL}, #{currentConnections,jdbcType=DECIMAL}, #{totalConnections,jdbcType=DECIMAL}, 
      #{uniqueHosts,jdbcType=BIGINT}, #{statementLatency,jdbcType=LONGVARCHAR}, #{statementAvgLatency,jdbcType=LONGVARCHAR}, 
      #{fileIoLatency,jdbcType=LONGVARCHAR}, #{currentMemory,jdbcType=LONGVARCHAR}, #{totalMemoryAllocated,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, statements, table_scans, file_ios, current_connections, total_connections, 
    unique_hosts, statement_latency, statement_avg_latency, file_io_latency, current_memory, 
    total_memory_allocated
    from user_summary
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="OBJECT_TYPE" jdbcType="VARCHAR" property="objectType" />
    <result column="OBJECT_SCHEMA" jdbcType="VARCHAR" property="objectSchema" />
    <result column="OBJECT_NAME" jdbcType="VARCHAR" property="objectName" />
    <result column="OWNER_THREAD_ID" jdbcType="BIGINT" property="ownerThreadId" />
    <result column="OWNER_EVENT_ID" jdbcType="BIGINT" property="ownerEventId" />
    <result column="INTERNAL_LOCK" jdbcType="VARCHAR" property="internalLock" />
    <result column="EXTERNAL_LOCK" jdbcType="VARCHAR" property="externalLock" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from table_handles
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into table_handles (OBJECT_INSTANCE_BEGIN, OBJECT_TYPE, OBJECT_SCHEMA, 
      OBJECT_NAME, OWNER_THREAD_ID, OWNER_EVENT_ID, 
      INTERNAL_LOCK, EXTERNAL_LOCK)
    values (#{objectInstanceBegin,jdbcType=BIGINT}, #{objectType,jdbcType=VARCHAR}, #{objectSchema,jdbcType=VARCHAR}, 
      #{objectName,jdbcType=VARCHAR}, #{ownerThreadId,jdbcType=BIGINT}, #{ownerEventId,jdbcType=BIGINT}, 
      #{internalLock,jdbcType=VARCHAR}, #{externalLock,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update table_handles
    set OBJECT_TYPE = #{objectType,jdbcType=VARCHAR},
      OBJECT_SCHEMA = #{objectSchema,jdbcType=VARCHAR},
      OBJECT_NAME = #{objectName,jdbcType=VARCHAR},
      OWNER_THREAD_ID = #{ownerThreadId,jdbcType=BIGINT},
      OWNER_EVENT_ID = #{ownerEventId,jdbcType=BIGINT},
      INTERNAL_LOCK = #{internalLock,jdbcType=VARCHAR},
      EXTERNAL_LOCK = #{externalLock,jdbcType=VARCHAR}
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, OWNER_THREAD_ID, 
    OWNER_EVENT_ID, INTERNAL_LOCK, EXTERNAL_LOCK
    from table_handles
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, OWNER_THREAD_ID, 
    OWNER_EVENT_ID, INTERNAL_LOCK, EXTERNAL_LOCK
    from table_handles
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="BUCKET_NUMBER" jdbcType="INTEGER" property="bucketNumber" />
    <result column="BUCKET_TIMER_LOW" jdbcType="BIGINT" property="bucketTimerLow" />
    <result column="BUCKET_TIMER_HIGH" jdbcType="BIGINT" property="bucketTimerHigh" />
    <result column="COUNT_BUCKET" jdbcType="BIGINT" property="countBucket" />
    <result column="COUNT_BUCKET_AND_LOWER" jdbcType="BIGINT" property="countBucketAndLower" />
    <result column="BUCKET_QUANTILE" jdbcType="DOUBLE" property="bucketQuantile" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from events_statements_histogram_global
    where BUCKET_NUMBER = #{bucketNumber,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_statements_histogram_global (BUCKET_NUMBER, BUCKET_TIMER_LOW, BUCKET_TIMER_HIGH, 
      COUNT_BUCKET, COUNT_BUCKET_AND_LOWER, BUCKET_QUANTILE
      )
    values (#{bucketNumber,jdbcType=INTEGER}, #{bucketTimerLow,jdbcType=BIGINT}, #{bucketTimerHigh,jdbcType=BIGINT}, 
      #{countBucket,jdbcType=BIGINT}, #{countBucketAndLower,jdbcType=BIGINT}, #{bucketQuantile,jdbcType=DOUBLE}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_statements_histogram_global
    set BUCKET_TIMER_LOW = #{bucketTimerLow,jdbcType=BIGINT},
      BUCKET_TIMER_HIGH = #{bucketTimerHigh,jdbcType=BIGINT},
      COUNT_BUCKET = #{countBucket,jdbcType=BIGINT},
      COUNT_BUCKET_AND_LOWER = #{countBucketAndLower,jdbcType=BIGINT},
      BUCKET_QUANTILE = #{bucketQuantile,jdbcType=DOUBLE}
    where BUCKET_NUMBER = #{bucketNumber,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select BUCKET_NUMBER, BUCKET_TIMER_LOW, BUCKET_TIMER_HIGH, COUNT_BUCKET, COUNT_BUCKET_AND_LOWER, 
    BUCKET_QUANTILE
    from events_statements_histogram_global
    where BUCKET_NUMBER = #{bucketNumber,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select BUCKET_NUMBER, BUCKET_TIMER_LOW, BUCKET_TIMER_HIGH, COUNT_BUCKET, COUNT_BUCKET_AND_LOWER, 
    BUCKET_QUANTILE
    from events_statements_histogram_global
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="database_name" jdbcType="VARCHAR" property="databaseName" />
    <id column="table_name" jdbcType="VARCHAR" property="tableName" />
    <id column="index_name" jdbcType="VARCHAR" property="indexName" />
    <id column="stat_name" jdbcType="VARCHAR" property="statName" />
    <result column="last_update" jdbcType="TIMESTAMP" property="lastUpdate" />
    <result column="stat_value" jdbcType="BIGINT" property="statValue" />
    <result column="sample_size" jdbcType="BIGINT" property="sampleSize" />
    <result column="stat_description" jdbcType="VARCHAR" property="statDescription" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from innodb_index_stats
    where database_name = #{databaseName,jdbcType=VARCHAR}
      and table_name = #{tableName,jdbcType=VARCHAR}
      and index_name = #{indexName,jdbcType=VARCHAR}
      and stat_name = #{statName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into innodb_index_stats (database_name, table_name, index_name, 
      stat_name, last_update, stat_value, 
      sample_size, stat_description)
    values (#{databaseName,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, #{indexName,jdbcType=VARCHAR}, 
      #{statName,jdbcType=VARCHAR}, #{lastUpdate,jdbcType=TIMESTAMP}, #{statValue,jdbcType=BIGINT}, 
      #{sampleSize,jdbcType=BIGINT}, #{statDescription,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update innodb_index_stats
    set last_update = #{lastUpdate,jdbcType=TIMESTAMP},
      stat_value = #{statValue,jdbcType=BIGINT},
      sample_size = #{sampleSize,jdbcType=BIGINT},
      stat_description = #{statDescription,jdbcType=VARCHAR}
    where database_name = #{databaseName,jdbcType=VARCHAR}
      and table_name = #{tableName,jdbcType=VARCHAR}
      and index_name = #{indexName,jdbcType=VARCHAR}
      and stat_name = #{statName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select database_name, table_name, index_name, stat_name, last_update, stat_value, 
    sample_size, stat_description
    from innodb_index_stats
    where database_name = #{databaseName,jdbcType=VARCHAR}
      and table_name = #{tableName,jdbcType=VARCHAR}
      and index_name = #{indexName,jdbcType=VARCHAR}
      and stat_name = #{statName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select database_name, table_name, index_name, stat_name, last_update, stat_value, 
    sample_size, stat_description
    from innodb_index_stats
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Time_zone_id" jdbcType="INTEGER" property="timeZoneId" />
    <result column="Use_leap_seconds" jdbcType="CHAR" property="useLeapSeconds" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from time_zone
    where Time_zone_id = #{timeZoneId,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into time_zone (Time_zone_id, Use_leap_seconds)
    values (#{timeZoneId,jdbcType=INTEGER}, #{useLeapSeconds,jdbcType=CHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update time_zone
    set Use_leap_seconds = #{useLeapSeconds,jdbcType=CHAR}
    where Time_zone_id = #{timeZoneId,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select Time_zone_id, Use_leap_seconds
    from time_zone
    where Time_zone_id = #{timeZoneId,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Time_zone_id, Use_leap_seconds
    from time_zone
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="TABLE_ID" jdbcType="BIGINT" property="tableId" />
    <result column="NAME" jdbcType="VARCHAR" property="name" />
    <result column="FLAG" jdbcType="INTEGER" property="flag" />
    <result column="N_COLS" jdbcType="INTEGER" property="nCols" />
    <result column="SPACE" jdbcType="BIGINT" property="space" />
    <result column="ROW_FORMAT" jdbcType="VARCHAR" property="rowFormat" />
    <result column="ZIP_PAGE_SIZE" jdbcType="INTEGER" property="zipPageSize" />
    <result column="SPACE_TYPE" jdbcType="VARCHAR" property="spaceType" />
    <result column="INSTANT_COLS" jdbcType="INTEGER" property="instantCols" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_TABLES (TABLE_ID, NAME, FLAG, 
      N_COLS, SPACE, ROW_FORMAT, 
      ZIP_PAGE_SIZE, SPACE_TYPE, INSTANT_COLS
      )
    values (#{tableId,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{flag,jdbcType=INTEGER}, 
      #{nCols,jdbcType=INTEGER}, #{space,jdbcType=BIGINT}, #{rowFormat,jdbcType=VARCHAR}, 
      #{zipPageSize,jdbcType=INTEGER}, #{spaceType,jdbcType=VARCHAR}, #{instantCols,jdbcType=INTEGER}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select TABLE_ID, NAME, FLAG, N_COLS, SPACE, ROW_FORMAT, ZIP_PAGE_SIZE, SPACE_TYPE, 
    INSTANT_COLS
    from INNODB_TABLES
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="eid" jdbcType="BIGINT" property="eid" />
    <result column="roles" jdbcType="VARCHAR" property="roles" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from menu
    where eid = #{eid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into menu (eid, roles)
    values (#{eid,jdbcType=BIGINT}, #{roles,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update menu
    set roles = #{roles,jdbcType=VARCHAR}
    where eid = #{eid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select eid, roles
    from menu
    where eid = #{eid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select eid, roles
    from menu
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="VIEW_CATALOG" jdbcType="VARCHAR" property="viewCatalog" />
    <result column="VIEW_SCHEMA" jdbcType="VARCHAR" property="viewSchema" />
    <result column="VIEW_NAME" jdbcType="VARCHAR" property="viewName" />
    <result column="TABLE_CATALOG" jdbcType="VARCHAR" property="tableCatalog" />
    <result column="TABLE_SCHEMA" jdbcType="VARCHAR" property="tableSchema" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into VIEW_TABLE_USAGE (VIEW_CATALOG, VIEW_SCHEMA, VIEW_NAME, 
      TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME
      )
    values (#{viewCatalog,jdbcType=VARCHAR}, #{viewSchema,jdbcType=VARCHAR}, #{viewName,jdbcType=VARCHAR}, 
      #{tableCatalog,jdbcType=VARCHAR}, #{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select VIEW_CATALOG, VIEW_SCHEMA, VIEW_NAME, TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME
    from VIEW_TABLE_USAGE
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="cnt" jdbcType="BIGINT" property="cnt" />
    <result column="avg_us" jdbcType="DECIMAL" property="avgUs" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$ps_digest_avg_latency_distribution (cnt, avg_us)
    values (#{cnt,jdbcType=BIGINT}, #{avgUs,jdbcType=DECIMAL})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select cnt, avg_us
    from x$ps_digest_avg_latency_distribution
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="pages" jdbcType="BIGINT" property="pages" />
    <result column="pages_hashed" jdbcType="BIGINT" property="pagesHashed" />
    <result column="pages_old" jdbcType="BIGINT" property="pagesOld" />
    <result column="rows_cached" jdbcType="DECIMAL" property="rowsCached" />
    <result column="object_schema" jdbcType="LONGVARCHAR" property="objectSchema" />
    <result column="allocated" jdbcType="LONGVARCHAR" property="allocated" />
    <result column="data" jdbcType="LONGVARCHAR" property="data" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into innodb_buffer_stats_by_schema (pages, pages_hashed, pages_old, 
      rows_cached, object_schema, allocated, 
      data)
    values (#{pages,jdbcType=BIGINT}, #{pagesHashed,jdbcType=BIGINT}, #{pagesOld,jdbcType=BIGINT}, 
      #{rowsCached,jdbcType=DECIMAL}, #{objectSchema,jdbcType=LONGVARCHAR}, #{allocated,jdbcType=LONGVARCHAR}, 
      #{data,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select pages, pages_hashed, pages_old, rows_cached, object_schema, allocated, data
    from innodb_buffer_stats_by_schema
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="page_size" jdbcType="INTEGER" property="pageSize" />
    <result column="compress_ops" jdbcType="INTEGER" property="compressOps" />
    <result column="compress_ops_ok" jdbcType="INTEGER" property="compressOpsOk" />
    <result column="compress_time" jdbcType="INTEGER" property="compressTime" />
    <result column="uncompress_ops" jdbcType="INTEGER" property="uncompressOps" />
    <result column="uncompress_time" jdbcType="INTEGER" property="uncompressTime" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_CMP (page_size, compress_ops, compress_ops_ok, 
      compress_time, uncompress_ops, uncompress_time
      )
    values (#{pageSize,jdbcType=INTEGER}, #{compressOps,jdbcType=INTEGER}, #{compressOpsOk,jdbcType=INTEGER}, 
      #{compressTime,jdbcType=INTEGER}, #{uncompressOps,jdbcType=INTEGER}, #{uncompressTime,jdbcType=INTEGER}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select page_size, compress_ops, compress_ops_ok, compress_time, uncompress_ops, uncompress_time
    from INNODB_CMP
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="UDF_NAME" jdbcType="VARCHAR" property="udfName" />
    <result column="UDF_RETURN_TYPE" jdbcType="VARCHAR" property="udfReturnType" />
    <result column="UDF_TYPE" jdbcType="VARCHAR" property="udfType" />
    <result column="UDF_LIBRARY" jdbcType="VARCHAR" property="udfLibrary" />
    <result column="UDF_USAGE_COUNT" jdbcType="BIGINT" property="udfUsageCount" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from user_defined_functions
    where UDF_NAME = #{udfName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into user_defined_functions (UDF_NAME, UDF_RETURN_TYPE, UDF_TYPE, 
      UDF_LIBRARY, UDF_USAGE_COUNT)
    values (#{udfName,jdbcType=VARCHAR}, #{udfReturnType,jdbcType=VARCHAR}, #{udfType,jdbcType=VARCHAR}, 
      #{udfLibrary,jdbcType=VARCHAR}, #{udfUsageCount,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update user_defined_functions
    set UDF_RETURN_TYPE = #{udfReturnType,jdbcType=VARCHAR},
      UDF_TYPE = #{udfType,jdbcType=VARCHAR},
      UDF_LIBRARY = #{udfLibrary,jdbcType=VARCHAR},
      UDF_USAGE_COUNT = #{udfUsageCount,jdbcType=BIGINT}
    where UDF_NAME = #{udfName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select UDF_NAME, UDF_RETURN_TYPE, UDF_TYPE, UDF_LIBRARY, UDF_USAGE_COUNT
    from user_defined_functions
    where UDF_NAME = #{udfName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select UDF_NAME, UDF_RETURN_TYPE, UDF_TYPE, UDF_LIBRARY, UDF_USAGE_COUNT
    from user_defined_functions
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="help_category_id" jdbcType="SMALLINT" property="helpCategoryId" />
    <result column="name" jdbcType="CHAR" property="name" />
    <result column="parent_category_id" jdbcType="SMALLINT" property="parentCategoryId" />
    <result column="url" jdbcType="LONGVARCHAR" property="url" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Short">
    delete from help_category
    where help_category_id = #{helpCategoryId,jdbcType=SMALLINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into help_category (help_category_id, name, parent_category_id, 
      url)
    values (#{helpCategoryId,jdbcType=SMALLINT}, #{name,jdbcType=CHAR}, #{parentCategoryId,jdbcType=SMALLINT}, 
      #{url,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update help_category
    set name = #{name,jdbcType=CHAR},
      parent_category_id = #{parentCategoryId,jdbcType=SMALLINT},
      url = #{url,jdbcType=LONGVARCHAR}
    where help_category_id = #{helpCategoryId,jdbcType=SMALLINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Short" resultMap="BaseResultMap">
    select help_category_id, name, parent_category_id, url
    from help_category
    where help_category_id = #{helpCategoryId,jdbcType=SMALLINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select help_category_id, name, parent_category_id, url
    from help_category
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="id" jdbcType="INTEGER" property="id" />
    <result column="name" jdbcType="VARCHAR" property="name" />
    <result column="dep_id" jdbcType="INTEGER" property="depId" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from company
    where id = #{id,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into company (name, dep_id)
    values (#{name,jdbcType=VARCHAR}, #{depId,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update company
    set name = #{name,jdbcType=VARCHAR},
      dep_id = #{depId,jdbcType=INTEGER}
    where id = #{id,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select id, name, dep_id
    from company
    where id = #{id,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select id, name, dep_id
    from company
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="TIMER_NAME" jdbcType="CHAR" property="timerName" />
    <result column="TIMER_FREQUENCY" jdbcType="BIGINT" property="timerFrequency" />
    <result column="TIMER_RESOLUTION" jdbcType="BIGINT" property="timerResolution" />
    <result column="TIMER_OVERHEAD" jdbcType="BIGINT" property="timerOverhead" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into performance_timers (TIMER_NAME, TIMER_FREQUENCY, TIMER_RESOLUTION, 
      TIMER_OVERHEAD)
    values (#{timerName,jdbcType=CHAR}, #{timerFrequency,jdbcType=BIGINT}, #{timerResolution,jdbcType=BIGINT}, 
      #{timerOverhead,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select TIMER_NAME, TIMER_FREQUENCY, TIMER_RESOLUTION, TIMER_OVERHEAD
    from performance_timers
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="imgid" jdbcType="BIGINT" property="imgid" />
    <result column="name" jdbcType="VARCHAR" property="name" />
    <result column="url" jdbcType="VARCHAR" property="url" />
    <result column="version" jdbcType="VARCHAR" property="version" />
    <result column="auth" jdbcType="INTEGER" property="auth" />
    <result column="status" jdbcType="INTEGER" property="status" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from imgurl
    where imgid = #{imgid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into imgurl (imgid, name, url, 
      version, auth, status
      )
    values (#{imgid,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{url,jdbcType=VARCHAR}, 
      #{version,jdbcType=VARCHAR}, #{auth,jdbcType=INTEGER}, #{status,jdbcType=INTEGER}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update imgurl
    set name = #{name,jdbcType=VARCHAR},
      url = #{url,jdbcType=VARCHAR},
      version = #{version,jdbcType=VARCHAR},
      auth = #{auth,jdbcType=INTEGER},
      status = #{status,jdbcType=INTEGER}
    where imgid = #{imgid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select imgid, name, url, version, auth, status
    from imgurl
    where imgid = #{imgid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select imgid, name, url, version, auth, status
    from imgurl
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="TABLE_ID" jdbcType="BIGINT" property="tableId" />
    <result column="POS" jdbcType="INTEGER" property="pos" />
    <result column="BASE_POS" jdbcType="INTEGER" property="basePos" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_VIRTUAL (TABLE_ID, POS, BASE_POS
      )
    values (#{tableId,jdbcType=BIGINT}, #{pos,jdbcType=INTEGER}, #{basePos,jdbcType=INTEGER}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select TABLE_ID, POS, BASE_POS
    from INNODB_VIRTUAL
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="INDEX_ID" jdbcType="BIGINT" property="indexId" />
    <result column="NAME" jdbcType="VARCHAR" property="name" />
    <result column="TABLE_ID" jdbcType="BIGINT" property="tableId" />
    <result column="TYPE" jdbcType="INTEGER" property="type" />
    <result column="N_FIELDS" jdbcType="INTEGER" property="nFields" />
    <result column="PAGE_NO" jdbcType="INTEGER" property="pageNo" />
    <result column="SPACE" jdbcType="INTEGER" property="space" />
    <result column="MERGE_THRESHOLD" jdbcType="INTEGER" property="mergeThreshold" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_INDEXES (INDEX_ID, NAME, TABLE_ID, 
      TYPE, N_FIELDS, PAGE_NO, 
      SPACE, MERGE_THRESHOLD)
    values (#{indexId,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{tableId,jdbcType=BIGINT}, 
      #{type,jdbcType=INTEGER}, #{nFields,jdbcType=INTEGER}, #{pageNo,jdbcType=INTEGER}, 
      #{space,jdbcType=INTEGER}, #{mergeThreshold,jdbcType=INTEGER})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select INDEX_ID, NAME, TABLE_ID, TYPE, N_FIELDS, PAGE_NO, SPACE, MERGE_THRESHOLD
    from INNODB_INDEXES
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="id" jdbcType="INTEGER" property="id" />
    <result column="name" jdbcType="VARCHAR" property="name" />
    <result column="uid" jdbcType="INTEGER" property="uid" />
    <result column="pid" jdbcType="INTEGER" property="pid" />
    <result column="sid" jdbcType="INTEGER" property="sid" />
    <result column="password" jdbcType="VARCHAR" property="password" />
    <result column="area" jdbcType="VARCHAR" property="area" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from init_info
    where id = #{id,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into init_info (name, uid, pid, 
      sid, password, area
      )
    values (#{name,jdbcType=VARCHAR}, #{uid,jdbcType=INTEGER}, #{pid,jdbcType=INTEGER}, 
      #{sid,jdbcType=INTEGER}, #{password,jdbcType=VARCHAR}, #{area,jdbcType=VARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update init_info
    set name = #{name,jdbcType=VARCHAR},
      uid = #{uid,jdbcType=INTEGER},
      pid = #{pid,jdbcType=INTEGER},
      sid = #{sid,jdbcType=INTEGER},
      password = #{password,jdbcType=VARCHAR},
      area = #{area,jdbcType=VARCHAR}
    where id = #{id,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select id, name, uid, pid, sid, password, area
    from init_info
    where id = #{id,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select id, name, uid, pid, sid, password, area
    from init_info
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="current_count_used" jdbcType="DECIMAL" property="currentCountUsed" />
    <result column="current_allocated" jdbcType="DECIMAL" property="currentAllocated" />
    <result column="current_avg_alloc" jdbcType="DECIMAL" property="currentAvgAlloc" />
    <result column="current_max_alloc" jdbcType="BIGINT" property="currentMaxAlloc" />
    <result column="total_allocated" jdbcType="DECIMAL" property="totalAllocated" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$memory_by_user_by_current_bytes (user, current_count_used, current_allocated, 
      current_avg_alloc, current_max_alloc, total_allocated
      )
    values (#{user,jdbcType=VARCHAR}, #{currentCountUsed,jdbcType=DECIMAL}, #{currentAllocated,jdbcType=DECIMAL}, 
      #{currentAvgAlloc,jdbcType=DECIMAL}, #{currentMaxAlloc,jdbcType=BIGINT}, #{totalAllocated,jdbcType=DECIMAL}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, current_count_used, current_allocated, current_avg_alloc, current_max_alloc, 
    total_allocated
    from x$memory_by_user_by_current_bytes
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="mid" jdbcType="BIGINT" property="mid" />
    <result column="title" jdbcType="VARCHAR" property="title" />
    <result column="title2" jdbcType="VARCHAR" property="title2" />
    <result column="formuser" jdbcType="VARCHAR" property="formuser" />
    <result column="touser" jdbcType="VARCHAR" property="touser" />
    <result column="sendname" jdbcType="VARCHAR" property="sendname" />
    <result column="imgurl" jdbcType="VARCHAR" property="imgurl" />
    <result column="createdate" jdbcType="VARCHAR" property="createdate" />
    <result column="status" jdbcType="INTEGER" property="status" />
    <result column="send" jdbcType="LONGVARCHAR" property="send" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from sendmail
    where mid = #{mid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into sendmail (mid, title, title2, 
      formuser, touser, sendname, 
      imgurl, createdate, status, 
      send)
    values (#{mid,jdbcType=BIGINT}, #{title,jdbcType=VARCHAR}, #{title2,jdbcType=VARCHAR}, 
      #{formuser,jdbcType=VARCHAR}, #{touser,jdbcType=VARCHAR}, #{sendname,jdbcType=VARCHAR}, 
      #{imgurl,jdbcType=VARCHAR}, #{createdate,jdbcType=VARCHAR}, #{status,jdbcType=INTEGER}, 
      #{send,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update sendmail
    set title = #{title,jdbcType=VARCHAR},
      title2 = #{title2,jdbcType=VARCHAR},
      formuser = #{formuser,jdbcType=VARCHAR},
      touser = #{touser,jdbcType=VARCHAR},
      sendname = #{sendname,jdbcType=VARCHAR},
      imgurl = #{imgurl,jdbcType=VARCHAR},
      createdate = #{createdate,jdbcType=VARCHAR},
      status = #{status,jdbcType=INTEGER},
      send = #{send,jdbcType=LONGVARCHAR}
    where mid = #{mid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select mid, title, title2, formuser, touser, sendname, imgurl, createdate, status, 
    send
    from sendmail
    where mid = #{mid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select mid, title, title2, formuser, touser, sendname, imgurl, createdate, status, 
    send
    from sendmail
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="table_schema" jdbcType="VARCHAR" property="tableSchema" />
    <result column="table_name" jdbcType="VARCHAR" property="tableName" />
    <result column="rows_fetched" jdbcType="BIGINT" property="rowsFetched" />
    <result column="fetch_latency" jdbcType="BIGINT" property="fetchLatency" />
    <result column="rows_inserted" jdbcType="BIGINT" property="rowsInserted" />
    <result column="insert_latency" jdbcType="BIGINT" property="insertLatency" />
    <result column="rows_updated" jdbcType="BIGINT" property="rowsUpdated" />
    <result column="update_latency" jdbcType="BIGINT" property="updateLatency" />
    <result column="rows_deleted" jdbcType="BIGINT" property="rowsDeleted" />
    <result column="delete_latency" jdbcType="BIGINT" property="deleteLatency" />
    <result column="io_read_requests" jdbcType="DECIMAL" property="ioReadRequests" />
    <result column="io_read" jdbcType="DECIMAL" property="ioRead" />
    <result column="io_read_latency" jdbcType="DECIMAL" property="ioReadLatency" />
    <result column="io_write_requests" jdbcType="DECIMAL" property="ioWriteRequests" />
    <result column="io_write" jdbcType="DECIMAL" property="ioWrite" />
    <result column="io_write_latency" jdbcType="DECIMAL" property="ioWriteLatency" />
    <result column="io_misc_requests" jdbcType="DECIMAL" property="ioMiscRequests" />
    <result column="io_misc_latency" jdbcType="DECIMAL" property="ioMiscLatency" />
    <result column="innodb_buffer_allocated" jdbcType="DECIMAL" property="innodbBufferAllocated" />
    <result column="innodb_buffer_data" jdbcType="DECIMAL" property="innodbBufferData" />
    <result column="innodb_buffer_free" jdbcType="DECIMAL" property="innodbBufferFree" />
    <result column="innodb_buffer_pages" jdbcType="BIGINT" property="innodbBufferPages" />
    <result column="innodb_buffer_pages_hashed" jdbcType="BIGINT" property="innodbBufferPagesHashed" />
    <result column="innodb_buffer_pages_old" jdbcType="BIGINT" property="innodbBufferPagesOld" />
    <result column="innodb_buffer_rows_cached" jdbcType="DECIMAL" property="innodbBufferRowsCached" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$schema_table_statistics_with_buffer (table_schema, table_name, rows_fetched, 
      fetch_latency, rows_inserted, insert_latency, 
      rows_updated, update_latency, rows_deleted, 
      delete_latency, io_read_requests, io_read, 
      io_read_latency, io_write_requests, io_write, 
      io_write_latency, io_misc_requests, io_misc_latency, 
      innodb_buffer_allocated, innodb_buffer_data, 
      innodb_buffer_free, innodb_buffer_pages, innodb_buffer_pages_hashed, 
      innodb_buffer_pages_old, innodb_buffer_rows_cached
      )
    values (#{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, #{rowsFetched,jdbcType=BIGINT}, 
      #{fetchLatency,jdbcType=BIGINT}, #{rowsInserted,jdbcType=BIGINT}, #{insertLatency,jdbcType=BIGINT}, 
      #{rowsUpdated,jdbcType=BIGINT}, #{updateLatency,jdbcType=BIGINT}, #{rowsDeleted,jdbcType=BIGINT}, 
      #{deleteLatency,jdbcType=BIGINT}, #{ioReadRequests,jdbcType=DECIMAL}, #{ioRead,jdbcType=DECIMAL}, 
      #{ioReadLatency,jdbcType=DECIMAL}, #{ioWriteRequests,jdbcType=DECIMAL}, #{ioWrite,jdbcType=DECIMAL}, 
      #{ioWriteLatency,jdbcType=DECIMAL}, #{ioMiscRequests,jdbcType=DECIMAL}, #{ioMiscLatency,jdbcType=DECIMAL}, 
      #{innodbBufferAllocated,jdbcType=DECIMAL}, #{innodbBufferData,jdbcType=DECIMAL}, 
      #{innodbBufferFree,jdbcType=DECIMAL}, #{innodbBufferPages,jdbcType=BIGINT}, #{innodbBufferPagesHashed,jdbcType=BIGINT}, 
      #{innodbBufferPagesOld,jdbcType=BIGINT}, #{innodbBufferRowsCached,jdbcType=DECIMAL}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select table_schema, table_name, rows_fetched, fetch_latency, rows_inserted, insert_latency, 
    rows_updated, update_latency, rows_deleted, delete_latency, io_read_requests, io_read, 
    io_read_latency, io_write_requests, io_write, io_write_latency, io_misc_requests, 
    io_misc_latency, innodb_buffer_allocated, innodb_buffer_data, innodb_buffer_free, 
    innodb_buffer_pages, innodb_buffer_pages_hashed, innodb_buffer_pages_old, innodb_buffer_rows_cached
    from x$schema_table_statistics_with_buffer
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="full_scan" jdbcType="VARCHAR" property="fullScan" />
    <result column="exec_count" jdbcType="BIGINT" property="execCount" />
    <result column="err_count" jdbcType="BIGINT" property="errCount" />
    <result column="warn_count" jdbcType="BIGINT" property="warnCount" />
    <result column="rows_sent" jdbcType="BIGINT" property="rowsSent" />
    <result column="rows_sent_avg" jdbcType="DECIMAL" property="rowsSentAvg" />
    <result column="rows_examined" jdbcType="BIGINT" property="rowsExamined" />
    <result column="rows_examined_avg" jdbcType="DECIMAL" property="rowsExaminedAvg" />
    <result column="first_seen" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="last_seen" jdbcType="TIMESTAMP" property="lastSeen" />
    <result column="digest" jdbcType="VARCHAR" property="digest" />
    <result column="query" jdbcType="LONGVARCHAR" property="query" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
    <result column="avg_latency" jdbcType="LONGVARCHAR" property="avgLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into statements_with_runtimes_in_95th_percentile (db, full_scan, exec_count, 
      err_count, warn_count, rows_sent, 
      rows_sent_avg, rows_examined, rows_examined_avg, 
      first_seen, last_seen, digest, 
      query, total_latency, max_latency, 
      avg_latency)
    values (#{db,jdbcType=VARCHAR}, #{fullScan,jdbcType=VARCHAR}, #{execCount,jdbcType=BIGINT}, 
      #{errCount,jdbcType=BIGINT}, #{warnCount,jdbcType=BIGINT}, #{rowsSent,jdbcType=BIGINT}, 
      #{rowsSentAvg,jdbcType=DECIMAL}, #{rowsExamined,jdbcType=BIGINT}, #{rowsExaminedAvg,jdbcType=DECIMAL}, 
      #{firstSeen,jdbcType=TIMESTAMP}, #{lastSeen,jdbcType=TIMESTAMP}, #{digest,jdbcType=VARCHAR}, 
      #{query,jdbcType=LONGVARCHAR}, #{totalLatency,jdbcType=LONGVARCHAR}, #{maxLatency,jdbcType=LONGVARCHAR}, 
      #{avgLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select db, full_scan, exec_count, err_count, warn_count, rows_sent, rows_sent_avg, 
    rows_examined, rows_examined_avg, first_seen, last_seen, digest, query, total_latency, 
    max_latency, avg_latency
    from statements_with_runtimes_in_95th_percentile
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="COUNT_READ_WRITE" jdbcType="BIGINT" property="countReadWrite" />
    <result column="SUM_TIMER_READ_WRITE" jdbcType="BIGINT" property="sumTimerReadWrite" />
    <result column="MIN_TIMER_READ_WRITE" jdbcType="BIGINT" property="minTimerReadWrite" />
    <result column="AVG_TIMER_READ_WRITE" jdbcType="BIGINT" property="avgTimerReadWrite" />
    <result column="MAX_TIMER_READ_WRITE" jdbcType="BIGINT" property="maxTimerReadWrite" />
    <result column="COUNT_READ_ONLY" jdbcType="BIGINT" property="countReadOnly" />
    <result column="SUM_TIMER_READ_ONLY" jdbcType="BIGINT" property="sumTimerReadOnly" />
    <result column="MIN_TIMER_READ_ONLY" jdbcType="BIGINT" property="minTimerReadOnly" />
    <result column="AVG_TIMER_READ_ONLY" jdbcType="BIGINT" property="avgTimerReadOnly" />
    <result column="MAX_TIMER_READ_ONLY" jdbcType="BIGINT" property="maxTimerReadOnly" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_transactions_summary_by_account_by_event_name (USER, HOST, EVENT_NAME, 
      COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
      AVG_TIMER_WAIT, MAX_TIMER_WAIT, COUNT_READ_WRITE, 
      SUM_TIMER_READ_WRITE, MIN_TIMER_READ_WRITE, AVG_TIMER_READ_WRITE, 
      MAX_TIMER_READ_WRITE, COUNT_READ_ONLY, SUM_TIMER_READ_ONLY, 
      MIN_TIMER_READ_ONLY, AVG_TIMER_READ_ONLY, MAX_TIMER_READ_ONLY
      )
    values (#{user,jdbcType=CHAR}, #{host,jdbcType=CHAR}, #{eventName,jdbcType=VARCHAR}, 
      #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, 
      #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT}, #{countReadWrite,jdbcType=BIGINT}, 
      #{sumTimerReadWrite,jdbcType=BIGINT}, #{minTimerReadWrite,jdbcType=BIGINT}, #{avgTimerReadWrite,jdbcType=BIGINT}, 
      #{maxTimerReadWrite,jdbcType=BIGINT}, #{countReadOnly,jdbcType=BIGINT}, #{sumTimerReadOnly,jdbcType=BIGINT}, 
      #{minTimerReadOnly,jdbcType=BIGINT}, #{avgTimerReadOnly,jdbcType=BIGINT}, #{maxTimerReadOnly,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, HOST, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT, COUNT_READ_WRITE, SUM_TIMER_READ_WRITE, MIN_TIMER_READ_WRITE, AVG_TIMER_READ_WRITE, 
    MAX_TIMER_READ_WRITE, COUNT_READ_ONLY, SUM_TIMER_READ_ONLY, MIN_TIMER_READ_ONLY, 
    AVG_TIMER_READ_ONLY, MAX_TIMER_READ_ONLY
    from events_transactions_summary_by_account_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from events_stages_summary_global_by_event_name
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_stages_summary_global_by_event_name (EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, 
      MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT
      )
    values (#{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, 
      #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_stages_summary_global_by_event_name
    set COUNT_STAR = #{countStar,jdbcType=BIGINT},
      SUM_TIMER_WAIT = #{sumTimerWait,jdbcType=BIGINT},
      MIN_TIMER_WAIT = #{minTimerWait,jdbcType=BIGINT},
      AVG_TIMER_WAIT = #{avgTimerWait,jdbcType=BIGINT},
      MAX_TIMER_WAIT = #{maxTimerWait,jdbcType=BIGINT}
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT
    from events_stages_summary_global_by_event_name
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT
    from events_stages_summary_global_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="cid" jdbcType="INTEGER" property="cid" />
    <result column="type_name" jdbcType="VARCHAR" property="typeName" />
    <result column="price" jdbcType="INTEGER" property="price" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from carinfo
    where cid = #{cid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into carinfo (cid, type_name, price
      )
    values (#{cid,jdbcType=INTEGER}, #{typeName,jdbcType=VARCHAR}, #{price,jdbcType=INTEGER}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update carinfo
    set type_name = #{typeName,jdbcType=VARCHAR},
      price = #{price,jdbcType=INTEGER}
    where cid = #{cid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select cid, type_name, price
    from carinfo
    where cid = #{cid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select cid, type_name, price
    from carinfo
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="current_count_used" jdbcType="DECIMAL" property="currentCountUsed" />
    <result column="current_allocated" jdbcType="DECIMAL" property="currentAllocated" />
    <result column="current_avg_alloc" jdbcType="DECIMAL" property="currentAvgAlloc" />
    <result column="current_max_alloc" jdbcType="BIGINT" property="currentMaxAlloc" />
    <result column="total_allocated" jdbcType="DECIMAL" property="totalAllocated" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$memory_by_host_by_current_bytes (host, current_count_used, current_allocated, 
      current_avg_alloc, current_max_alloc, total_allocated
      )
    values (#{host,jdbcType=VARCHAR}, #{currentCountUsed,jdbcType=DECIMAL}, #{currentAllocated,jdbcType=DECIMAL}, 
      #{currentAvgAlloc,jdbcType=DECIMAL}, #{currentMaxAlloc,jdbcType=BIGINT}, #{totalAllocated,jdbcType=DECIMAL}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, current_count_used, current_allocated, current_avg_alloc, current_max_alloc, 
    total_allocated
    from x$memory_by_host_by_current_bytes
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="sys_version" jdbcType="VARCHAR" property="sysVersion" />
    <result column="mysql_version" jdbcType="VARCHAR" property="mysqlVersion" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into version (sys_version, mysql_version)
    values (#{sysVersion,jdbcType=VARCHAR}, #{mysqlVersion,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select sys_version, mysql_version
    from version
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="variable" jdbcType="VARCHAR" property="variable" />
    <result column="value" jdbcType="VARCHAR" property="value" />
    <result column="set_time" jdbcType="TIMESTAMP" property="setTime" />
    <result column="set_by" jdbcType="VARCHAR" property="setBy" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from sys_config
    where variable = #{variable,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into sys_config (variable, value, set_time, 
      set_by)
    values (#{variable,jdbcType=VARCHAR}, #{value,jdbcType=VARCHAR}, #{setTime,jdbcType=TIMESTAMP}, 
      #{setBy,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update sys_config
    set value = #{value,jdbcType=VARCHAR},
      set_time = #{setTime,jdbcType=TIMESTAMP},
      set_by = #{setBy,jdbcType=VARCHAR}
    where variable = #{variable,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select variable, value, set_time, set_by
    from sys_config
    where variable = #{variable,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select variable, value, set_time, set_by
    from sys_config
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Time_zone_id" jdbcType="INTEGER" property="timeZoneId" />
    <id column="Transition_type_id" jdbcType="INTEGER" property="transitionTypeId" />
    <result column="Offset" jdbcType="INTEGER" property="offset" />
    <result column="Is_DST" jdbcType="TINYINT" property="isDst" />
    <result column="Abbreviation" jdbcType="CHAR" property="abbreviation" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from time_zone_transition_type
    where Time_zone_id = #{timeZoneId,jdbcType=INTEGER}
      and Transition_type_id = #{transitionTypeId,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into time_zone_transition_type (Time_zone_id, Transition_type_id, Offset, 
      Is_DST, Abbreviation)
    values (#{timeZoneId,jdbcType=INTEGER}, #{transitionTypeId,jdbcType=INTEGER}, #{offset,jdbcType=INTEGER}, 
      #{isDst,jdbcType=TINYINT}, #{abbreviation,jdbcType=CHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update time_zone_transition_type
    set Offset = #{offset,jdbcType=INTEGER},
      Is_DST = #{isDst,jdbcType=TINYINT},
      Abbreviation = #{abbreviation,jdbcType=CHAR}
    where Time_zone_id = #{timeZoneId,jdbcType=INTEGER}
      and Transition_type_id = #{transitionTypeId,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select Time_zone_id, Transition_type_id, Offset, Is_DST, Abbreviation
    from time_zone_transition_type
    where Time_zone_id = #{timeZoneId,jdbcType=INTEGER}
      and Transition_type_id = #{transitionTypeId,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Time_zone_id, Transition_type_id, Offset, Is_DST, Abbreviation
    from time_zone_transition_type
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="cid" jdbcType="INTEGER" property="cid" />
    <id column="mid" jdbcType="INTEGER" property="mid" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from t_relationships
    where cid = #{cid,jdbcType=INTEGER}
      and mid = #{mid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into t_relationships (cid, mid)
    values (#{cid,jdbcType=INTEGER}, #{mid,jdbcType=INTEGER})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select cid, mid
    from t_relationships
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="OBJECT_TYPE" jdbcType="CHAR" property="objectType" />
    <id column="OBJECT_SCHEMA" jdbcType="VARCHAR" property="objectSchema" />
    <id column="OBJECT_NAME" jdbcType="VARCHAR" property="objectName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="COUNT_STATEMENTS" jdbcType="BIGINT" property="countStatements" />
    <result column="SUM_STATEMENTS_WAIT" jdbcType="BIGINT" property="sumStatementsWait" />
    <result column="MIN_STATEMENTS_WAIT" jdbcType="BIGINT" property="minStatementsWait" />
    <result column="AVG_STATEMENTS_WAIT" jdbcType="BIGINT" property="avgStatementsWait" />
    <result column="MAX_STATEMENTS_WAIT" jdbcType="BIGINT" property="maxStatementsWait" />
    <result column="SUM_LOCK_TIME" jdbcType="BIGINT" property="sumLockTime" />
    <result column="SUM_ERRORS" jdbcType="BIGINT" property="sumErrors" />
    <result column="SUM_WARNINGS" jdbcType="BIGINT" property="sumWarnings" />
    <result column="SUM_ROWS_AFFECTED" jdbcType="BIGINT" property="sumRowsAffected" />
    <result column="SUM_ROWS_SENT" jdbcType="BIGINT" property="sumRowsSent" />
    <result column="SUM_ROWS_EXAMINED" jdbcType="BIGINT" property="sumRowsExamined" />
    <result column="SUM_CREATED_TMP_DISK_TABLES" jdbcType="BIGINT" property="sumCreatedTmpDiskTables" />
    <result column="SUM_CREATED_TMP_TABLES" jdbcType="BIGINT" property="sumCreatedTmpTables" />
    <result column="SUM_SELECT_FULL_JOIN" jdbcType="BIGINT" property="sumSelectFullJoin" />
    <result column="SUM_SELECT_FULL_RANGE_JOIN" jdbcType="BIGINT" property="sumSelectFullRangeJoin" />
    <result column="SUM_SELECT_RANGE" jdbcType="BIGINT" property="sumSelectRange" />
    <result column="SUM_SELECT_RANGE_CHECK" jdbcType="BIGINT" property="sumSelectRangeCheck" />
    <result column="SUM_SELECT_SCAN" jdbcType="BIGINT" property="sumSelectScan" />
    <result column="SUM_SORT_MERGE_PASSES" jdbcType="BIGINT" property="sumSortMergePasses" />
    <result column="SUM_SORT_RANGE" jdbcType="BIGINT" property="sumSortRange" />
    <result column="SUM_SORT_ROWS" jdbcType="BIGINT" property="sumSortRows" />
    <result column="SUM_SORT_SCAN" jdbcType="BIGINT" property="sumSortScan" />
    <result column="SUM_NO_INDEX_USED" jdbcType="BIGINT" property="sumNoIndexUsed" />
    <result column="SUM_NO_GOOD_INDEX_USED" jdbcType="BIGINT" property="sumNoGoodIndexUsed" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from events_statements_summary_by_program
    where OBJECT_TYPE = #{objectType,jdbcType=CHAR}
      and OBJECT_SCHEMA = #{objectSchema,jdbcType=VARCHAR}
      and OBJECT_NAME = #{objectName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_statements_summary_by_program (OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, 
      COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
      AVG_TIMER_WAIT, MAX_TIMER_WAIT, COUNT_STATEMENTS, 
      SUM_STATEMENTS_WAIT, MIN_STATEMENTS_WAIT, AVG_STATEMENTS_WAIT, 
      MAX_STATEMENTS_WAIT, SUM_LOCK_TIME, SUM_ERRORS, 
      SUM_WARNINGS, SUM_ROWS_AFFECTED, SUM_ROWS_SENT, 
      SUM_ROWS_EXAMINED, SUM_CREATED_TMP_DISK_TABLES, 
      SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, SUM_SELECT_FULL_RANGE_JOIN, 
      SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, 
      SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, 
      SUM_SORT_SCAN, SUM_NO_INDEX_USED, SUM_NO_GOOD_INDEX_USED
      )
    values (#{objectType,jdbcType=CHAR}, #{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, 
      #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, 
      #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT}, #{countStatements,jdbcType=BIGINT}, 
      #{sumStatementsWait,jdbcType=BIGINT}, #{minStatementsWait,jdbcType=BIGINT}, #{avgStatementsWait,jdbcType=BIGINT}, 
      #{maxStatementsWait,jdbcType=BIGINT}, #{sumLockTime,jdbcType=BIGINT}, #{sumErrors,jdbcType=BIGINT}, 
      #{sumWarnings,jdbcType=BIGINT}, #{sumRowsAffected,jdbcType=BIGINT}, #{sumRowsSent,jdbcType=BIGINT}, 
      #{sumRowsExamined,jdbcType=BIGINT}, #{sumCreatedTmpDiskTables,jdbcType=BIGINT}, 
      #{sumCreatedTmpTables,jdbcType=BIGINT}, #{sumSelectFullJoin,jdbcType=BIGINT}, #{sumSelectFullRangeJoin,jdbcType=BIGINT}, 
      #{sumSelectRange,jdbcType=BIGINT}, #{sumSelectRangeCheck,jdbcType=BIGINT}, #{sumSelectScan,jdbcType=BIGINT}, 
      #{sumSortMergePasses,jdbcType=BIGINT}, #{sumSortRange,jdbcType=BIGINT}, #{sumSortRows,jdbcType=BIGINT}, 
      #{sumSortScan,jdbcType=BIGINT}, #{sumNoIndexUsed,jdbcType=BIGINT}, #{sumNoGoodIndexUsed,jdbcType=BIGINT}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_statements_summary_by_program
    set COUNT_STAR = #{countStar,jdbcType=BIGINT},
      SUM_TIMER_WAIT = #{sumTimerWait,jdbcType=BIGINT},
      MIN_TIMER_WAIT = #{minTimerWait,jdbcType=BIGINT},
      AVG_TIMER_WAIT = #{avgTimerWait,jdbcType=BIGINT},
      MAX_TIMER_WAIT = #{maxTimerWait,jdbcType=BIGINT},
      COUNT_STATEMENTS = #{countStatements,jdbcType=BIGINT},
      SUM_STATEMENTS_WAIT = #{sumStatementsWait,jdbcType=BIGINT},
      MIN_STATEMENTS_WAIT = #{minStatementsWait,jdbcType=BIGINT},
      AVG_STATEMENTS_WAIT = #{avgStatementsWait,jdbcType=BIGINT},
      MAX_STATEMENTS_WAIT = #{maxStatementsWait,jdbcType=BIGINT},
      SUM_LOCK_TIME = #{sumLockTime,jdbcType=BIGINT},
      SUM_ERRORS = #{sumErrors,jdbcType=BIGINT},
      SUM_WARNINGS = #{sumWarnings,jdbcType=BIGINT},
      SUM_ROWS_AFFECTED = #{sumRowsAffected,jdbcType=BIGINT},
      SUM_ROWS_SENT = #{sumRowsSent,jdbcType=BIGINT},
      SUM_ROWS_EXAMINED = #{sumRowsExamined,jdbcType=BIGINT},
      SUM_CREATED_TMP_DISK_TABLES = #{sumCreatedTmpDiskTables,jdbcType=BIGINT},
      SUM_CREATED_TMP_TABLES = #{sumCreatedTmpTables,jdbcType=BIGINT},
      SUM_SELECT_FULL_JOIN = #{sumSelectFullJoin,jdbcType=BIGINT},
      SUM_SELECT_FULL_RANGE_JOIN = #{sumSelectFullRangeJoin,jdbcType=BIGINT},
      SUM_SELECT_RANGE = #{sumSelectRange,jdbcType=BIGINT},
      SUM_SELECT_RANGE_CHECK = #{sumSelectRangeCheck,jdbcType=BIGINT},
      SUM_SELECT_SCAN = #{sumSelectScan,jdbcType=BIGINT},
      SUM_SORT_MERGE_PASSES = #{sumSortMergePasses,jdbcType=BIGINT},
      SUM_SORT_RANGE = #{sumSortRange,jdbcType=BIGINT},
      SUM_SORT_ROWS = #{sumSortRows,jdbcType=BIGINT},
      SUM_SORT_SCAN = #{sumSortScan,jdbcType=BIGINT},
      SUM_NO_INDEX_USED = #{sumNoIndexUsed,jdbcType=BIGINT},
      SUM_NO_GOOD_INDEX_USED = #{sumNoGoodIndexUsed,jdbcType=BIGINT}
    where OBJECT_TYPE = #{objectType,jdbcType=CHAR}
      and OBJECT_SCHEMA = #{objectSchema,jdbcType=VARCHAR}
      and OBJECT_NAME = #{objectName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
    AVG_TIMER_WAIT, MAX_TIMER_WAIT, COUNT_STATEMENTS, SUM_STATEMENTS_WAIT, MIN_STATEMENTS_WAIT, 
    AVG_STATEMENTS_WAIT, MAX_STATEMENTS_WAIT, SUM_LOCK_TIME, SUM_ERRORS, SUM_WARNINGS, 
    SUM_ROWS_AFFECTED, SUM_ROWS_SENT, SUM_ROWS_EXAMINED, SUM_CREATED_TMP_DISK_TABLES, 
    SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, SUM_SELECT_FULL_RANGE_JOIN, SUM_SELECT_RANGE, 
    SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, 
    SUM_SORT_SCAN, SUM_NO_INDEX_USED, SUM_NO_GOOD_INDEX_USED
    from events_statements_summary_by_program
    where OBJECT_TYPE = #{objectType,jdbcType=CHAR}
      and OBJECT_SCHEMA = #{objectSchema,jdbcType=VARCHAR}
      and OBJECT_NAME = #{objectName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
    AVG_TIMER_WAIT, MAX_TIMER_WAIT, COUNT_STATEMENTS, SUM_STATEMENTS_WAIT, MIN_STATEMENTS_WAIT, 
    AVG_STATEMENTS_WAIT, MAX_STATEMENTS_WAIT, SUM_LOCK_TIME, SUM_ERRORS, SUM_WARNINGS, 
    SUM_ROWS_AFFECTED, SUM_ROWS_SENT, SUM_ROWS_EXAMINED, SUM_CREATED_TMP_DISK_TABLES, 
    SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, SUM_SELECT_FULL_RANGE_JOIN, SUM_SELECT_RANGE, 
    SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, 
    SUM_SORT_SCAN, SUM_NO_INDEX_USED, SUM_NO_GOOD_INDEX_USED
    from events_statements_summary_by_program
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="page_size" jdbcType="INTEGER" property="pageSize" />
    <result column="compress_ops" jdbcType="INTEGER" property="compressOps" />
    <result column="compress_ops_ok" jdbcType="INTEGER" property="compressOpsOk" />
    <result column="compress_time" jdbcType="INTEGER" property="compressTime" />
    <result column="uncompress_ops" jdbcType="INTEGER" property="uncompressOps" />
    <result column="uncompress_time" jdbcType="INTEGER" property="uncompressTime" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_CMP_RESET (page_size, compress_ops, compress_ops_ok, 
      compress_time, uncompress_ops, uncompress_time
      )
    values (#{pageSize,jdbcType=INTEGER}, #{compressOps,jdbcType=INTEGER}, #{compressOpsOk,jdbcType=INTEGER}, 
      #{compressTime,jdbcType=INTEGER}, #{uncompressOps,jdbcType=INTEGER}, #{uncompressTime,jdbcType=INTEGER}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select page_size, compress_ops, compress_ops_ok, compress_time, uncompress_ops, uncompress_time
    from INNODB_CMP_RESET
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="pages" jdbcType="BIGINT" property="pages" />
    <result column="pages_hashed" jdbcType="BIGINT" property="pagesHashed" />
    <result column="pages_old" jdbcType="BIGINT" property="pagesOld" />
    <result column="rows_cached" jdbcType="DECIMAL" property="rowsCached" />
    <result column="object_schema" jdbcType="LONGVARCHAR" property="objectSchema" />
    <result column="object_name" jdbcType="LONGVARCHAR" property="objectName" />
    <result column="allocated" jdbcType="LONGVARCHAR" property="allocated" />
    <result column="data" jdbcType="LONGVARCHAR" property="data" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into innodb_buffer_stats_by_table (pages, pages_hashed, pages_old, 
      rows_cached, object_schema, object_name, 
      allocated, data)
    values (#{pages,jdbcType=BIGINT}, #{pagesHashed,jdbcType=BIGINT}, #{pagesOld,jdbcType=BIGINT}, 
      #{rowsCached,jdbcType=DECIMAL}, #{objectSchema,jdbcType=LONGVARCHAR}, #{objectName,jdbcType=LONGVARCHAR}, 
      #{allocated,jdbcType=LONGVARCHAR}, #{data,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select pages, pages_hashed, pages_old, rows_cached, object_schema, object_name, allocated, 
    data
    from innodb_buffer_stats_by_table
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="POOL_ID" jdbcType="BIGINT" property="poolId" />
    <result column="POOL_SIZE" jdbcType="BIGINT" property="poolSize" />
    <result column="FREE_BUFFERS" jdbcType="BIGINT" property="freeBuffers" />
    <result column="DATABASE_PAGES" jdbcType="BIGINT" property="databasePages" />
    <result column="OLD_DATABASE_PAGES" jdbcType="BIGINT" property="oldDatabasePages" />
    <result column="MODIFIED_DATABASE_PAGES" jdbcType="BIGINT" property="modifiedDatabasePages" />
    <result column="PENDING_DECOMPRESS" jdbcType="BIGINT" property="pendingDecompress" />
    <result column="PENDING_READS" jdbcType="BIGINT" property="pendingReads" />
    <result column="PENDING_FLUSH_LRU" jdbcType="BIGINT" property="pendingFlushLru" />
    <result column="PENDING_FLUSH_LIST" jdbcType="BIGINT" property="pendingFlushList" />
    <result column="PAGES_MADE_YOUNG" jdbcType="BIGINT" property="pagesMadeYoung" />
    <result column="PAGES_NOT_MADE_YOUNG" jdbcType="BIGINT" property="pagesNotMadeYoung" />
    <result column="PAGES_MADE_YOUNG_RATE" jdbcType="REAL" property="pagesMadeYoungRate" />
    <result column="PAGES_MADE_NOT_YOUNG_RATE" jdbcType="REAL" property="pagesMadeNotYoungRate" />
    <result column="NUMBER_PAGES_READ" jdbcType="BIGINT" property="numberPagesRead" />
    <result column="NUMBER_PAGES_CREATED" jdbcType="BIGINT" property="numberPagesCreated" />
    <result column="NUMBER_PAGES_WRITTEN" jdbcType="BIGINT" property="numberPagesWritten" />
    <result column="PAGES_READ_RATE" jdbcType="REAL" property="pagesReadRate" />
    <result column="PAGES_CREATE_RATE" jdbcType="REAL" property="pagesCreateRate" />
    <result column="PAGES_WRITTEN_RATE" jdbcType="REAL" property="pagesWrittenRate" />
    <result column="NUMBER_PAGES_GET" jdbcType="BIGINT" property="numberPagesGet" />
    <result column="HIT_RATE" jdbcType="BIGINT" property="hitRate" />
    <result column="YOUNG_MAKE_PER_THOUSAND_GETS" jdbcType="BIGINT" property="youngMakePerThousandGets" />
    <result column="NOT_YOUNG_MAKE_PER_THOUSAND_GETS" jdbcType="BIGINT" property="notYoungMakePerThousandGets" />
    <result column="NUMBER_PAGES_READ_AHEAD" jdbcType="BIGINT" property="numberPagesReadAhead" />
    <result column="NUMBER_READ_AHEAD_EVICTED" jdbcType="BIGINT" property="numberReadAheadEvicted" />
    <result column="READ_AHEAD_RATE" jdbcType="REAL" property="readAheadRate" />
    <result column="READ_AHEAD_EVICTED_RATE" jdbcType="REAL" property="readAheadEvictedRate" />
    <result column="LRU_IO_TOTAL" jdbcType="BIGINT" property="lruIoTotal" />
    <result column="LRU_IO_CURRENT" jdbcType="BIGINT" property="lruIoCurrent" />
    <result column="UNCOMPRESS_TOTAL" jdbcType="BIGINT" property="uncompressTotal" />
    <result column="UNCOMPRESS_CURRENT" jdbcType="BIGINT" property="uncompressCurrent" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_BUFFER_POOL_STATS (POOL_ID, POOL_SIZE, FREE_BUFFERS, 
      DATABASE_PAGES, OLD_DATABASE_PAGES, MODIFIED_DATABASE_PAGES, 
      PENDING_DECOMPRESS, PENDING_READS, PENDING_FLUSH_LRU, 
      PENDING_FLUSH_LIST, PAGES_MADE_YOUNG, PAGES_NOT_MADE_YOUNG, 
      PAGES_MADE_YOUNG_RATE, PAGES_MADE_NOT_YOUNG_RATE, NUMBER_PAGES_READ, 
      NUMBER_PAGES_CREATED, NUMBER_PAGES_WRITTEN, PAGES_READ_RATE, 
      PAGES_CREATE_RATE, PAGES_WRITTEN_RATE, NUMBER_PAGES_GET, 
      HIT_RATE, YOUNG_MAKE_PER_THOUSAND_GETS, NOT_YOUNG_MAKE_PER_THOUSAND_GETS, 
      NUMBER_PAGES_READ_AHEAD, NUMBER_READ_AHEAD_EVICTED, 
      READ_AHEAD_RATE, READ_AHEAD_EVICTED_RATE, LRU_IO_TOTAL, 
      LRU_IO_CURRENT, UNCOMPRESS_TOTAL, UNCOMPRESS_CURRENT
      )
    values (#{poolId,jdbcType=BIGINT}, #{poolSize,jdbcType=BIGINT}, #{freeBuffers,jdbcType=BIGINT}, 
      #{databasePages,jdbcType=BIGINT}, #{oldDatabasePages,jdbcType=BIGINT}, #{modifiedDatabasePages,jdbcType=BIGINT}, 
      #{pendingDecompress,jdbcType=BIGINT}, #{pendingReads,jdbcType=BIGINT}, #{pendingFlushLru,jdbcType=BIGINT}, 
      #{pendingFlushList,jdbcType=BIGINT}, #{pagesMadeYoung,jdbcType=BIGINT}, #{pagesNotMadeYoung,jdbcType=BIGINT}, 
      #{pagesMadeYoungRate,jdbcType=REAL}, #{pagesMadeNotYoungRate,jdbcType=REAL}, #{numberPagesRead,jdbcType=BIGINT}, 
      #{numberPagesCreated,jdbcType=BIGINT}, #{numberPagesWritten,jdbcType=BIGINT}, #{pagesReadRate,jdbcType=REAL}, 
      #{pagesCreateRate,jdbcType=REAL}, #{pagesWrittenRate,jdbcType=REAL}, #{numberPagesGet,jdbcType=BIGINT}, 
      #{hitRate,jdbcType=BIGINT}, #{youngMakePerThousandGets,jdbcType=BIGINT}, #{notYoungMakePerThousandGets,jdbcType=BIGINT}, 
      #{numberPagesReadAhead,jdbcType=BIGINT}, #{numberReadAheadEvicted,jdbcType=BIGINT}, 
      #{readAheadRate,jdbcType=REAL}, #{readAheadEvictedRate,jdbcType=REAL}, #{lruIoTotal,jdbcType=BIGINT}, 
      #{lruIoCurrent,jdbcType=BIGINT}, #{uncompressTotal,jdbcType=BIGINT}, #{uncompressCurrent,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select POOL_ID, POOL_SIZE, FREE_BUFFERS, DATABASE_PAGES, OLD_DATABASE_PAGES, MODIFIED_DATABASE_PAGES, 
    PENDING_DECOMPRESS, PENDING_READS, PENDING_FLUSH_LRU, PENDING_FLUSH_LIST, PAGES_MADE_YOUNG, 
    PAGES_NOT_MADE_YOUNG, PAGES_MADE_YOUNG_RATE, PAGES_MADE_NOT_YOUNG_RATE, NUMBER_PAGES_READ, 
    NUMBER_PAGES_CREATED, NUMBER_PAGES_WRITTEN, PAGES_READ_RATE, PAGES_CREATE_RATE, PAGES_WRITTEN_RATE, 
    NUMBER_PAGES_GET, HIT_RATE, YOUNG_MAKE_PER_THOUSAND_GETS, NOT_YOUNG_MAKE_PER_THOUSAND_GETS, 
    NUMBER_PAGES_READ_AHEAD, NUMBER_READ_AHEAD_EVICTED, READ_AHEAD_RATE, READ_AHEAD_EVICTED_RATE, 
    LRU_IO_TOTAL, LRU_IO_CURRENT, UNCOMPRESS_TOTAL, UNCOMPRESS_CURRENT
    from INNODB_BUFFER_POOL_STATS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="thread" jdbcType="VARCHAR" property="thread" />
    <result column="file" jdbcType="VARCHAR" property="file" />
    <result column="operation" jdbcType="VARCHAR" property="operation" />
    <result column="latency" jdbcType="LONGVARCHAR" property="latency" />
    <result column="requested" jdbcType="LONGVARCHAR" property="requested" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into latest_file_io (thread, file, operation, 
      latency, requested)
    values (#{thread,jdbcType=VARCHAR}, #{file,jdbcType=VARCHAR}, #{operation,jdbcType=VARCHAR}, 
      #{latency,jdbcType=LONGVARCHAR}, #{requested,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select thread, file, operation, latency, requested
    from latest_file_io
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="event_name" jdbcType="VARCHAR" property="eventName" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into host_summary_by_file_io_type (host, event_name, total, 
      total_latency, max_latency)
    values (#{host,jdbcType=VARCHAR}, #{eventName,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{totalLatency,jdbcType=LONGVARCHAR}, #{maxLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, event_name, total, total_latency, max_latency
    from host_summary_by_file_io_type
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="statements" jdbcType="DECIMAL" property="statements" />
    <result column="statement_latency" jdbcType="DECIMAL" property="statementLatency" />
    <result column="statement_avg_latency" jdbcType="DECIMAL" property="statementAvgLatency" />
    <result column="table_scans" jdbcType="DECIMAL" property="tableScans" />
    <result column="file_ios" jdbcType="DECIMAL" property="fileIos" />
    <result column="file_io_latency" jdbcType="DECIMAL" property="fileIoLatency" />
    <result column="current_connections" jdbcType="DECIMAL" property="currentConnections" />
    <result column="total_connections" jdbcType="DECIMAL" property="totalConnections" />
    <result column="unique_hosts" jdbcType="BIGINT" property="uniqueHosts" />
    <result column="current_memory" jdbcType="DECIMAL" property="currentMemory" />
    <result column="total_memory_allocated" jdbcType="DECIMAL" property="totalMemoryAllocated" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$user_summary (user, statements, statement_latency, 
      statement_avg_latency, table_scans, file_ios, 
      file_io_latency, current_connections, total_connections, 
      unique_hosts, current_memory, total_memory_allocated
      )
    values (#{user,jdbcType=VARCHAR}, #{statements,jdbcType=DECIMAL}, #{statementLatency,jdbcType=DECIMAL}, 
      #{statementAvgLatency,jdbcType=DECIMAL}, #{tableScans,jdbcType=DECIMAL}, #{fileIos,jdbcType=DECIMAL}, 
      #{fileIoLatency,jdbcType=DECIMAL}, #{currentConnections,jdbcType=DECIMAL}, #{totalConnections,jdbcType=DECIMAL}, 
      #{uniqueHosts,jdbcType=BIGINT}, #{currentMemory,jdbcType=DECIMAL}, #{totalMemoryAllocated,jdbcType=DECIMAL}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, statements, statement_latency, statement_avg_latency, table_scans, file_ios, 
    file_io_latency, current_connections, total_connections, unique_hosts, current_memory, 
    total_memory_allocated
    from x$user_summary
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="OBJECT_TYPE" jdbcType="VARCHAR" property="objectType" />
    <result column="OBJECT_SCHEMA" jdbcType="VARCHAR" property="objectSchema" />
    <result column="OBJECT_NAME" jdbcType="VARCHAR" property="objectName" />
    <result column="INDEX_NAME" jdbcType="VARCHAR" property="indexName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="COUNT_READ" jdbcType="BIGINT" property="countRead" />
    <result column="SUM_TIMER_READ" jdbcType="BIGINT" property="sumTimerRead" />
    <result column="MIN_TIMER_READ" jdbcType="BIGINT" property="minTimerRead" />
    <result column="AVG_TIMER_READ" jdbcType="BIGINT" property="avgTimerRead" />
    <result column="MAX_TIMER_READ" jdbcType="BIGINT" property="maxTimerRead" />
    <result column="COUNT_WRITE" jdbcType="BIGINT" property="countWrite" />
    <result column="SUM_TIMER_WRITE" jdbcType="BIGINT" property="sumTimerWrite" />
    <result column="MIN_TIMER_WRITE" jdbcType="BIGINT" property="minTimerWrite" />
    <result column="AVG_TIMER_WRITE" jdbcType="BIGINT" property="avgTimerWrite" />
    <result column="MAX_TIMER_WRITE" jdbcType="BIGINT" property="maxTimerWrite" />
    <result column="COUNT_FETCH" jdbcType="BIGINT" property="countFetch" />
    <result column="SUM_TIMER_FETCH" jdbcType="BIGINT" property="sumTimerFetch" />
    <result column="MIN_TIMER_FETCH" jdbcType="BIGINT" property="minTimerFetch" />
    <result column="AVG_TIMER_FETCH" jdbcType="BIGINT" property="avgTimerFetch" />
    <result column="MAX_TIMER_FETCH" jdbcType="BIGINT" property="maxTimerFetch" />
    <result column="COUNT_INSERT" jdbcType="BIGINT" property="countInsert" />
    <result column="SUM_TIMER_INSERT" jdbcType="BIGINT" property="sumTimerInsert" />
    <result column="MIN_TIMER_INSERT" jdbcType="BIGINT" property="minTimerInsert" />
    <result column="AVG_TIMER_INSERT" jdbcType="BIGINT" property="avgTimerInsert" />
    <result column="MAX_TIMER_INSERT" jdbcType="BIGINT" property="maxTimerInsert" />
    <result column="COUNT_UPDATE" jdbcType="BIGINT" property="countUpdate" />
    <result column="SUM_TIMER_UPDATE" jdbcType="BIGINT" property="sumTimerUpdate" />
    <result column="MIN_TIMER_UPDATE" jdbcType="BIGINT" property="minTimerUpdate" />
    <result column="AVG_TIMER_UPDATE" jdbcType="BIGINT" property="avgTimerUpdate" />
    <result column="MAX_TIMER_UPDATE" jdbcType="BIGINT" property="maxTimerUpdate" />
    <result column="COUNT_DELETE" jdbcType="BIGINT" property="countDelete" />
    <result column="SUM_TIMER_DELETE" jdbcType="BIGINT" property="sumTimerDelete" />
    <result column="MIN_TIMER_DELETE" jdbcType="BIGINT" property="minTimerDelete" />
    <result column="AVG_TIMER_DELETE" jdbcType="BIGINT" property="avgTimerDelete" />
    <result column="MAX_TIMER_DELETE" jdbcType="BIGINT" property="maxTimerDelete" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into table_io_waits_summary_by_index_usage (OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, 
      INDEX_NAME, COUNT_STAR, SUM_TIMER_WAIT, 
      MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, 
      COUNT_READ, SUM_TIMER_READ, MIN_TIMER_READ, 
      AVG_TIMER_READ, MAX_TIMER_READ, COUNT_WRITE, 
      SUM_TIMER_WRITE, MIN_TIMER_WRITE, AVG_TIMER_WRITE, 
      MAX_TIMER_WRITE, COUNT_FETCH, SUM_TIMER_FETCH, 
      MIN_TIMER_FETCH, AVG_TIMER_FETCH, MAX_TIMER_FETCH, 
      COUNT_INSERT, SUM_TIMER_INSERT, MIN_TIMER_INSERT, 
      AVG_TIMER_INSERT, MAX_TIMER_INSERT, COUNT_UPDATE, 
      SUM_TIMER_UPDATE, MIN_TIMER_UPDATE, AVG_TIMER_UPDATE, 
      MAX_TIMER_UPDATE, COUNT_DELETE, SUM_TIMER_DELETE, 
      MIN_TIMER_DELETE, AVG_TIMER_DELETE, MAX_TIMER_DELETE
      )
    values (#{objectType,jdbcType=VARCHAR}, #{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, 
      #{indexName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, 
      #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT}, 
      #{countRead,jdbcType=BIGINT}, #{sumTimerRead,jdbcType=BIGINT}, #{minTimerRead,jdbcType=BIGINT}, 
      #{avgTimerRead,jdbcType=BIGINT}, #{maxTimerRead,jdbcType=BIGINT}, #{countWrite,jdbcType=BIGINT}, 
      #{sumTimerWrite,jdbcType=BIGINT}, #{minTimerWrite,jdbcType=BIGINT}, #{avgTimerWrite,jdbcType=BIGINT}, 
      #{maxTimerWrite,jdbcType=BIGINT}, #{countFetch,jdbcType=BIGINT}, #{sumTimerFetch,jdbcType=BIGINT}, 
      #{minTimerFetch,jdbcType=BIGINT}, #{avgTimerFetch,jdbcType=BIGINT}, #{maxTimerFetch,jdbcType=BIGINT}, 
      #{countInsert,jdbcType=BIGINT}, #{sumTimerInsert,jdbcType=BIGINT}, #{minTimerInsert,jdbcType=BIGINT}, 
      #{avgTimerInsert,jdbcType=BIGINT}, #{maxTimerInsert,jdbcType=BIGINT}, #{countUpdate,jdbcType=BIGINT}, 
      #{sumTimerUpdate,jdbcType=BIGINT}, #{minTimerUpdate,jdbcType=BIGINT}, #{avgTimerUpdate,jdbcType=BIGINT}, 
      #{maxTimerUpdate,jdbcType=BIGINT}, #{countDelete,jdbcType=BIGINT}, #{sumTimerDelete,jdbcType=BIGINT}, 
      #{minTimerDelete,jdbcType=BIGINT}, #{avgTimerDelete,jdbcType=BIGINT}, #{maxTimerDelete,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, INDEX_NAME, COUNT_STAR, SUM_TIMER_WAIT, 
    MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, COUNT_READ, SUM_TIMER_READ, MIN_TIMER_READ, 
    AVG_TIMER_READ, MAX_TIMER_READ, COUNT_WRITE, SUM_TIMER_WRITE, MIN_TIMER_WRITE, AVG_TIMER_WRITE, 
    MAX_TIMER_WRITE, COUNT_FETCH, SUM_TIMER_FETCH, MIN_TIMER_FETCH, AVG_TIMER_FETCH, 
    MAX_TIMER_FETCH, COUNT_INSERT, SUM_TIMER_INSERT, MIN_TIMER_INSERT, AVG_TIMER_INSERT, 
    MAX_TIMER_INSERT, COUNT_UPDATE, SUM_TIMER_UPDATE, MIN_TIMER_UPDATE, AVG_TIMER_UPDATE, 
    MAX_TIMER_UPDATE, COUNT_DELETE, SUM_TIMER_DELETE, MIN_TIMER_DELETE, AVG_TIMER_DELETE, 
    MAX_TIMER_DELETE
    from table_io_waits_summary_by_index_usage
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="database_name" jdbcType="VARCHAR" property="databaseName" />
    <id column="table_name" jdbcType="VARCHAR" property="tableName" />
    <result column="last_update" jdbcType="TIMESTAMP" property="lastUpdate" />
    <result column="n_rows" jdbcType="BIGINT" property="nRows" />
    <result column="clustered_index_size" jdbcType="BIGINT" property="clusteredIndexSize" />
    <result column="sum_of_other_index_sizes" jdbcType="BIGINT" property="sumOfOtherIndexSizes" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from innodb_table_stats
    where database_name = #{databaseName,jdbcType=VARCHAR}
      and table_name = #{tableName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into innodb_table_stats (database_name, table_name, last_update, 
      n_rows, clustered_index_size, sum_of_other_index_sizes
      )
    values (#{databaseName,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, #{lastUpdate,jdbcType=TIMESTAMP}, 
      #{nRows,jdbcType=BIGINT}, #{clusteredIndexSize,jdbcType=BIGINT}, #{sumOfOtherIndexSizes,jdbcType=BIGINT}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update innodb_table_stats
    set last_update = #{lastUpdate,jdbcType=TIMESTAMP},
      n_rows = #{nRows,jdbcType=BIGINT},
      clustered_index_size = #{clusteredIndexSize,jdbcType=BIGINT},
      sum_of_other_index_sizes = #{sumOfOtherIndexSizes,jdbcType=BIGINT}
    where database_name = #{databaseName,jdbcType=VARCHAR}
      and table_name = #{tableName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select database_name, table_name, last_update, n_rows, clustered_index_size, sum_of_other_index_sizes
    from innodb_table_stats
    where database_name = #{databaseName,jdbcType=VARCHAR}
      and table_name = #{tableName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select database_name, table_name, last_update, n_rows, clustered_index_size, sum_of_other_index_sizes
    from innodb_table_stats
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="uid" jdbcType="INTEGER" property="uid" />
    <result column="uname" jdbcType="VARCHAR" property="uname" />
    <result column="pwd" jdbcType="VARCHAR" property="pwd" />
    <result column="realName" jdbcType="VARCHAR" property="realname" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into users (uid, uname, pwd, 
      realName)
    values (#{uid,jdbcType=INTEGER}, #{uname,jdbcType=VARCHAR}, #{pwd,jdbcType=VARCHAR}, 
      #{realname,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select uid, uname, pwd, realName
    from users
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="CONSTRAINT_CATALOG" jdbcType="VARCHAR" property="constraintCatalog" />
    <result column="CONSTRAINT_SCHEMA" jdbcType="VARCHAR" property="constraintSchema" />
    <result column="CONSTRAINT_NAME" jdbcType="VARCHAR" property="constraintName" />
    <result column="TABLE_CATALOG" jdbcType="VARCHAR" property="tableCatalog" />
    <result column="TABLE_SCHEMA" jdbcType="VARCHAR" property="tableSchema" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
    <result column="COLUMN_NAME" jdbcType="VARCHAR" property="columnName" />
    <result column="ORDINAL_POSITION" jdbcType="INTEGER" property="ordinalPosition" />
    <result column="POSITION_IN_UNIQUE_CONSTRAINT" jdbcType="BINARY" property="positionInUniqueConstraint" />
    <result column="REFERENCED_TABLE_SCHEMA" jdbcType="BINARY" property="referencedTableSchema" />
    <result column="REFERENCED_TABLE_NAME" jdbcType="BINARY" property="referencedTableName" />
    <result column="REFERENCED_COLUMN_NAME" jdbcType="BINARY" property="referencedColumnName" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into KEY_COLUMN_USAGE (CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA, 
      CONSTRAINT_NAME, TABLE_CATALOG, TABLE_SCHEMA, 
      TABLE_NAME, COLUMN_NAME, ORDINAL_POSITION, 
      POSITION_IN_UNIQUE_CONSTRAINT, REFERENCED_TABLE_SCHEMA, 
      REFERENCED_TABLE_NAME, REFERENCED_COLUMN_NAME
      )
    values (#{constraintCatalog,jdbcType=VARCHAR}, #{constraintSchema,jdbcType=VARCHAR}, 
      #{constraintName,jdbcType=VARCHAR}, #{tableCatalog,jdbcType=VARCHAR}, #{tableSchema,jdbcType=VARCHAR}, 
      #{tableName,jdbcType=VARCHAR}, #{columnName,jdbcType=VARCHAR}, #{ordinalPosition,jdbcType=INTEGER}, 
      #{positionInUniqueConstraint,jdbcType=BINARY}, #{referencedTableSchema,jdbcType=BINARY}, 
      #{referencedTableName,jdbcType=BINARY}, #{referencedColumnName,jdbcType=BINARY}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA, CONSTRAINT_NAME, TABLE_CATALOG, TABLE_SCHEMA, 
    TABLE_NAME, COLUMN_NAME, ORDINAL_POSITION, POSITION_IN_UNIQUE_CONSTRAINT, REFERENCED_TABLE_SCHEMA, 
    REFERENCED_TABLE_NAME, REFERENCED_COLUMN_NAME
    from KEY_COLUMN_USAGE
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="statement" jdbcType="VARCHAR" property="statement" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="max_latency" jdbcType="BIGINT" property="maxLatency" />
    <result column="lock_latency" jdbcType="BIGINT" property="lockLatency" />
    <result column="rows_sent" jdbcType="BIGINT" property="rowsSent" />
    <result column="rows_examined" jdbcType="BIGINT" property="rowsExamined" />
    <result column="rows_affected" jdbcType="BIGINT" property="rowsAffected" />
    <result column="full_scans" jdbcType="BIGINT" property="fullScans" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$user_summary_by_statement_type (user, statement, total, 
      total_latency, max_latency, lock_latency, 
      rows_sent, rows_examined, rows_affected, 
      full_scans)
    values (#{user,jdbcType=VARCHAR}, #{statement,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{totalLatency,jdbcType=BIGINT}, #{maxLatency,jdbcType=BIGINT}, #{lockLatency,jdbcType=BIGINT}, 
      #{rowsSent,jdbcType=BIGINT}, #{rowsExamined,jdbcType=BIGINT}, #{rowsAffected,jdbcType=BIGINT}, 
      #{fullScans,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, statement, total, total_latency, max_latency, lock_latency, rows_sent, 
    rows_examined, rows_affected, full_scans
    from x$user_summary_by_statement_type
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="COUNT_READ_WRITE" jdbcType="BIGINT" property="countReadWrite" />
    <result column="SUM_TIMER_READ_WRITE" jdbcType="BIGINT" property="sumTimerReadWrite" />
    <result column="MIN_TIMER_READ_WRITE" jdbcType="BIGINT" property="minTimerReadWrite" />
    <result column="AVG_TIMER_READ_WRITE" jdbcType="BIGINT" property="avgTimerReadWrite" />
    <result column="MAX_TIMER_READ_WRITE" jdbcType="BIGINT" property="maxTimerReadWrite" />
    <result column="COUNT_READ_ONLY" jdbcType="BIGINT" property="countReadOnly" />
    <result column="SUM_TIMER_READ_ONLY" jdbcType="BIGINT" property="sumTimerReadOnly" />
    <result column="MIN_TIMER_READ_ONLY" jdbcType="BIGINT" property="minTimerReadOnly" />
    <result column="AVG_TIMER_READ_ONLY" jdbcType="BIGINT" property="avgTimerReadOnly" />
    <result column="MAX_TIMER_READ_ONLY" jdbcType="BIGINT" property="maxTimerReadOnly" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_transactions_summary_by_user_by_event_name (USER, EVENT_NAME, COUNT_STAR, 
      SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
      MAX_TIMER_WAIT, COUNT_READ_WRITE, SUM_TIMER_READ_WRITE, 
      MIN_TIMER_READ_WRITE, AVG_TIMER_READ_WRITE, MAX_TIMER_READ_WRITE, 
      COUNT_READ_ONLY, SUM_TIMER_READ_ONLY, MIN_TIMER_READ_ONLY, 
      AVG_TIMER_READ_ONLY, MAX_TIMER_READ_ONLY)
    values (#{user,jdbcType=CHAR}, #{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, 
      #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, 
      #{maxTimerWait,jdbcType=BIGINT}, #{countReadWrite,jdbcType=BIGINT}, #{sumTimerReadWrite,jdbcType=BIGINT}, 
      #{minTimerReadWrite,jdbcType=BIGINT}, #{avgTimerReadWrite,jdbcType=BIGINT}, #{maxTimerReadWrite,jdbcType=BIGINT}, 
      #{countReadOnly,jdbcType=BIGINT}, #{sumTimerReadOnly,jdbcType=BIGINT}, #{minTimerReadOnly,jdbcType=BIGINT}, 
      #{avgTimerReadOnly,jdbcType=BIGINT}, #{maxTimerReadOnly,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT, COUNT_READ_WRITE, SUM_TIMER_READ_WRITE, MIN_TIMER_READ_WRITE, AVG_TIMER_READ_WRITE, 
    MAX_TIMER_READ_WRITE, COUNT_READ_ONLY, SUM_TIMER_READ_ONLY, MIN_TIMER_READ_ONLY, 
    AVG_TIMER_READ_ONLY, MAX_TIMER_READ_ONLY
    from events_transactions_summary_by_user_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Channel_name" jdbcType="CHAR" property="channelName" />
    <result column="Number_of_lines" jdbcType="INTEGER" property="numberOfLines" />
    <result column="Relay_log_pos" jdbcType="BIGINT" property="relayLogPos" />
    <result column="Master_log_pos" jdbcType="BIGINT" property="masterLogPos" />
    <result column="Sql_delay" jdbcType="INTEGER" property="sqlDelay" />
    <result column="Number_of_workers" jdbcType="INTEGER" property="numberOfWorkers" />
    <result column="Id" jdbcType="INTEGER" property="id" />
    <result column="Relay_log_name" jdbcType="LONGVARCHAR" property="relayLogName" />
    <result column="Master_log_name" jdbcType="LONGVARCHAR" property="masterLogName" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from slave_relay_log_info
    where Channel_name = #{channelName,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into slave_relay_log_info (Channel_name, Number_of_lines, Relay_log_pos, 
      Master_log_pos, Sql_delay, Number_of_workers, 
      Relay_log_name, Master_log_name)
    values (#{channelName,jdbcType=CHAR}, #{numberOfLines,jdbcType=INTEGER}, #{relayLogPos,jdbcType=BIGINT}, 
      #{masterLogPos,jdbcType=BIGINT}, #{sqlDelay,jdbcType=INTEGER}, #{numberOfWorkers,jdbcType=INTEGER}, 
      #{relayLogName,jdbcType=LONGVARCHAR}, #{masterLogName,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update slave_relay_log_info
    set Number_of_lines = #{numberOfLines,jdbcType=INTEGER},
      Relay_log_pos = #{relayLogPos,jdbcType=BIGINT},
      Master_log_pos = #{masterLogPos,jdbcType=BIGINT},
      Sql_delay = #{sqlDelay,jdbcType=INTEGER},
      Number_of_workers = #{numberOfWorkers,jdbcType=INTEGER},
      Id = #{id,jdbcType=INTEGER},
      Relay_log_name = #{relayLogName,jdbcType=LONGVARCHAR},
      Master_log_name = #{masterLogName,jdbcType=LONGVARCHAR}
    where Channel_name = #{channelName,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select Channel_name, Number_of_lines, Relay_log_pos, Master_log_pos, Sql_delay, Number_of_workers, 
    Id, Relay_log_name, Master_log_name
    from slave_relay_log_info
    where Channel_name = #{channelName,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Channel_name, Number_of_lines, Relay_log_pos, Master_log_pos, Sql_delay, Number_of_workers, 
    Id, Relay_log_name, Master_log_name
    from slave_relay_log_info
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_ALLOC" jdbcType="BIGINT" property="countAlloc" />
    <result column="COUNT_FREE" jdbcType="BIGINT" property="countFree" />
    <result column="SUM_NUMBER_OF_BYTES_ALLOC" jdbcType="BIGINT" property="sumNumberOfBytesAlloc" />
    <result column="SUM_NUMBER_OF_BYTES_FREE" jdbcType="BIGINT" property="sumNumberOfBytesFree" />
    <result column="LOW_COUNT_USED" jdbcType="BIGINT" property="lowCountUsed" />
    <result column="CURRENT_COUNT_USED" jdbcType="BIGINT" property="currentCountUsed" />
    <result column="HIGH_COUNT_USED" jdbcType="BIGINT" property="highCountUsed" />
    <result column="LOW_NUMBER_OF_BYTES_USED" jdbcType="BIGINT" property="lowNumberOfBytesUsed" />
    <result column="CURRENT_NUMBER_OF_BYTES_USED" jdbcType="BIGINT" property="currentNumberOfBytesUsed" />
    <result column="HIGH_NUMBER_OF_BYTES_USED" jdbcType="BIGINT" property="highNumberOfBytesUsed" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into memory_summary_by_account_by_event_name (USER, HOST, EVENT_NAME, 
      COUNT_ALLOC, COUNT_FREE, SUM_NUMBER_OF_BYTES_ALLOC, 
      SUM_NUMBER_OF_BYTES_FREE, LOW_COUNT_USED, CURRENT_COUNT_USED, 
      HIGH_COUNT_USED, LOW_NUMBER_OF_BYTES_USED, CURRENT_NUMBER_OF_BYTES_USED, 
      HIGH_NUMBER_OF_BYTES_USED)
    values (#{user,jdbcType=CHAR}, #{host,jdbcType=CHAR}, #{eventName,jdbcType=VARCHAR}, 
      #{countAlloc,jdbcType=BIGINT}, #{countFree,jdbcType=BIGINT}, #{sumNumberOfBytesAlloc,jdbcType=BIGINT}, 
      #{sumNumberOfBytesFree,jdbcType=BIGINT}, #{lowCountUsed,jdbcType=BIGINT}, #{currentCountUsed,jdbcType=BIGINT}, 
      #{highCountUsed,jdbcType=BIGINT}, #{lowNumberOfBytesUsed,jdbcType=BIGINT}, #{currentNumberOfBytesUsed,jdbcType=BIGINT}, 
      #{highNumberOfBytesUsed,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, HOST, EVENT_NAME, COUNT_ALLOC, COUNT_FREE, SUM_NUMBER_OF_BYTES_ALLOC, 
    SUM_NUMBER_OF_BYTES_FREE, LOW_COUNT_USED, CURRENT_COUNT_USED, HIGH_COUNT_USED, LOW_NUMBER_OF_BYTES_USED, 
    CURRENT_NUMBER_OF_BYTES_USED, HIGH_NUMBER_OF_BYTES_USED
    from memory_summary_by_account_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="user_id" jdbcType="INTEGER" property="userId" />
    <result column="user_name" jdbcType="VARCHAR" property="userName" />
    <result column="user_password" jdbcType="VARCHAR" property="userPassword" />
    <result column="user_idnex" jdbcType="INTEGER" property="userIdnex" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from user_id_info
    where user_id = #{userId,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into user_id_info (user_id, user_name, user_password, 
      user_idnex)
    values (#{userId,jdbcType=INTEGER}, #{userName,jdbcType=VARCHAR}, #{userPassword,jdbcType=VARCHAR}, 
      #{userIdnex,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update user_id_info
    set user_name = #{userName,jdbcType=VARCHAR},
      user_password = #{userPassword,jdbcType=VARCHAR},
      user_idnex = #{userIdnex,jdbcType=INTEGER}
    where user_id = #{userId,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select user_id, user_name, user_password, user_idnex
    from user_id_info
    where user_id = #{userId,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select user_id, user_name, user_password, user_idnex
    from user_id_info
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Host" jdbcType="CHAR" property="host" />
    <id column="User" jdbcType="CHAR" property="user" />
    <id column="Password_timestamp" jdbcType="TIMESTAMP" property="passwordTimestamp" />
    <result column="Password" jdbcType="LONGVARCHAR" property="password" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from password_history
    where Host = #{host,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
      and Password_timestamp = #{passwordTimestamp,jdbcType=TIMESTAMP}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into password_history (Host, User, Password_timestamp, 
      Password)
    values (#{host,jdbcType=CHAR}, #{user,jdbcType=CHAR}, #{passwordTimestamp,jdbcType=TIMESTAMP}, 
      #{password,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update password_history
    set Password = #{password,jdbcType=LONGVARCHAR}
    where Host = #{host,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
      and Password_timestamp = #{passwordTimestamp,jdbcType=TIMESTAMP}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select Host, User, Password_timestamp, Password
    from password_history
    where Host = #{host,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
      and Password_timestamp = #{passwordTimestamp,jdbcType=TIMESTAMP}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Host, User, Password_timestamp, Password
    from password_history
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="SPACE_ID" jdbcType="INTEGER" property="spaceId" />
    <result column="INDEX_ID" jdbcType="BIGINT" property="indexId" />
    <result column="N_CACHED_PAGES" jdbcType="BIGINT" property="nCachedPages" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_CACHED_INDEXES (SPACE_ID, INDEX_ID, N_CACHED_PAGES
      )
    values (#{spaceId,jdbcType=INTEGER}, #{indexId,jdbcType=BIGINT}, #{nCachedPages,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select SPACE_ID, INDEX_ID, N_CACHED_PAGES
    from INNODB_CACHED_INDEXES
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="NAME" jdbcType="VARCHAR" property="name" />
    <result column="SUBSYSTEM" jdbcType="VARCHAR" property="subsystem" />
    <result column="COUNT" jdbcType="BIGINT" property="count" />
    <result column="MAX_COUNT" jdbcType="BIGINT" property="maxCount" />
    <result column="MIN_COUNT" jdbcType="BIGINT" property="minCount" />
    <result column="AVG_COUNT" jdbcType="REAL" property="avgCount" />
    <result column="COUNT_RESET" jdbcType="BIGINT" property="countReset" />
    <result column="MAX_COUNT_RESET" jdbcType="BIGINT" property="maxCountReset" />
    <result column="MIN_COUNT_RESET" jdbcType="BIGINT" property="minCountReset" />
    <result column="AVG_COUNT_RESET" jdbcType="REAL" property="avgCountReset" />
    <result column="TIME_ENABLED" jdbcType="TIMESTAMP" property="timeEnabled" />
    <result column="TIME_DISABLED" jdbcType="TIMESTAMP" property="timeDisabled" />
    <result column="TIME_ELAPSED" jdbcType="BIGINT" property="timeElapsed" />
    <result column="TIME_RESET" jdbcType="TIMESTAMP" property="timeReset" />
    <result column="STATUS" jdbcType="VARCHAR" property="status" />
    <result column="TYPE" jdbcType="VARCHAR" property="type" />
    <result column="COMMENT" jdbcType="VARCHAR" property="comment" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_METRICS (NAME, SUBSYSTEM, COUNT, 
      MAX_COUNT, MIN_COUNT, AVG_COUNT, 
      COUNT_RESET, MAX_COUNT_RESET, MIN_COUNT_RESET, 
      AVG_COUNT_RESET, TIME_ENABLED, TIME_DISABLED, 
      TIME_ELAPSED, TIME_RESET, STATUS, 
      TYPE, COMMENT)
    values (#{name,jdbcType=VARCHAR}, #{subsystem,jdbcType=VARCHAR}, #{count,jdbcType=BIGINT}, 
      #{maxCount,jdbcType=BIGINT}, #{minCount,jdbcType=BIGINT}, #{avgCount,jdbcType=REAL}, 
      #{countReset,jdbcType=BIGINT}, #{maxCountReset,jdbcType=BIGINT}, #{minCountReset,jdbcType=BIGINT}, 
      #{avgCountReset,jdbcType=REAL}, #{timeEnabled,jdbcType=TIMESTAMP}, #{timeDisabled,jdbcType=TIMESTAMP}, 
      #{timeElapsed,jdbcType=BIGINT}, #{timeReset,jdbcType=TIMESTAMP}, #{status,jdbcType=VARCHAR}, 
      #{type,jdbcType=VARCHAR}, #{comment,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select NAME, SUBSYSTEM, COUNT, MAX_COUNT, MIN_COUNT, AVG_COUNT, COUNT_RESET, MAX_COUNT_RESET, 
    MIN_COUNT_RESET, AVG_COUNT_RESET, TIME_ENABLED, TIME_DISABLED, TIME_ELAPSED, TIME_RESET, 
    STATUS, TYPE, COMMENT
    from INNODB_METRICS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="STATEMENT_ID" jdbcType="BIGINT" property="statementId" />
    <result column="STATEMENT_NAME" jdbcType="VARCHAR" property="statementName" />
    <result column="OWNER_THREAD_ID" jdbcType="BIGINT" property="ownerThreadId" />
    <result column="OWNER_EVENT_ID" jdbcType="BIGINT" property="ownerEventId" />
    <result column="OWNER_OBJECT_TYPE" jdbcType="CHAR" property="ownerObjectType" />
    <result column="OWNER_OBJECT_SCHEMA" jdbcType="VARCHAR" property="ownerObjectSchema" />
    <result column="OWNER_OBJECT_NAME" jdbcType="VARCHAR" property="ownerObjectName" />
    <result column="TIMER_PREPARE" jdbcType="BIGINT" property="timerPrepare" />
    <result column="COUNT_REPREPARE" jdbcType="BIGINT" property="countReprepare" />
    <result column="COUNT_EXECUTE" jdbcType="BIGINT" property="countExecute" />
    <result column="SUM_TIMER_EXECUTE" jdbcType="BIGINT" property="sumTimerExecute" />
    <result column="MIN_TIMER_EXECUTE" jdbcType="BIGINT" property="minTimerExecute" />
    <result column="AVG_TIMER_EXECUTE" jdbcType="BIGINT" property="avgTimerExecute" />
    <result column="MAX_TIMER_EXECUTE" jdbcType="BIGINT" property="maxTimerExecute" />
    <result column="SUM_LOCK_TIME" jdbcType="BIGINT" property="sumLockTime" />
    <result column="SUM_ERRORS" jdbcType="BIGINT" property="sumErrors" />
    <result column="SUM_WARNINGS" jdbcType="BIGINT" property="sumWarnings" />
    <result column="SUM_ROWS_AFFECTED" jdbcType="BIGINT" property="sumRowsAffected" />
    <result column="SUM_ROWS_SENT" jdbcType="BIGINT" property="sumRowsSent" />
    <result column="SUM_ROWS_EXAMINED" jdbcType="BIGINT" property="sumRowsExamined" />
    <result column="SUM_CREATED_TMP_DISK_TABLES" jdbcType="BIGINT" property="sumCreatedTmpDiskTables" />
    <result column="SUM_CREATED_TMP_TABLES" jdbcType="BIGINT" property="sumCreatedTmpTables" />
    <result column="SUM_SELECT_FULL_JOIN" jdbcType="BIGINT" property="sumSelectFullJoin" />
    <result column="SUM_SELECT_FULL_RANGE_JOIN" jdbcType="BIGINT" property="sumSelectFullRangeJoin" />
    <result column="SUM_SELECT_RANGE" jdbcType="BIGINT" property="sumSelectRange" />
    <result column="SUM_SELECT_RANGE_CHECK" jdbcType="BIGINT" property="sumSelectRangeCheck" />
    <result column="SUM_SELECT_SCAN" jdbcType="BIGINT" property="sumSelectScan" />
    <result column="SUM_SORT_MERGE_PASSES" jdbcType="BIGINT" property="sumSortMergePasses" />
    <result column="SUM_SORT_RANGE" jdbcType="BIGINT" property="sumSortRange" />
    <result column="SUM_SORT_ROWS" jdbcType="BIGINT" property="sumSortRows" />
    <result column="SUM_SORT_SCAN" jdbcType="BIGINT" property="sumSortScan" />
    <result column="SUM_NO_INDEX_USED" jdbcType="BIGINT" property="sumNoIndexUsed" />
    <result column="SUM_NO_GOOD_INDEX_USED" jdbcType="BIGINT" property="sumNoGoodIndexUsed" />
    <result column="SQL_TEXT" jdbcType="LONGVARCHAR" property="sqlText" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from prepared_statements_instances
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into prepared_statements_instances (OBJECT_INSTANCE_BEGIN, STATEMENT_ID, STATEMENT_NAME, 
      OWNER_THREAD_ID, OWNER_EVENT_ID, OWNER_OBJECT_TYPE, 
      OWNER_OBJECT_SCHEMA, OWNER_OBJECT_NAME, TIMER_PREPARE, 
      COUNT_REPREPARE, COUNT_EXECUTE, SUM_TIMER_EXECUTE, 
      MIN_TIMER_EXECUTE, AVG_TIMER_EXECUTE, MAX_TIMER_EXECUTE, 
      SUM_LOCK_TIME, SUM_ERRORS, SUM_WARNINGS, 
      SUM_ROWS_AFFECTED, SUM_ROWS_SENT, SUM_ROWS_EXAMINED, 
      SUM_CREATED_TMP_DISK_TABLES, SUM_CREATED_TMP_TABLES, 
      SUM_SELECT_FULL_JOIN, SUM_SELECT_FULL_RANGE_JOIN, 
      SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, 
      SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, 
      SUM_SORT_SCAN, SUM_NO_INDEX_USED, SUM_NO_GOOD_INDEX_USED, 
      SQL_TEXT)
    values (#{objectInstanceBegin,jdbcType=BIGINT}, #{statementId,jdbcType=BIGINT}, #{statementName,jdbcType=VARCHAR}, 
      #{ownerThreadId,jdbcType=BIGINT}, #{ownerEventId,jdbcType=BIGINT}, #{ownerObjectType,jdbcType=CHAR}, 
      #{ownerObjectSchema,jdbcType=VARCHAR}, #{ownerObjectName,jdbcType=VARCHAR}, #{timerPrepare,jdbcType=BIGINT}, 
      #{countReprepare,jdbcType=BIGINT}, #{countExecute,jdbcType=BIGINT}, #{sumTimerExecute,jdbcType=BIGINT}, 
      #{minTimerExecute,jdbcType=BIGINT}, #{avgTimerExecute,jdbcType=BIGINT}, #{maxTimerExecute,jdbcType=BIGINT}, 
      #{sumLockTime,jdbcType=BIGINT}, #{sumErrors,jdbcType=BIGINT}, #{sumWarnings,jdbcType=BIGINT}, 
      #{sumRowsAffected,jdbcType=BIGINT}, #{sumRowsSent,jdbcType=BIGINT}, #{sumRowsExamined,jdbcType=BIGINT}, 
      #{sumCreatedTmpDiskTables,jdbcType=BIGINT}, #{sumCreatedTmpTables,jdbcType=BIGINT}, 
      #{sumSelectFullJoin,jdbcType=BIGINT}, #{sumSelectFullRangeJoin,jdbcType=BIGINT}, 
      #{sumSelectRange,jdbcType=BIGINT}, #{sumSelectRangeCheck,jdbcType=BIGINT}, #{sumSelectScan,jdbcType=BIGINT}, 
      #{sumSortMergePasses,jdbcType=BIGINT}, #{sumSortRange,jdbcType=BIGINT}, #{sumSortRows,jdbcType=BIGINT}, 
      #{sumSortScan,jdbcType=BIGINT}, #{sumNoIndexUsed,jdbcType=BIGINT}, #{sumNoGoodIndexUsed,jdbcType=BIGINT}, 
      #{sqlText,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update prepared_statements_instances
    set STATEMENT_ID = #{statementId,jdbcType=BIGINT},
      STATEMENT_NAME = #{statementName,jdbcType=VARCHAR},
      OWNER_THREAD_ID = #{ownerThreadId,jdbcType=BIGINT},
      OWNER_EVENT_ID = #{ownerEventId,jdbcType=BIGINT},
      OWNER_OBJECT_TYPE = #{ownerObjectType,jdbcType=CHAR},
      OWNER_OBJECT_SCHEMA = #{ownerObjectSchema,jdbcType=VARCHAR},
      OWNER_OBJECT_NAME = #{ownerObjectName,jdbcType=VARCHAR},
      TIMER_PREPARE = #{timerPrepare,jdbcType=BIGINT},
      COUNT_REPREPARE = #{countReprepare,jdbcType=BIGINT},
      COUNT_EXECUTE = #{countExecute,jdbcType=BIGINT},
      SUM_TIMER_EXECUTE = #{sumTimerExecute,jdbcType=BIGINT},
      MIN_TIMER_EXECUTE = #{minTimerExecute,jdbcType=BIGINT},
      AVG_TIMER_EXECUTE = #{avgTimerExecute,jdbcType=BIGINT},
      MAX_TIMER_EXECUTE = #{maxTimerExecute,jdbcType=BIGINT},
      SUM_LOCK_TIME = #{sumLockTime,jdbcType=BIGINT},
      SUM_ERRORS = #{sumErrors,jdbcType=BIGINT},
      SUM_WARNINGS = #{sumWarnings,jdbcType=BIGINT},
      SUM_ROWS_AFFECTED = #{sumRowsAffected,jdbcType=BIGINT},
      SUM_ROWS_SENT = #{sumRowsSent,jdbcType=BIGINT},
      SUM_ROWS_EXAMINED = #{sumRowsExamined,jdbcType=BIGINT},
      SUM_CREATED_TMP_DISK_TABLES = #{sumCreatedTmpDiskTables,jdbcType=BIGINT},
      SUM_CREATED_TMP_TABLES = #{sumCreatedTmpTables,jdbcType=BIGINT},
      SUM_SELECT_FULL_JOIN = #{sumSelectFullJoin,jdbcType=BIGINT},
      SUM_SELECT_FULL_RANGE_JOIN = #{sumSelectFullRangeJoin,jdbcType=BIGINT},
      SUM_SELECT_RANGE = #{sumSelectRange,jdbcType=BIGINT},
      SUM_SELECT_RANGE_CHECK = #{sumSelectRangeCheck,jdbcType=BIGINT},
      SUM_SELECT_SCAN = #{sumSelectScan,jdbcType=BIGINT},
      SUM_SORT_MERGE_PASSES = #{sumSortMergePasses,jdbcType=BIGINT},
      SUM_SORT_RANGE = #{sumSortRange,jdbcType=BIGINT},
      SUM_SORT_ROWS = #{sumSortRows,jdbcType=BIGINT},
      SUM_SORT_SCAN = #{sumSortScan,jdbcType=BIGINT},
      SUM_NO_INDEX_USED = #{sumNoIndexUsed,jdbcType=BIGINT},
      SUM_NO_GOOD_INDEX_USED = #{sumNoGoodIndexUsed,jdbcType=BIGINT},
      SQL_TEXT = #{sqlText,jdbcType=LONGVARCHAR}
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, STATEMENT_ID, STATEMENT_NAME, OWNER_THREAD_ID, OWNER_EVENT_ID, 
    OWNER_OBJECT_TYPE, OWNER_OBJECT_SCHEMA, OWNER_OBJECT_NAME, TIMER_PREPARE, COUNT_REPREPARE, 
    COUNT_EXECUTE, SUM_TIMER_EXECUTE, MIN_TIMER_EXECUTE, AVG_TIMER_EXECUTE, MAX_TIMER_EXECUTE, 
    SUM_LOCK_TIME, SUM_ERRORS, SUM_WARNINGS, SUM_ROWS_AFFECTED, SUM_ROWS_SENT, SUM_ROWS_EXAMINED, 
    SUM_CREATED_TMP_DISK_TABLES, SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, SUM_SELECT_FULL_RANGE_JOIN, 
    SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, SUM_SORT_MERGE_PASSES, 
    SUM_SORT_RANGE, SUM_SORT_ROWS, SUM_SORT_SCAN, SUM_NO_INDEX_USED, SUM_NO_GOOD_INDEX_USED, 
    SQL_TEXT
    from prepared_statements_instances
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, STATEMENT_ID, STATEMENT_NAME, OWNER_THREAD_ID, OWNER_EVENT_ID, 
    OWNER_OBJECT_TYPE, OWNER_OBJECT_SCHEMA, OWNER_OBJECT_NAME, TIMER_PREPARE, COUNT_REPREPARE, 
    COUNT_EXECUTE, SUM_TIMER_EXECUTE, MIN_TIMER_EXECUTE, AVG_TIMER_EXECUTE, MAX_TIMER_EXECUTE, 
    SUM_LOCK_TIME, SUM_ERRORS, SUM_WARNINGS, SUM_ROWS_AFFECTED, SUM_ROWS_SENT, SUM_ROWS_EXAMINED, 
    SUM_CREATED_TMP_DISK_TABLES, SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, SUM_SELECT_FULL_RANGE_JOIN, 
    SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, SUM_SORT_MERGE_PASSES, 
    SUM_SORT_RANGE, SUM_SORT_ROWS, SUM_SORT_SCAN, SUM_NO_INDEX_USED, SUM_NO_GOOD_INDEX_USED, 
    SQL_TEXT
    from prepared_statements_instances
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="thd_id" jdbcType="BIGINT" property="thdId" />
    <result column="conn_id" jdbcType="BIGINT" property="connId" />
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="command" jdbcType="VARCHAR" property="command" />
    <result column="state" jdbcType="VARCHAR" property="state" />
    <result column="time" jdbcType="BIGINT" property="time" />
    <result column="progress" jdbcType="DECIMAL" property="progress" />
    <result column="rows_examined" jdbcType="BIGINT" property="rowsExamined" />
    <result column="rows_sent" jdbcType="BIGINT" property="rowsSent" />
    <result column="rows_affected" jdbcType="BIGINT" property="rowsAffected" />
    <result column="tmp_tables" jdbcType="BIGINT" property="tmpTables" />
    <result column="tmp_disk_tables" jdbcType="BIGINT" property="tmpDiskTables" />
    <result column="full_scan" jdbcType="VARCHAR" property="fullScan" />
    <result column="last_wait" jdbcType="VARCHAR" property="lastWait" />
    <result column="source" jdbcType="VARCHAR" property="source" />
    <result column="trx_state" jdbcType="CHAR" property="trxState" />
    <result column="trx_autocommit" jdbcType="CHAR" property="trxAutocommit" />
    <result column="pid" jdbcType="VARCHAR" property="pid" />
    <result column="program_name" jdbcType="VARCHAR" property="programName" />
    <result column="current_statement" jdbcType="LONGVARCHAR" property="currentStatement" />
    <result column="statement_latency" jdbcType="LONGVARCHAR" property="statementLatency" />
    <result column="lock_latency" jdbcType="LONGVARCHAR" property="lockLatency" />
    <result column="last_statement" jdbcType="LONGVARCHAR" property="lastStatement" />
    <result column="last_statement_latency" jdbcType="LONGVARCHAR" property="lastStatementLatency" />
    <result column="current_memory" jdbcType="LONGVARCHAR" property="currentMemory" />
    <result column="last_wait_latency" jdbcType="LONGVARCHAR" property="lastWaitLatency" />
    <result column="trx_latency" jdbcType="LONGVARCHAR" property="trxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into processlist (thd_id, conn_id, user, 
      db, command, state, 
      time, progress, rows_examined, 
      rows_sent, rows_affected, tmp_tables, 
      tmp_disk_tables, full_scan, last_wait, 
      source, trx_state, trx_autocommit, 
      pid, program_name, current_statement, 
      statement_latency, lock_latency, 
      last_statement, last_statement_latency, 
      current_memory, last_wait_latency, 
      trx_latency)
    values (#{thdId,jdbcType=BIGINT}, #{connId,jdbcType=BIGINT}, #{user,jdbcType=VARCHAR}, 
      #{db,jdbcType=VARCHAR}, #{command,jdbcType=VARCHAR}, #{state,jdbcType=VARCHAR}, 
      #{time,jdbcType=BIGINT}, #{progress,jdbcType=DECIMAL}, #{rowsExamined,jdbcType=BIGINT}, 
      #{rowsSent,jdbcType=BIGINT}, #{rowsAffected,jdbcType=BIGINT}, #{tmpTables,jdbcType=BIGINT}, 
      #{tmpDiskTables,jdbcType=BIGINT}, #{fullScan,jdbcType=VARCHAR}, #{lastWait,jdbcType=VARCHAR}, 
      #{source,jdbcType=VARCHAR}, #{trxState,jdbcType=CHAR}, #{trxAutocommit,jdbcType=CHAR}, 
      #{pid,jdbcType=VARCHAR}, #{programName,jdbcType=VARCHAR}, #{currentStatement,jdbcType=LONGVARCHAR}, 
      #{statementLatency,jdbcType=LONGVARCHAR}, #{lockLatency,jdbcType=LONGVARCHAR}, 
      #{lastStatement,jdbcType=LONGVARCHAR}, #{lastStatementLatency,jdbcType=LONGVARCHAR}, 
      #{currentMemory,jdbcType=LONGVARCHAR}, #{lastWaitLatency,jdbcType=LONGVARCHAR}, 
      #{trxLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select thd_id, conn_id, user, db, command, state, time, progress, rows_examined, 
    rows_sent, rows_affected, tmp_tables, tmp_disk_tables, full_scan, last_wait, source, 
    trx_state, trx_autocommit, pid, program_name, current_statement, statement_latency, 
    lock_latency, last_statement, last_statement_latency, current_memory, last_wait_latency, 
    trx_latency
    from processlist
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="TABLE_CATALOG" jdbcType="VARCHAR" property="tableCatalog" />
    <result column="TABLE_SCHEMA" jdbcType="VARCHAR" property="tableSchema" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
    <result column="COLUMN_NAME" jdbcType="VARCHAR" property="columnName" />
    <result column="SRS_NAME" jdbcType="VARCHAR" property="srsName" />
    <result column="SRS_ID" jdbcType="INTEGER" property="srsId" />
    <result column="GEOMETRY_TYPE_NAME" jdbcType="LONGVARCHAR" property="geometryTypeName" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into ST_GEOMETRY_COLUMNS (TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, 
      COLUMN_NAME, SRS_NAME, SRS_ID, 
      GEOMETRY_TYPE_NAME)
    values (#{tableCatalog,jdbcType=VARCHAR}, #{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, 
      #{columnName,jdbcType=VARCHAR}, #{srsName,jdbcType=VARCHAR}, #{srsId,jdbcType=INTEGER}, 
      #{geometryTypeName,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, SRS_NAME, SRS_ID, GEOMETRY_TYPE_NAME
    from ST_GEOMETRY_COLUMNS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="NAME" jdbcType="VARCHAR" property="name" />
    <result column="ENABLED" jdbcType="CHAR" property="enabled" />
    <result column="HISTORY" jdbcType="CHAR" property="history" />
    <result column="PROPERTIES" jdbcType="CHAR" property="properties" />
    <result column="VOLATILITY" jdbcType="INTEGER" property="volatility" />
    <result column="DOCUMENTATION" jdbcType="LONGVARCHAR" property="documentation" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from setup_threads
    where NAME = #{name,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into setup_threads (NAME, ENABLED, HISTORY, 
      PROPERTIES, VOLATILITY, DOCUMENTATION
      )
    values (#{name,jdbcType=VARCHAR}, #{enabled,jdbcType=CHAR}, #{history,jdbcType=CHAR}, 
      #{properties,jdbcType=CHAR}, #{volatility,jdbcType=INTEGER}, #{documentation,jdbcType=LONGVARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update setup_threads
    set ENABLED = #{enabled,jdbcType=CHAR},
      HISTORY = #{history,jdbcType=CHAR},
      PROPERTIES = #{properties,jdbcType=CHAR},
      VOLATILITY = #{volatility,jdbcType=INTEGER},
      DOCUMENTATION = #{documentation,jdbcType=LONGVARCHAR}
    where NAME = #{name,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select NAME, ENABLED, HISTORY, PROPERTIES, VOLATILITY, DOCUMENTATION
    from setup_threads
    where NAME = #{name,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select NAME, ENABLED, HISTORY, PROPERTIES, VOLATILITY, DOCUMENTATION
    from setup_threads
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="allocated" jdbcType="DECIMAL" property="allocated" />
    <result column="data" jdbcType="DECIMAL" property="data" />
    <result column="pages" jdbcType="BIGINT" property="pages" />
    <result column="pages_hashed" jdbcType="BIGINT" property="pagesHashed" />
    <result column="pages_old" jdbcType="BIGINT" property="pagesOld" />
    <result column="rows_cached" jdbcType="DECIMAL" property="rowsCached" />
    <result column="object_schema" jdbcType="LONGVARCHAR" property="objectSchema" />
    <result column="object_name" jdbcType="LONGVARCHAR" property="objectName" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$innodb_buffer_stats_by_table (allocated, data, pages, 
      pages_hashed, pages_old, rows_cached, 
      object_schema, object_name)
    values (#{allocated,jdbcType=DECIMAL}, #{data,jdbcType=DECIMAL}, #{pages,jdbcType=BIGINT}, 
      #{pagesHashed,jdbcType=BIGINT}, #{pagesOld,jdbcType=BIGINT}, #{rowsCached,jdbcType=DECIMAL}, 
      #{objectSchema,jdbcType=LONGVARCHAR}, #{objectName,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select allocated, data, pages, pages_hashed, pages_old, rows_cached, object_schema, 
    object_name
    from x$innodb_buffer_stats_by_table
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="Variable_name" jdbcType="VARCHAR" property="variableName" />
    <result column="Variable_value" jdbcType="VARCHAR" property="variableValue" />
    <result column="Type" jdbcType="VARCHAR" property="type" />
    <result column="Enabled" jdbcType="VARCHAR" property="enabled" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into metrics (Variable_name, Variable_value, Type, 
      Enabled)
    values (#{variableName,jdbcType=VARCHAR}, #{variableValue,jdbcType=VARCHAR}, #{type,jdbcType=VARCHAR}, 
      #{enabled,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select Variable_name, Variable_value, Type, Enabled
    from metrics
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="IP" jdbcType="VARCHAR" property="ip" />
    <result column="HOST" jdbcType="VARCHAR" property="host" />
    <result column="HOST_VALIDATED" jdbcType="CHAR" property="hostValidated" />
    <result column="SUM_CONNECT_ERRORS" jdbcType="BIGINT" property="sumConnectErrors" />
    <result column="COUNT_HOST_BLOCKED_ERRORS" jdbcType="BIGINT" property="countHostBlockedErrors" />
    <result column="COUNT_NAMEINFO_TRANSIENT_ERRORS" jdbcType="BIGINT" property="countNameinfoTransientErrors" />
    <result column="COUNT_NAMEINFO_PERMANENT_ERRORS" jdbcType="BIGINT" property="countNameinfoPermanentErrors" />
    <result column="COUNT_FORMAT_ERRORS" jdbcType="BIGINT" property="countFormatErrors" />
    <result column="COUNT_ADDRINFO_TRANSIENT_ERRORS" jdbcType="BIGINT" property="countAddrinfoTransientErrors" />
    <result column="COUNT_ADDRINFO_PERMANENT_ERRORS" jdbcType="BIGINT" property="countAddrinfoPermanentErrors" />
    <result column="COUNT_FCRDNS_ERRORS" jdbcType="BIGINT" property="countFcrdnsErrors" />
    <result column="COUNT_HOST_ACL_ERRORS" jdbcType="BIGINT" property="countHostAclErrors" />
    <result column="COUNT_NO_AUTH_PLUGIN_ERRORS" jdbcType="BIGINT" property="countNoAuthPluginErrors" />
    <result column="COUNT_AUTH_PLUGIN_ERRORS" jdbcType="BIGINT" property="countAuthPluginErrors" />
    <result column="COUNT_HANDSHAKE_ERRORS" jdbcType="BIGINT" property="countHandshakeErrors" />
    <result column="COUNT_PROXY_USER_ERRORS" jdbcType="BIGINT" property="countProxyUserErrors" />
    <result column="COUNT_PROXY_USER_ACL_ERRORS" jdbcType="BIGINT" property="countProxyUserAclErrors" />
    <result column="COUNT_AUTHENTICATION_ERRORS" jdbcType="BIGINT" property="countAuthenticationErrors" />
    <result column="COUNT_SSL_ERRORS" jdbcType="BIGINT" property="countSslErrors" />
    <result column="COUNT_MAX_USER_CONNECTIONS_ERRORS" jdbcType="BIGINT" property="countMaxUserConnectionsErrors" />
    <result column="COUNT_MAX_USER_CONNECTIONS_PER_HOUR_ERRORS" jdbcType="BIGINT" property="countMaxUserConnectionsPerHourErrors" />
    <result column="COUNT_DEFAULT_DATABASE_ERRORS" jdbcType="BIGINT" property="countDefaultDatabaseErrors" />
    <result column="COUNT_INIT_CONNECT_ERRORS" jdbcType="BIGINT" property="countInitConnectErrors" />
    <result column="COUNT_LOCAL_ERRORS" jdbcType="BIGINT" property="countLocalErrors" />
    <result column="COUNT_UNKNOWN_ERRORS" jdbcType="BIGINT" property="countUnknownErrors" />
    <result column="FIRST_SEEN" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="LAST_SEEN" jdbcType="TIMESTAMP" property="lastSeen" />
    <result column="FIRST_ERROR_SEEN" jdbcType="TIMESTAMP" property="firstErrorSeen" />
    <result column="LAST_ERROR_SEEN" jdbcType="TIMESTAMP" property="lastErrorSeen" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from host_cache
    where IP = #{ip,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into host_cache (IP, HOST, HOST_VALIDATED, 
      SUM_CONNECT_ERRORS, COUNT_HOST_BLOCKED_ERRORS, 
      COUNT_NAMEINFO_TRANSIENT_ERRORS, COUNT_NAMEINFO_PERMANENT_ERRORS, 
      COUNT_FORMAT_ERRORS, COUNT_ADDRINFO_TRANSIENT_ERRORS, 
      COUNT_ADDRINFO_PERMANENT_ERRORS, COUNT_FCRDNS_ERRORS, 
      COUNT_HOST_ACL_ERRORS, COUNT_NO_AUTH_PLUGIN_ERRORS, 
      COUNT_AUTH_PLUGIN_ERRORS, COUNT_HANDSHAKE_ERRORS, 
      COUNT_PROXY_USER_ERRORS, COUNT_PROXY_USER_ACL_ERRORS, 
      COUNT_AUTHENTICATION_ERRORS, COUNT_SSL_ERRORS, 
      COUNT_MAX_USER_CONNECTIONS_ERRORS, COUNT_MAX_USER_CONNECTIONS_PER_HOUR_ERRORS, 
      COUNT_DEFAULT_DATABASE_ERRORS, COUNT_INIT_CONNECT_ERRORS, 
      COUNT_LOCAL_ERRORS, COUNT_UNKNOWN_ERRORS, FIRST_SEEN, 
      LAST_SEEN, FIRST_ERROR_SEEN, LAST_ERROR_SEEN
      )
    values (#{ip,jdbcType=VARCHAR}, #{host,jdbcType=VARCHAR}, #{hostValidated,jdbcType=CHAR}, 
      #{sumConnectErrors,jdbcType=BIGINT}, #{countHostBlockedErrors,jdbcType=BIGINT}, 
      #{countNameinfoTransientErrors,jdbcType=BIGINT}, #{countNameinfoPermanentErrors,jdbcType=BIGINT}, 
      #{countFormatErrors,jdbcType=BIGINT}, #{countAddrinfoTransientErrors,jdbcType=BIGINT}, 
      #{countAddrinfoPermanentErrors,jdbcType=BIGINT}, #{countFcrdnsErrors,jdbcType=BIGINT}, 
      #{countHostAclErrors,jdbcType=BIGINT}, #{countNoAuthPluginErrors,jdbcType=BIGINT}, 
      #{countAuthPluginErrors,jdbcType=BIGINT}, #{countHandshakeErrors,jdbcType=BIGINT}, 
      #{countProxyUserErrors,jdbcType=BIGINT}, #{countProxyUserAclErrors,jdbcType=BIGINT}, 
      #{countAuthenticationErrors,jdbcType=BIGINT}, #{countSslErrors,jdbcType=BIGINT}, 
      #{countMaxUserConnectionsErrors,jdbcType=BIGINT}, #{countMaxUserConnectionsPerHourErrors,jdbcType=BIGINT}, 
      #{countDefaultDatabaseErrors,jdbcType=BIGINT}, #{countInitConnectErrors,jdbcType=BIGINT}, 
      #{countLocalErrors,jdbcType=BIGINT}, #{countUnknownErrors,jdbcType=BIGINT}, #{firstSeen,jdbcType=TIMESTAMP}, 
      #{lastSeen,jdbcType=TIMESTAMP}, #{firstErrorSeen,jdbcType=TIMESTAMP}, #{lastErrorSeen,jdbcType=TIMESTAMP}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update host_cache
    set HOST = #{host,jdbcType=VARCHAR},
      HOST_VALIDATED = #{hostValidated,jdbcType=CHAR},
      SUM_CONNECT_ERRORS = #{sumConnectErrors,jdbcType=BIGINT},
      COUNT_HOST_BLOCKED_ERRORS = #{countHostBlockedErrors,jdbcType=BIGINT},
      COUNT_NAMEINFO_TRANSIENT_ERRORS = #{countNameinfoTransientErrors,jdbcType=BIGINT},
      COUNT_NAMEINFO_PERMANENT_ERRORS = #{countNameinfoPermanentErrors,jdbcType=BIGINT},
      COUNT_FORMAT_ERRORS = #{countFormatErrors,jdbcType=BIGINT},
      COUNT_ADDRINFO_TRANSIENT_ERRORS = #{countAddrinfoTransientErrors,jdbcType=BIGINT},
      COUNT_ADDRINFO_PERMANENT_ERRORS = #{countAddrinfoPermanentErrors,jdbcType=BIGINT},
      COUNT_FCRDNS_ERRORS = #{countFcrdnsErrors,jdbcType=BIGINT},
      COUNT_HOST_ACL_ERRORS = #{countHostAclErrors,jdbcType=BIGINT},
      COUNT_NO_AUTH_PLUGIN_ERRORS = #{countNoAuthPluginErrors,jdbcType=BIGINT},
      COUNT_AUTH_PLUGIN_ERRORS = #{countAuthPluginErrors,jdbcType=BIGINT},
      COUNT_HANDSHAKE_ERRORS = #{countHandshakeErrors,jdbcType=BIGINT},
      COUNT_PROXY_USER_ERRORS = #{countProxyUserErrors,jdbcType=BIGINT},
      COUNT_PROXY_USER_ACL_ERRORS = #{countProxyUserAclErrors,jdbcType=BIGINT},
      COUNT_AUTHENTICATION_ERRORS = #{countAuthenticationErrors,jdbcType=BIGINT},
      COUNT_SSL_ERRORS = #{countSslErrors,jdbcType=BIGINT},
      COUNT_MAX_USER_CONNECTIONS_ERRORS = #{countMaxUserConnectionsErrors,jdbcType=BIGINT},
      COUNT_MAX_USER_CONNECTIONS_PER_HOUR_ERRORS = #{countMaxUserConnectionsPerHourErrors,jdbcType=BIGINT},
      COUNT_DEFAULT_DATABASE_ERRORS = #{countDefaultDatabaseErrors,jdbcType=BIGINT},
      COUNT_INIT_CONNECT_ERRORS = #{countInitConnectErrors,jdbcType=BIGINT},
      COUNT_LOCAL_ERRORS = #{countLocalErrors,jdbcType=BIGINT},
      COUNT_UNKNOWN_ERRORS = #{countUnknownErrors,jdbcType=BIGINT},
      FIRST_SEEN = #{firstSeen,jdbcType=TIMESTAMP},
      LAST_SEEN = #{lastSeen,jdbcType=TIMESTAMP},
      FIRST_ERROR_SEEN = #{firstErrorSeen,jdbcType=TIMESTAMP},
      LAST_ERROR_SEEN = #{lastErrorSeen,jdbcType=TIMESTAMP}
    where IP = #{ip,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select IP, HOST, HOST_VALIDATED, SUM_CONNECT_ERRORS, COUNT_HOST_BLOCKED_ERRORS, COUNT_NAMEINFO_TRANSIENT_ERRORS, 
    COUNT_NAMEINFO_PERMANENT_ERRORS, COUNT_FORMAT_ERRORS, COUNT_ADDRINFO_TRANSIENT_ERRORS, 
    COUNT_ADDRINFO_PERMANENT_ERRORS, COUNT_FCRDNS_ERRORS, COUNT_HOST_ACL_ERRORS, COUNT_NO_AUTH_PLUGIN_ERRORS, 
    COUNT_AUTH_PLUGIN_ERRORS, COUNT_HANDSHAKE_ERRORS, COUNT_PROXY_USER_ERRORS, COUNT_PROXY_USER_ACL_ERRORS, 
    COUNT_AUTHENTICATION_ERRORS, COUNT_SSL_ERRORS, COUNT_MAX_USER_CONNECTIONS_ERRORS, 
    COUNT_MAX_USER_CONNECTIONS_PER_HOUR_ERRORS, COUNT_DEFAULT_DATABASE_ERRORS, COUNT_INIT_CONNECT_ERRORS, 
    COUNT_LOCAL_ERRORS, COUNT_UNKNOWN_ERRORS, FIRST_SEEN, LAST_SEEN, FIRST_ERROR_SEEN, 
    LAST_ERROR_SEEN
    from host_cache
    where IP = #{ip,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select IP, HOST, HOST_VALIDATED, SUM_CONNECT_ERRORS, COUNT_HOST_BLOCKED_ERRORS, COUNT_NAMEINFO_TRANSIENT_ERRORS, 
    COUNT_NAMEINFO_PERMANENT_ERRORS, COUNT_FORMAT_ERRORS, COUNT_ADDRINFO_TRANSIENT_ERRORS, 
    COUNT_ADDRINFO_PERMANENT_ERRORS, COUNT_FCRDNS_ERRORS, COUNT_HOST_ACL_ERRORS, COUNT_NO_AUTH_PLUGIN_ERRORS, 
    COUNT_AUTH_PLUGIN_ERRORS, COUNT_HANDSHAKE_ERRORS, COUNT_PROXY_USER_ERRORS, COUNT_PROXY_USER_ACL_ERRORS, 
    COUNT_AUTHENTICATION_ERRORS, COUNT_SSL_ERRORS, COUNT_MAX_USER_CONNECTIONS_ERRORS, 
    COUNT_MAX_USER_CONNECTIONS_PER_HOUR_ERRORS, COUNT_DEFAULT_DATABASE_ERRORS, COUNT_INIT_CONNECT_ERRORS, 
    COUNT_LOCAL_ERRORS, COUNT_UNKNOWN_ERRORS, FIRST_SEEN, LAST_SEEN, FIRST_ERROR_SEEN, 
    LAST_ERROR_SEEN
    from host_cache
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="component_id" jdbcType="INTEGER" property="componentId" />
    <result column="component_group_id" jdbcType="INTEGER" property="componentGroupId" />
    <result column="component_urn" jdbcType="LONGVARCHAR" property="componentUrn" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from component
    where component_id = #{componentId,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into component (component_id, component_group_id, component_urn
      )
    values (#{componentId,jdbcType=INTEGER}, #{componentGroupId,jdbcType=INTEGER}, #{componentUrn,jdbcType=LONGVARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update component
    set component_group_id = #{componentGroupId,jdbcType=INTEGER},
      component_urn = #{componentUrn,jdbcType=LONGVARCHAR}
    where component_id = #{componentId,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select component_id, component_group_id, component_urn
    from component
    where component_id = #{componentId,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select component_id, component_group_id, component_urn
    from component
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="table_schema" jdbcType="VARCHAR" property="tableSchema" />
    <result column="table_name" jdbcType="VARCHAR" property="tableName" />
    <result column="column_name" jdbcType="VARCHAR" property="columnName" />
    <result column="is_signed" jdbcType="INTEGER" property="isSigned" />
    <result column="is_unsigned" jdbcType="INTEGER" property="isUnsigned" />
    <result column="max_value" jdbcType="BIGINT" property="maxValue" />
    <result column="auto_increment" jdbcType="BIGINT" property="autoIncrement" />
    <result column="auto_increment_ratio" jdbcType="DECIMAL" property="autoIncrementRatio" />
    <result column="data_type" jdbcType="LONGVARCHAR" property="dataType" />
    <result column="column_type" jdbcType="LONGVARCHAR" property="columnType" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into schema_auto_increment_columns (table_schema, table_name, column_name, 
      is_signed, is_unsigned, max_value, 
      auto_increment, auto_increment_ratio, data_type, 
      column_type)
    values (#{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, #{columnName,jdbcType=VARCHAR}, 
      #{isSigned,jdbcType=INTEGER}, #{isUnsigned,jdbcType=INTEGER}, #{maxValue,jdbcType=BIGINT}, 
      #{autoIncrement,jdbcType=BIGINT}, #{autoIncrementRatio,jdbcType=DECIMAL}, #{dataType,jdbcType=LONGVARCHAR}, 
      #{columnType,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select table_schema, table_name, column_name, is_signed, is_unsigned, max_value, 
    auto_increment, auto_increment_ratio, data_type, column_type
    from schema_auto_increment_columns
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="page_size" jdbcType="INTEGER" property="pageSize" />
    <result column="buffer_pool_instance" jdbcType="INTEGER" property="bufferPoolInstance" />
    <result column="pages_used" jdbcType="INTEGER" property="pagesUsed" />
    <result column="pages_free" jdbcType="INTEGER" property="pagesFree" />
    <result column="relocation_ops" jdbcType="BIGINT" property="relocationOps" />
    <result column="relocation_time" jdbcType="INTEGER" property="relocationTime" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_CMPMEM (page_size, buffer_pool_instance, pages_used, 
      pages_free, relocation_ops, relocation_time
      )
    values (#{pageSize,jdbcType=INTEGER}, #{bufferPoolInstance,jdbcType=INTEGER}, #{pagesUsed,jdbcType=INTEGER}, 
      #{pagesFree,jdbcType=INTEGER}, #{relocationOps,jdbcType=BIGINT}, #{relocationTime,jdbcType=INTEGER}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select page_size, buffer_pool_instance, pages_used, pages_free, relocation_ops, relocation_time
    from INNODB_CMPMEM
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="CATALOG_NAME" jdbcType="VARCHAR" property="catalogName" />
    <result column="SCHEMA_NAME" jdbcType="VARCHAR" property="schemaName" />
    <result column="DEFAULT_CHARACTER_SET_NAME" jdbcType="VARCHAR" property="defaultCharacterSetName" />
    <result column="DEFAULT_COLLATION_NAME" jdbcType="VARCHAR" property="defaultCollationName" />
    <result column="DEFAULT_ENCRYPTION" jdbcType="CHAR" property="defaultEncryption" />
    <result column="SQL_PATH" jdbcType="BINARY" property="sqlPath" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into SCHEMATA (CATALOG_NAME, SCHEMA_NAME, DEFAULT_CHARACTER_SET_NAME, 
      DEFAULT_COLLATION_NAME, DEFAULT_ENCRYPTION, SQL_PATH
      )
    values (#{catalogName,jdbcType=VARCHAR}, #{schemaName,jdbcType=VARCHAR}, #{defaultCharacterSetName,jdbcType=VARCHAR}, 
      #{defaultCollationName,jdbcType=VARCHAR}, #{defaultEncryption,jdbcType=CHAR}, #{sqlPath,jdbcType=BINARY}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select CATALOG_NAME, SCHEMA_NAME, DEFAULT_CHARACTER_SET_NAME, DEFAULT_COLLATION_NAME, 
    DEFAULT_ENCRYPTION, SQL_PATH
    from SCHEMATA
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="table_schema" jdbcType="VARCHAR" property="tableSchema" />
    <result column="table_name" jdbcType="VARCHAR" property="tableName" />
    <result column="rows_fetched" jdbcType="BIGINT" property="rowsFetched" />
    <result column="rows_inserted" jdbcType="BIGINT" property="rowsInserted" />
    <result column="rows_updated" jdbcType="BIGINT" property="rowsUpdated" />
    <result column="rows_deleted" jdbcType="BIGINT" property="rowsDeleted" />
    <result column="io_read_requests" jdbcType="DECIMAL" property="ioReadRequests" />
    <result column="io_write_requests" jdbcType="DECIMAL" property="ioWriteRequests" />
    <result column="io_misc_requests" jdbcType="DECIMAL" property="ioMiscRequests" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="fetch_latency" jdbcType="LONGVARCHAR" property="fetchLatency" />
    <result column="insert_latency" jdbcType="LONGVARCHAR" property="insertLatency" />
    <result column="update_latency" jdbcType="LONGVARCHAR" property="updateLatency" />
    <result column="delete_latency" jdbcType="LONGVARCHAR" property="deleteLatency" />
    <result column="io_read" jdbcType="LONGVARCHAR" property="ioRead" />
    <result column="io_read_latency" jdbcType="LONGVARCHAR" property="ioReadLatency" />
    <result column="io_write" jdbcType="LONGVARCHAR" property="ioWrite" />
    <result column="io_write_latency" jdbcType="LONGVARCHAR" property="ioWriteLatency" />
    <result column="io_misc_latency" jdbcType="LONGVARCHAR" property="ioMiscLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into schema_table_statistics (table_schema, table_name, rows_fetched, 
      rows_inserted, rows_updated, rows_deleted, 
      io_read_requests, io_write_requests, io_misc_requests, 
      total_latency, fetch_latency, insert_latency, 
      update_latency, delete_latency, io_read, 
      io_read_latency, io_write, io_write_latency, 
      io_misc_latency)
    values (#{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, #{rowsFetched,jdbcType=BIGINT}, 
      #{rowsInserted,jdbcType=BIGINT}, #{rowsUpdated,jdbcType=BIGINT}, #{rowsDeleted,jdbcType=BIGINT}, 
      #{ioReadRequests,jdbcType=DECIMAL}, #{ioWriteRequests,jdbcType=DECIMAL}, #{ioMiscRequests,jdbcType=DECIMAL}, 
      #{totalLatency,jdbcType=LONGVARCHAR}, #{fetchLatency,jdbcType=LONGVARCHAR}, #{insertLatency,jdbcType=LONGVARCHAR}, 
      #{updateLatency,jdbcType=LONGVARCHAR}, #{deleteLatency,jdbcType=LONGVARCHAR}, #{ioRead,jdbcType=LONGVARCHAR}, 
      #{ioReadLatency,jdbcType=LONGVARCHAR}, #{ioWrite,jdbcType=LONGVARCHAR}, #{ioWriteLatency,jdbcType=LONGVARCHAR}, 
      #{ioMiscLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select table_schema, table_name, rows_fetched, rows_inserted, rows_updated, rows_deleted, 
    io_read_requests, io_write_requests, io_misc_requests, total_latency, fetch_latency, 
    insert_latency, update_latency, delete_latency, io_read, io_read_latency, io_write, 
    io_write_latency, io_misc_latency
    from schema_table_statistics
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="database_name" jdbcType="VARCHAR" property="databaseName" />
    <result column="table_name" jdbcType="VARCHAR" property="tableName" />
    <result column="index_name" jdbcType="VARCHAR" property="indexName" />
    <result column="compress_ops" jdbcType="INTEGER" property="compressOps" />
    <result column="compress_ops_ok" jdbcType="INTEGER" property="compressOpsOk" />
    <result column="compress_time" jdbcType="INTEGER" property="compressTime" />
    <result column="uncompress_ops" jdbcType="INTEGER" property="uncompressOps" />
    <result column="uncompress_time" jdbcType="INTEGER" property="uncompressTime" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_CMP_PER_INDEX (database_name, table_name, index_name, 
      compress_ops, compress_ops_ok, compress_time, 
      uncompress_ops, uncompress_time)
    values (#{databaseName,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, #{indexName,jdbcType=VARCHAR}, 
      #{compressOps,jdbcType=INTEGER}, #{compressOpsOk,jdbcType=INTEGER}, #{compressTime,jdbcType=INTEGER}, 
      #{uncompressOps,jdbcType=INTEGER}, #{uncompressTime,jdbcType=INTEGER})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select database_name, table_name, index_name, compress_ops, compress_ops_ok, compress_time, 
    uncompress_ops, uncompress_time
    from INNODB_CMP_PER_INDEX
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="did" jdbcType="BIGINT" property="did" />
    <result column="mon" jdbcType="VARCHAR" property="mon" />
    <result column="tue" jdbcType="VARCHAR" property="tue" />
    <result column="wed" jdbcType="VARCHAR" property="wed" />
    <result column="thu" jdbcType="VARCHAR" property="thu" />
    <result column="fri" jdbcType="VARCHAR" property="fri" />
    <result column="sat" jdbcType="VARCHAR" property="sat" />
    <result column="sun" jdbcType="VARCHAR" property="sun" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from subborder
    where did = #{did,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into subborder (did, mon, tue, 
      wed, thu, fri, sat, 
      sun)
    values (#{did,jdbcType=BIGINT}, #{mon,jdbcType=VARCHAR}, #{tue,jdbcType=VARCHAR}, 
      #{wed,jdbcType=VARCHAR}, #{thu,jdbcType=VARCHAR}, #{fri,jdbcType=VARCHAR}, #{sat,jdbcType=VARCHAR}, 
      #{sun,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update subborder
    set mon = #{mon,jdbcType=VARCHAR},
      tue = #{tue,jdbcType=VARCHAR},
      wed = #{wed,jdbcType=VARCHAR},
      thu = #{thu,jdbcType=VARCHAR},
      fri = #{fri,jdbcType=VARCHAR},
      sat = #{sat,jdbcType=VARCHAR},
      sun = #{sun,jdbcType=VARCHAR}
    where did = #{did,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select did, mon, tue, wed, thu, fri, sat, sun
    from subborder
    where did = #{did,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select did, mon, tue, wed, thu, fri, sat, sun
    from subborder
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="dept_no" jdbcType="BIGINT" property="deptNo" />
    <result column="d_name" jdbcType="VARCHAR" property="dName" />
    <result column="db_name" jdbcType="VARCHAR" property="dbName" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from t_dept
    where dept_no = #{deptNo,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into t_dept (dept_no, d_name, db_name
      )
    values (#{deptNo,jdbcType=BIGINT}, #{dName,jdbcType=VARCHAR}, #{dbName,jdbcType=VARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update t_dept
    set d_name = #{dName,jdbcType=VARCHAR},
      db_name = #{dbName,jdbcType=VARCHAR}
    where dept_no = #{deptNo,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select dept_no, d_name, db_name
    from t_dept
    where dept_no = #{deptNo,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select dept_no, d_name, db_name
    from t_dept
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="uid" jdbcType="INTEGER" property="uid" />
    <result column="uname" jdbcType="VARCHAR" property="uname" />
    <result column="upwd" jdbcType="CHAR" property="upwd" />
    <result column="realname" jdbcType="VARCHAR" property="realname" />
    <result column="sex" jdbcType="CHAR" property="sex" />
    <result column="identity" jdbcType="CHAR" property="identity" />
    <result column="good_value" jdbcType="INTEGER" property="goodValue" />
    <result column="money" jdbcType="INTEGER" property="money" />
    <result column="qq" jdbcType="VARCHAR" property="qq" />
    <result column="weixin" jdbcType="VARCHAR" property="weixin" />
    <result column="tel" jdbcType="CHAR" property="tel" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from userinfo
    where uid = #{uid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into userinfo (uid, uname, upwd, 
      realname, sex, identity, 
      good_value, money, qq, 
      weixin, tel)
    values (#{uid,jdbcType=INTEGER}, #{uname,jdbcType=VARCHAR}, #{upwd,jdbcType=CHAR}, 
      #{realname,jdbcType=VARCHAR}, #{sex,jdbcType=CHAR}, #{identity,jdbcType=CHAR}, 
      #{goodValue,jdbcType=INTEGER}, #{money,jdbcType=INTEGER}, #{qq,jdbcType=VARCHAR}, 
      #{weixin,jdbcType=VARCHAR}, #{tel,jdbcType=CHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update userinfo
    set uname = #{uname,jdbcType=VARCHAR},
      upwd = #{upwd,jdbcType=CHAR},
      realname = #{realname,jdbcType=VARCHAR},
      sex = #{sex,jdbcType=CHAR},
      identity = #{identity,jdbcType=CHAR},
      good_value = #{goodValue,jdbcType=INTEGER},
      money = #{money,jdbcType=INTEGER},
      qq = #{qq,jdbcType=VARCHAR},
      weixin = #{weixin,jdbcType=VARCHAR},
      tel = #{tel,jdbcType=CHAR}
    where uid = #{uid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select uid, uname, upwd, realname, sex, identity, good_value, money, qq, weixin, 
    tel
    from userinfo
    where uid = #{uid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select uid, uname, upwd, realname, sex, identity, good_value, money, qq, weixin, 
    tel
    from userinfo
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="total" jdbcType="DECIMAL" property="total" />
    <result column="total_latency" jdbcType="DECIMAL" property="totalLatency" />
    <result column="max_latency" jdbcType="BIGINT" property="maxLatency" />
    <result column="lock_latency" jdbcType="DECIMAL" property="lockLatency" />
    <result column="rows_sent" jdbcType="DECIMAL" property="rowsSent" />
    <result column="rows_examined" jdbcType="DECIMAL" property="rowsExamined" />
    <result column="rows_affected" jdbcType="DECIMAL" property="rowsAffected" />
    <result column="full_scans" jdbcType="DECIMAL" property="fullScans" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$host_summary_by_statement_latency (host, total, total_latency, 
      max_latency, lock_latency, rows_sent, 
      rows_examined, rows_affected, full_scans
      )
    values (#{host,jdbcType=VARCHAR}, #{total,jdbcType=DECIMAL}, #{totalLatency,jdbcType=DECIMAL}, 
      #{maxLatency,jdbcType=BIGINT}, #{lockLatency,jdbcType=DECIMAL}, #{rowsSent,jdbcType=DECIMAL}, 
      #{rowsExamined,jdbcType=DECIMAL}, #{rowsAffected,jdbcType=DECIMAL}, #{fullScans,jdbcType=DECIMAL}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, total, total_latency, max_latency, lock_latency, rows_sent, rows_examined, 
    rows_affected, full_scans
    from x$host_summary_by_statement_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="jid" jdbcType="BIGINT" property="jid" />
    <result column="did" jdbcType="BIGINT" property="did" />
    <result column="createdate" jdbcType="TIMESTAMP" property="createdate" />
    <result column="operation" jdbcType="VARCHAR" property="operation" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from subjects
    where jid = #{jid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into subjects (jid, did, createdate, 
      operation)
    values (#{jid,jdbcType=BIGINT}, #{did,jdbcType=BIGINT}, #{createdate,jdbcType=TIMESTAMP}, 
      #{operation,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update subjects
    set did = #{did,jdbcType=BIGINT},
      createdate = #{createdate,jdbcType=TIMESTAMP},
      operation = #{operation,jdbcType=VARCHAR}
    where jid = #{jid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select jid, did, createdate, operation
    from subjects
    where jid = #{jid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select jid, did, createdate, operation
    from subjects
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="CHANNEL_NAME" jdbcType="CHAR" property="channelName" />
    <result column="FILTER_NAME" jdbcType="CHAR" property="filterName" />
    <result column="CONFIGURED_BY" jdbcType="CHAR" property="configuredBy" />
    <result column="ACTIVE_SINCE" jdbcType="TIMESTAMP" property="activeSince" />
    <result column="COUNTER" jdbcType="BIGINT" property="counter" />
    <result column="FILTER_RULE" jdbcType="LONGVARCHAR" property="filterRule" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into replication_applier_filters (CHANNEL_NAME, FILTER_NAME, CONFIGURED_BY, 
      ACTIVE_SINCE, COUNTER, FILTER_RULE
      )
    values (#{channelName,jdbcType=CHAR}, #{filterName,jdbcType=CHAR}, #{configuredBy,jdbcType=CHAR}, 
      #{activeSince,jdbcType=TIMESTAMP}, #{counter,jdbcType=BIGINT}, #{filterRule,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select CHANNEL_NAME, FILTER_NAME, CONFIGURED_BY, ACTIVE_SINCE, COUNTER, FILTER_RULE
    from replication_applier_filters
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Host" jdbcType="CHAR" property="host" />
    <id column="Db" jdbcType="CHAR" property="db" />
    <id column="User" jdbcType="CHAR" property="user" />
    <result column="Select_priv" jdbcType="CHAR" property="selectPriv" />
    <result column="Insert_priv" jdbcType="CHAR" property="insertPriv" />
    <result column="Update_priv" jdbcType="CHAR" property="updatePriv" />
    <result column="Delete_priv" jdbcType="CHAR" property="deletePriv" />
    <result column="Create_priv" jdbcType="CHAR" property="createPriv" />
    <result column="Drop_priv" jdbcType="CHAR" property="dropPriv" />
    <result column="Grant_priv" jdbcType="CHAR" property="grantPriv" />
    <result column="References_priv" jdbcType="CHAR" property="referencesPriv" />
    <result column="Index_priv" jdbcType="CHAR" property="indexPriv" />
    <result column="Alter_priv" jdbcType="CHAR" property="alterPriv" />
    <result column="Create_tmp_table_priv" jdbcType="CHAR" property="createTmpTablePriv" />
    <result column="Lock_tables_priv" jdbcType="CHAR" property="lockTablesPriv" />
    <result column="Create_view_priv" jdbcType="CHAR" property="createViewPriv" />
    <result column="Show_view_priv" jdbcType="CHAR" property="showViewPriv" />
    <result column="Create_routine_priv" jdbcType="CHAR" property="createRoutinePriv" />
    <result column="Alter_routine_priv" jdbcType="CHAR" property="alterRoutinePriv" />
    <result column="Execute_priv" jdbcType="CHAR" property="executePriv" />
    <result column="Event_priv" jdbcType="CHAR" property="eventPriv" />
    <result column="Trigger_priv" jdbcType="CHAR" property="triggerPriv" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from db
    where Host = #{host,jdbcType=CHAR}
      and Db = #{db,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into db (Host, Db, User, Select_priv, 
      Insert_priv, Update_priv, Delete_priv, 
      Create_priv, Drop_priv, Grant_priv, 
      References_priv, Index_priv, Alter_priv, 
      Create_tmp_table_priv, Lock_tables_priv, Create_view_priv, 
      Show_view_priv, Create_routine_priv, Alter_routine_priv, 
      Execute_priv, Event_priv, Trigger_priv
      )
    values (#{host,jdbcType=CHAR}, #{db,jdbcType=CHAR}, #{user,jdbcType=CHAR}, #{selectPriv,jdbcType=CHAR}, 
      #{insertPriv,jdbcType=CHAR}, #{updatePriv,jdbcType=CHAR}, #{deletePriv,jdbcType=CHAR}, 
      #{createPriv,jdbcType=CHAR}, #{dropPriv,jdbcType=CHAR}, #{grantPriv,jdbcType=CHAR}, 
      #{referencesPriv,jdbcType=CHAR}, #{indexPriv,jdbcType=CHAR}, #{alterPriv,jdbcType=CHAR}, 
      #{createTmpTablePriv,jdbcType=CHAR}, #{lockTablesPriv,jdbcType=CHAR}, #{createViewPriv,jdbcType=CHAR}, 
      #{showViewPriv,jdbcType=CHAR}, #{createRoutinePriv,jdbcType=CHAR}, #{alterRoutinePriv,jdbcType=CHAR}, 
      #{executePriv,jdbcType=CHAR}, #{eventPriv,jdbcType=CHAR}, #{triggerPriv,jdbcType=CHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update db
    set Select_priv = #{selectPriv,jdbcType=CHAR},
      Insert_priv = #{insertPriv,jdbcType=CHAR},
      Update_priv = #{updatePriv,jdbcType=CHAR},
      Delete_priv = #{deletePriv,jdbcType=CHAR},
      Create_priv = #{createPriv,jdbcType=CHAR},
      Drop_priv = #{dropPriv,jdbcType=CHAR},
      Grant_priv = #{grantPriv,jdbcType=CHAR},
      References_priv = #{referencesPriv,jdbcType=CHAR},
      Index_priv = #{indexPriv,jdbcType=CHAR},
      Alter_priv = #{alterPriv,jdbcType=CHAR},
      Create_tmp_table_priv = #{createTmpTablePriv,jdbcType=CHAR},
      Lock_tables_priv = #{lockTablesPriv,jdbcType=CHAR},
      Create_view_priv = #{createViewPriv,jdbcType=CHAR},
      Show_view_priv = #{showViewPriv,jdbcType=CHAR},
      Create_routine_priv = #{createRoutinePriv,jdbcType=CHAR},
      Alter_routine_priv = #{alterRoutinePriv,jdbcType=CHAR},
      Execute_priv = #{executePriv,jdbcType=CHAR},
      Event_priv = #{eventPriv,jdbcType=CHAR},
      Trigger_priv = #{triggerPriv,jdbcType=CHAR}
    where Host = #{host,jdbcType=CHAR}
      and Db = #{db,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select Host, Db, User, Select_priv, Insert_priv, Update_priv, Delete_priv, Create_priv, 
    Drop_priv, Grant_priv, References_priv, Index_priv, Alter_priv, Create_tmp_table_priv, 
    Lock_tables_priv, Create_view_priv, Show_view_priv, Create_routine_priv, Alter_routine_priv, 
    Execute_priv, Event_priv, Trigger_priv
    from db
    where Host = #{host,jdbcType=CHAR}
      and Db = #{db,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Host, Db, User, Select_priv, Insert_priv, Update_priv, Delete_priv, Create_priv, 
    Drop_priv, Grant_priv, References_priv, Index_priv, Alter_priv, Create_tmp_table_priv, 
    Lock_tables_priv, Create_view_priv, Show_view_priv, Create_routine_priv, Alter_routine_priv, 
    Execute_priv, Event_priv, Trigger_priv
    from db
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="iid" jdbcType="BIGINT" property="iid" />
    <result column="uid" jdbcType="BIGINT" property="uid" />
    <result column="uri" jdbcType="LONGVARCHAR" property="uri" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from imagesuri
    where iid = #{iid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into imagesuri (iid, uid, uri
      )
    values (#{iid,jdbcType=BIGINT}, #{uid,jdbcType=BIGINT}, #{uri,jdbcType=LONGVARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update imagesuri
    set uid = #{uid,jdbcType=BIGINT},
      uri = #{uri,jdbcType=LONGVARCHAR}
    where iid = #{iid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select iid, uid, uri
    from imagesuri
    where iid = #{iid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select iid, uid, uri
    from imagesuri
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="ID" jdbcType="INTEGER" property="id" />
    <result column="SPACE" jdbcType="INTEGER" property="space" />
    <result column="PATH" jdbcType="VARCHAR" property="path" />
    <result column="SIZE" jdbcType="BIGINT" property="size" />
    <result column="STATE" jdbcType="VARCHAR" property="state" />
    <result column="PURPOSE" jdbcType="VARCHAR" property="purpose" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into INNODB_SESSION_TEMP_TABLESPACES (SPACE, PATH, SIZE, 
      STATE, PURPOSE)
    values (#{space,jdbcType=INTEGER}, #{path,jdbcType=VARCHAR}, #{size,jdbcType=BIGINT}, 
      #{state,jdbcType=VARCHAR}, #{purpose,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select ID, SPACE, PATH, SIZE, STATE, PURPOSE
    from INNODB_SESSION_TEMP_TABLESPACES
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="event" jdbcType="VARCHAR" property="event" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="avg_latency" jdbcType="LONGVARCHAR" property="avgLatency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into waits_by_user_by_latency (user, event, total, 
      total_latency, avg_latency, max_latency
      )
    values (#{user,jdbcType=VARCHAR}, #{event,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{totalLatency,jdbcType=LONGVARCHAR}, #{avgLatency,jdbcType=LONGVARCHAR}, #{maxLatency,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, event, total, total_latency, avg_latency, max_latency
    from waits_by_user_by_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="VARIABLE_NAME" jdbcType="VARCHAR" property="variableName" />
    <result column="VARIABLE_VALUE" jdbcType="VARCHAR" property="variableValue" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into status_by_host (HOST, VARIABLE_NAME, VARIABLE_VALUE
      )
    values (#{host,jdbcType=CHAR}, #{variableName,jdbcType=VARCHAR}, #{variableValue,jdbcType=VARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select HOST, VARIABLE_NAME, VARIABLE_VALUE
    from status_by_host
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="event_name" jdbcType="VARCHAR" property="eventName" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="latency" jdbcType="LONGVARCHAR" property="latency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into user_summary_by_file_io_type (user, event_name, total, 
      latency, max_latency)
    values (#{user,jdbcType=VARCHAR}, #{eventName,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{latency,jdbcType=LONGVARCHAR}, #{maxLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, event_name, total, latency, max_latency
    from user_summary_by_file_io_type
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="events" jdbcType="VARCHAR" property="events" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="avg_latency" jdbcType="BIGINT" property="avgLatency" />
    <result column="max_latency" jdbcType="BIGINT" property="maxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$waits_global_by_latency (events, total, total_latency, 
      avg_latency, max_latency)
    values (#{events,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, #{totalLatency,jdbcType=BIGINT}, 
      #{avgLatency,jdbcType=BIGINT}, #{maxLatency,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select events, total, total_latency, avg_latency, max_latency
    from x$waits_global_by_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Host" jdbcType="CHAR" property="host" />
    <id column="User" jdbcType="CHAR" property="user" />
    <result column="Select_priv" jdbcType="CHAR" property="selectPriv" />
    <result column="Insert_priv" jdbcType="CHAR" property="insertPriv" />
    <result column="Update_priv" jdbcType="CHAR" property="updatePriv" />
    <result column="Delete_priv" jdbcType="CHAR" property="deletePriv" />
    <result column="Create_priv" jdbcType="CHAR" property="createPriv" />
    <result column="Drop_priv" jdbcType="CHAR" property="dropPriv" />
    <result column="Reload_priv" jdbcType="CHAR" property="reloadPriv" />
    <result column="Shutdown_priv" jdbcType="CHAR" property="shutdownPriv" />
    <result column="Process_priv" jdbcType="CHAR" property="processPriv" />
    <result column="File_priv" jdbcType="CHAR" property="filePriv" />
    <result column="Grant_priv" jdbcType="CHAR" property="grantPriv" />
    <result column="References_priv" jdbcType="CHAR" property="referencesPriv" />
    <result column="Index_priv" jdbcType="CHAR" property="indexPriv" />
    <result column="Alter_priv" jdbcType="CHAR" property="alterPriv" />
    <result column="Show_db_priv" jdbcType="CHAR" property="showDbPriv" />
    <result column="Super_priv" jdbcType="CHAR" property="superPriv" />
    <result column="Create_tmp_table_priv" jdbcType="CHAR" property="createTmpTablePriv" />
    <result column="Lock_tables_priv" jdbcType="CHAR" property="lockTablesPriv" />
    <result column="Execute_priv" jdbcType="CHAR" property="executePriv" />
    <result column="Repl_slave_priv" jdbcType="CHAR" property="replSlavePriv" />
    <result column="Repl_client_priv" jdbcType="CHAR" property="replClientPriv" />
    <result column="Create_view_priv" jdbcType="CHAR" property="createViewPriv" />
    <result column="Show_view_priv" jdbcType="CHAR" property="showViewPriv" />
    <result column="Create_routine_priv" jdbcType="CHAR" property="createRoutinePriv" />
    <result column="Alter_routine_priv" jdbcType="CHAR" property="alterRoutinePriv" />
    <result column="Create_user_priv" jdbcType="CHAR" property="createUserPriv" />
    <result column="Event_priv" jdbcType="CHAR" property="eventPriv" />
    <result column="Trigger_priv" jdbcType="CHAR" property="triggerPriv" />
    <result column="Create_tablespace_priv" jdbcType="CHAR" property="createTablespacePriv" />
    <result column="ssl_type" jdbcType="CHAR" property="sslType" />
    <result column="max_questions" jdbcType="INTEGER" property="maxQuestions" />
    <result column="max_updates" jdbcType="INTEGER" property="maxUpdates" />
    <result column="max_connections" jdbcType="INTEGER" property="maxConnections" />
    <result column="max_user_connections" jdbcType="INTEGER" property="maxUserConnections" />
    <result column="plugin" jdbcType="CHAR" property="plugin" />
    <result column="password_expired" jdbcType="CHAR" property="passwordExpired" />
    <result column="password_last_changed" jdbcType="TIMESTAMP" property="passwordLastChanged" />
    <result column="password_lifetime" jdbcType="SMALLINT" property="passwordLifetime" />
    <result column="account_locked" jdbcType="CHAR" property="accountLocked" />
    <result column="Create_role_priv" jdbcType="CHAR" property="createRolePriv" />
    <result column="Drop_role_priv" jdbcType="CHAR" property="dropRolePriv" />
    <result column="Password_reuse_history" jdbcType="SMALLINT" property="passwordReuseHistory" />
    <result column="Password_reuse_time" jdbcType="SMALLINT" property="passwordReuseTime" />
    <result column="Password_require_current" jdbcType="CHAR" property="passwordRequireCurrent" />
    <result column="ssl_cipher" jdbcType="LONGVARBINARY" property="sslCipher" />
    <result column="x509_issuer" jdbcType="LONGVARBINARY" property="x509Issuer" />
    <result column="x509_subject" jdbcType="LONGVARBINARY" property="x509Subject" />
    <result column="authentication_string" jdbcType="LONGVARCHAR" property="authenticationString" />
    <result column="User_attributes" jdbcType="LONGVARCHAR" property="userAttributes" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from user
    where Host = #{host,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into user (Host, User, Select_priv, 
      Insert_priv, Update_priv, Delete_priv, 
      Create_priv, Drop_priv, Reload_priv, 
      Shutdown_priv, Process_priv, File_priv, 
      Grant_priv, References_priv, Index_priv, 
      Alter_priv, Show_db_priv, Super_priv, 
      Create_tmp_table_priv, Lock_tables_priv, Execute_priv, 
      Repl_slave_priv, Repl_client_priv, Create_view_priv, 
      Show_view_priv, Create_routine_priv, Alter_routine_priv, 
      Create_user_priv, Event_priv, Trigger_priv, 
      Create_tablespace_priv, ssl_type, max_questions, 
      max_updates, max_connections, max_user_connections, 
      plugin, password_expired, password_last_changed, 
      password_lifetime, account_locked, Create_role_priv, 
      Drop_role_priv, Password_reuse_history, Password_reuse_time, 
      Password_require_current, ssl_cipher, x509_issuer, 
      x509_subject, authentication_string, 
      User_attributes)
    values (#{host,jdbcType=CHAR}, #{user,jdbcType=CHAR}, #{selectPriv,jdbcType=CHAR}, 
      #{insertPriv,jdbcType=CHAR}, #{updatePriv,jdbcType=CHAR}, #{deletePriv,jdbcType=CHAR}, 
      #{createPriv,jdbcType=CHAR}, #{dropPriv,jdbcType=CHAR}, #{reloadPriv,jdbcType=CHAR}, 
      #{shutdownPriv,jdbcType=CHAR}, #{processPriv,jdbcType=CHAR}, #{filePriv,jdbcType=CHAR}, 
      #{grantPriv,jdbcType=CHAR}, #{referencesPriv,jdbcType=CHAR}, #{indexPriv,jdbcType=CHAR}, 
      #{alterPriv,jdbcType=CHAR}, #{showDbPriv,jdbcType=CHAR}, #{superPriv,jdbcType=CHAR}, 
      #{createTmpTablePriv,jdbcType=CHAR}, #{lockTablesPriv,jdbcType=CHAR}, #{executePriv,jdbcType=CHAR}, 
      #{replSlavePriv,jdbcType=CHAR}, #{replClientPriv,jdbcType=CHAR}, #{createViewPriv,jdbcType=CHAR}, 
      #{showViewPriv,jdbcType=CHAR}, #{createRoutinePriv,jdbcType=CHAR}, #{alterRoutinePriv,jdbcType=CHAR}, 
      #{createUserPriv,jdbcType=CHAR}, #{eventPriv,jdbcType=CHAR}, #{triggerPriv,jdbcType=CHAR}, 
      #{createTablespacePriv,jdbcType=CHAR}, #{sslType,jdbcType=CHAR}, #{maxQuestions,jdbcType=INTEGER}, 
      #{maxUpdates,jdbcType=INTEGER}, #{maxConnections,jdbcType=INTEGER}, #{maxUserConnections,jdbcType=INTEGER}, 
      #{plugin,jdbcType=CHAR}, #{passwordExpired,jdbcType=CHAR}, #{passwordLastChanged,jdbcType=TIMESTAMP}, 
      #{passwordLifetime,jdbcType=SMALLINT}, #{accountLocked,jdbcType=CHAR}, #{createRolePriv,jdbcType=CHAR}, 
      #{dropRolePriv,jdbcType=CHAR}, #{passwordReuseHistory,jdbcType=SMALLINT}, #{passwordReuseTime,jdbcType=SMALLINT}, 
      #{passwordRequireCurrent,jdbcType=CHAR}, #{sslCipher,jdbcType=LONGVARBINARY}, #{x509Issuer,jdbcType=LONGVARBINARY}, 
      #{x509Subject,jdbcType=LONGVARBINARY}, #{authenticationString,jdbcType=LONGVARCHAR}, 
      #{userAttributes,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update user
    set Select_priv = #{selectPriv,jdbcType=CHAR},
      Insert_priv = #{insertPriv,jdbcType=CHAR},
      Update_priv = #{updatePriv,jdbcType=CHAR},
      Delete_priv = #{deletePriv,jdbcType=CHAR},
      Create_priv = #{createPriv,jdbcType=CHAR},
      Drop_priv = #{dropPriv,jdbcType=CHAR},
      Reload_priv = #{reloadPriv,jdbcType=CHAR},
      Shutdown_priv = #{shutdownPriv,jdbcType=CHAR},
      Process_priv = #{processPriv,jdbcType=CHAR},
      File_priv = #{filePriv,jdbcType=CHAR},
      Grant_priv = #{grantPriv,jdbcType=CHAR},
      References_priv = #{referencesPriv,jdbcType=CHAR},
      Index_priv = #{indexPriv,jdbcType=CHAR},
      Alter_priv = #{alterPriv,jdbcType=CHAR},
      Show_db_priv = #{showDbPriv,jdbcType=CHAR},
      Super_priv = #{superPriv,jdbcType=CHAR},
      Create_tmp_table_priv = #{createTmpTablePriv,jdbcType=CHAR},
      Lock_tables_priv = #{lockTablesPriv,jdbcType=CHAR},
      Execute_priv = #{executePriv,jdbcType=CHAR},
      Repl_slave_priv = #{replSlavePriv,jdbcType=CHAR},
      Repl_client_priv = #{replClientPriv,jdbcType=CHAR},
      Create_view_priv = #{createViewPriv,jdbcType=CHAR},
      Show_view_priv = #{showViewPriv,jdbcType=CHAR},
      Create_routine_priv = #{createRoutinePriv,jdbcType=CHAR},
      Alter_routine_priv = #{alterRoutinePriv,jdbcType=CHAR},
      Create_user_priv = #{createUserPriv,jdbcType=CHAR},
      Event_priv = #{eventPriv,jdbcType=CHAR},
      Trigger_priv = #{triggerPriv,jdbcType=CHAR},
      Create_tablespace_priv = #{createTablespacePriv,jdbcType=CHAR},
      ssl_type = #{sslType,jdbcType=CHAR},
      max_questions = #{maxQuestions,jdbcType=INTEGER},
      max_updates = #{maxUpdates,jdbcType=INTEGER},
      max_connections = #{maxConnections,jdbcType=INTEGER},
      max_user_connections = #{maxUserConnections,jdbcType=INTEGER},
      plugin = #{plugin,jdbcType=CHAR},
      password_expired = #{passwordExpired,jdbcType=CHAR},
      password_last_changed = #{passwordLastChanged,jdbcType=TIMESTAMP},
      password_lifetime = #{passwordLifetime,jdbcType=SMALLINT},
      account_locked = #{accountLocked,jdbcType=CHAR},
      Create_role_priv = #{createRolePriv,jdbcType=CHAR},
      Drop_role_priv = #{dropRolePriv,jdbcType=CHAR},
      Password_reuse_history = #{passwordReuseHistory,jdbcType=SMALLINT},
      Password_reuse_time = #{passwordReuseTime,jdbcType=SMALLINT},
      Password_require_current = #{passwordRequireCurrent,jdbcType=CHAR},
      ssl_cipher = #{sslCipher,jdbcType=LONGVARBINARY},
      x509_issuer = #{x509Issuer,jdbcType=LONGVARBINARY},
      x509_subject = #{x509Subject,jdbcType=LONGVARBINARY},
      authentication_string = #{authenticationString,jdbcType=LONGVARCHAR},
      User_attributes = #{userAttributes,jdbcType=LONGVARCHAR}
    where Host = #{host,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select Host, User, Select_priv, Insert_priv, Update_priv, Delete_priv, Create_priv, 
    Drop_priv, Reload_priv, Shutdown_priv, Process_priv, File_priv, Grant_priv, References_priv, 
    Index_priv, Alter_priv, Show_db_priv, Super_priv, Create_tmp_table_priv, Lock_tables_priv, 
    Execute_priv, Repl_slave_priv, Repl_client_priv, Create_view_priv, Show_view_priv, 
    Create_routine_priv, Alter_routine_priv, Create_user_priv, Event_priv, Trigger_priv, 
    Create_tablespace_priv, ssl_type, max_questions, max_updates, max_connections, max_user_connections, 
    plugin, password_expired, password_last_changed, password_lifetime, account_locked, 
    Create_role_priv, Drop_role_priv, Password_reuse_history, Password_reuse_time, Password_require_current, 
    ssl_cipher, x509_issuer, x509_subject, authentication_string, User_attributes
    from user
    where Host = #{host,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Host, User, Select_priv, Insert_priv, Update_priv, Delete_priv, Create_priv, 
    Drop_priv, Reload_priv, Shutdown_priv, Process_priv, File_priv, Grant_priv, References_priv, 
    Index_priv, Alter_priv, Show_db_priv, Super_priv, Create_tmp_table_priv, Lock_tables_priv, 
    Execute_priv, Repl_slave_priv, Repl_client_priv, Create_view_priv, Show_view_priv, 
    Create_routine_priv, Alter_routine_priv, Create_user_priv, Event_priv, Trigger_priv, 
    Create_tablespace_priv, ssl_type, max_questions, max_updates, max_connections, max_user_connections, 
    plugin, password_expired, password_last_changed, password_lifetime, account_locked, 
    Create_role_priv, Drop_role_priv, Password_reuse_history, Password_reuse_time, Password_require_current, 
    ssl_cipher, x509_issuer, x509_subject, authentication_string, User_attributes
    from user
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="TABLE_ID" jdbcType="BIGINT" property="tableId" />
    <result column="NAME" jdbcType="VARCHAR" property="name" />
    <result column="STATS_INITIALIZED" jdbcType="VARCHAR" property="statsInitialized" />
    <result column="NUM_ROWS" jdbcType="BIGINT" property="numRows" />
    <result column="CLUST_INDEX_SIZE" jdbcType="BIGINT" property="clustIndexSize" />
    <result column="OTHER_INDEX_SIZE" jdbcType="BIGINT" property="otherIndexSize" />
    <result column="MODIFIED_COUNTER" jdbcType="BIGINT" property="modifiedCounter" />
    <result column="AUTOINC" jdbcType="BIGINT" property="autoinc" />
    <result column="REF_COUNT" jdbcType="INTEGER" property="refCount" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_TABLESTATS (TABLE_ID, NAME, STATS_INITIALIZED, 
      NUM_ROWS, CLUST_INDEX_SIZE, OTHER_INDEX_SIZE, 
      MODIFIED_COUNTER, AUTOINC, REF_COUNT
      )
    values (#{tableId,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{statsInitialized,jdbcType=VARCHAR}, 
      #{numRows,jdbcType=BIGINT}, #{clustIndexSize,jdbcType=BIGINT}, #{otherIndexSize,jdbcType=BIGINT}, 
      #{modifiedCounter,jdbcType=BIGINT}, #{autoinc,jdbcType=BIGINT}, #{refCount,jdbcType=INTEGER}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select TABLE_ID, NAME, STATS_INITIALIZED, NUM_ROWS, CLUST_INDEX_SIZE, OTHER_INDEX_SIZE, 
    MODIFIED_COUNTER, AUTOINC, REF_COUNT
    from INNODB_TABLESTATS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="mid" jdbcType="INTEGER" property="mid" />
    <result column="xid" jdbcType="INTEGER" property="xid" />
    <result column="mzw" jdbcType="INTEGER" property="mzw" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from sale
    where mid = #{mid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into sale (mid, xid, mzw
      )
    values (#{mid,jdbcType=INTEGER}, #{xid,jdbcType=INTEGER}, #{mzw,jdbcType=INTEGER}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update sale
    set xid = #{xid,jdbcType=INTEGER},
      mzw = #{mzw,jdbcType=INTEGER}
    where mid = #{mid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select mid, xid, mzw
    from sale
    where mid = #{mid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select mid, xid, mzw
    from sale
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="event_class" jdbcType="VARCHAR" property="eventClass" />
    <result column="total" jdbcType="DECIMAL" property="total" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="min_latency" jdbcType="LONGVARCHAR" property="minLatency" />
    <result column="avg_latency" jdbcType="LONGVARCHAR" property="avgLatency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into wait_classes_global_by_avg_latency (event_class, total, total_latency, 
      min_latency, avg_latency, max_latency
      )
    values (#{eventClass,jdbcType=VARCHAR}, #{total,jdbcType=DECIMAL}, #{totalLatency,jdbcType=LONGVARCHAR}, 
      #{minLatency,jdbcType=LONGVARCHAR}, #{avgLatency,jdbcType=LONGVARCHAR}, #{maxLatency,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select event_class, total, total_latency, min_latency, avg_latency, max_latency
    from wait_classes_global_by_avg_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="ios" jdbcType="DECIMAL" property="ios" />
    <result column="io_latency" jdbcType="DECIMAL" property="ioLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$host_summary_by_file_io (host, ios, io_latency
      )
    values (#{host,jdbcType=VARCHAR}, #{ios,jdbcType=DECIMAL}, #{ioLatency,jdbcType=DECIMAL}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, ios, io_latency
    from x$host_summary_by_file_io
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="id" jdbcType="BIGINT" property="id" />
    <result column="products_id" jdbcType="BIGINT" property="productsId" />
    <result column="p_desc" jdbcType="LONGVARCHAR" property="pDesc" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from t_products_desc
    where id = #{id,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Long">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into t_products_desc (products_id, p_desc)
    values (#{productsId,jdbcType=BIGINT}, #{pDesc,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update t_products_desc
    set products_id = #{productsId,jdbcType=BIGINT},
      p_desc = #{pDesc,jdbcType=LONGVARCHAR}
    where id = #{id,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select id, products_id, p_desc
    from t_products_desc
    where id = #{id,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select id, products_id, p_desc
    from t_products_desc
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="PROCESSLIST_ID" jdbcType="BIGINT" property="processlistId" />
    <id column="ATTR_NAME" jdbcType="VARCHAR" property="attrName" />
    <result column="ATTR_VALUE" jdbcType="VARCHAR" property="attrValue" />
    <result column="ORDINAL_POSITION" jdbcType="INTEGER" property="ordinalPosition" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from session_connect_attrs
    where PROCESSLIST_ID = #{processlistId,jdbcType=BIGINT}
      and ATTR_NAME = #{attrName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into session_connect_attrs (PROCESSLIST_ID, ATTR_NAME, ATTR_VALUE, 
      ORDINAL_POSITION)
    values (#{processlistId,jdbcType=BIGINT}, #{attrName,jdbcType=VARCHAR}, #{attrValue,jdbcType=VARCHAR}, 
      #{ordinalPosition,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update session_connect_attrs
    set ATTR_VALUE = #{attrValue,jdbcType=VARCHAR},
      ORDINAL_POSITION = #{ordinalPosition,jdbcType=INTEGER}
    where PROCESSLIST_ID = #{processlistId,jdbcType=BIGINT}
      and ATTR_NAME = #{attrName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select PROCESSLIST_ID, ATTR_NAME, ATTR_VALUE, ORDINAL_POSITION
    from session_connect_attrs
    where PROCESSLIST_ID = #{processlistId,jdbcType=BIGINT}
      and ATTR_NAME = #{attrName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select PROCESSLIST_ID, ATTR_NAME, ATTR_VALUE, ORDINAL_POSITION
    from session_connect_attrs
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="DOC_ID" jdbcType="BIGINT" property="docId" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_FT_DELETED (DOC_ID)
    values (#{docId,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select DOC_ID
    from INNODB_FT_DELETED
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <result column="EVENT_ID" jdbcType="BIGINT" property="eventId" />
    <result column="END_EVENT_ID" jdbcType="BIGINT" property="endEventId" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="SOURCE" jdbcType="VARCHAR" property="source" />
    <result column="TIMER_START" jdbcType="BIGINT" property="timerStart" />
    <result column="TIMER_END" jdbcType="BIGINT" property="timerEnd" />
    <result column="TIMER_WAIT" jdbcType="BIGINT" property="timerWait" />
    <result column="LOCK_TIME" jdbcType="BIGINT" property="lockTime" />
    <result column="DIGEST" jdbcType="VARCHAR" property="digest" />
    <result column="CURRENT_SCHEMA" jdbcType="VARCHAR" property="currentSchema" />
    <result column="OBJECT_TYPE" jdbcType="VARCHAR" property="objectType" />
    <result column="OBJECT_SCHEMA" jdbcType="VARCHAR" property="objectSchema" />
    <result column="OBJECT_NAME" jdbcType="VARCHAR" property="objectName" />
    <result column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="MYSQL_ERRNO" jdbcType="INTEGER" property="mysqlErrno" />
    <result column="RETURNED_SQLSTATE" jdbcType="VARCHAR" property="returnedSqlstate" />
    <result column="MESSAGE_TEXT" jdbcType="VARCHAR" property="messageText" />
    <result column="ERRORS" jdbcType="BIGINT" property="errors" />
    <result column="WARNINGS" jdbcType="BIGINT" property="warnings" />
    <result column="ROWS_AFFECTED" jdbcType="BIGINT" property="rowsAffected" />
    <result column="ROWS_SENT" jdbcType="BIGINT" property="rowsSent" />
    <result column="ROWS_EXAMINED" jdbcType="BIGINT" property="rowsExamined" />
    <result column="CREATED_TMP_DISK_TABLES" jdbcType="BIGINT" property="createdTmpDiskTables" />
    <result column="CREATED_TMP_TABLES" jdbcType="BIGINT" property="createdTmpTables" />
    <result column="SELECT_FULL_JOIN" jdbcType="BIGINT" property="selectFullJoin" />
    <result column="SELECT_FULL_RANGE_JOIN" jdbcType="BIGINT" property="selectFullRangeJoin" />
    <result column="SELECT_RANGE" jdbcType="BIGINT" property="selectRange" />
    <result column="SELECT_RANGE_CHECK" jdbcType="BIGINT" property="selectRangeCheck" />
    <result column="SELECT_SCAN" jdbcType="BIGINT" property="selectScan" />
    <result column="SORT_MERGE_PASSES" jdbcType="BIGINT" property="sortMergePasses" />
    <result column="SORT_RANGE" jdbcType="BIGINT" property="sortRange" />
    <result column="SORT_ROWS" jdbcType="BIGINT" property="sortRows" />
    <result column="SORT_SCAN" jdbcType="BIGINT" property="sortScan" />
    <result column="NO_INDEX_USED" jdbcType="BIGINT" property="noIndexUsed" />
    <result column="NO_GOOD_INDEX_USED" jdbcType="BIGINT" property="noGoodIndexUsed" />
    <result column="NESTING_EVENT_ID" jdbcType="BIGINT" property="nestingEventId" />
    <result column="NESTING_EVENT_TYPE" jdbcType="CHAR" property="nestingEventType" />
    <result column="NESTING_EVENT_LEVEL" jdbcType="INTEGER" property="nestingEventLevel" />
    <result column="STATEMENT_ID" jdbcType="BIGINT" property="statementId" />
    <result column="SQL_TEXT" jdbcType="LONGVARCHAR" property="sqlText" />
    <result column="DIGEST_TEXT" jdbcType="LONGVARCHAR" property="digestText" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_statements_history_long (THREAD_ID, EVENT_ID, END_EVENT_ID, 
      EVENT_NAME, SOURCE, TIMER_START, 
      TIMER_END, TIMER_WAIT, LOCK_TIME, 
      DIGEST, CURRENT_SCHEMA, OBJECT_TYPE, 
      OBJECT_SCHEMA, OBJECT_NAME, OBJECT_INSTANCE_BEGIN, 
      MYSQL_ERRNO, RETURNED_SQLSTATE, MESSAGE_TEXT, 
      ERRORS, WARNINGS, ROWS_AFFECTED, 
      ROWS_SENT, ROWS_EXAMINED, CREATED_TMP_DISK_TABLES, 
      CREATED_TMP_TABLES, SELECT_FULL_JOIN, SELECT_FULL_RANGE_JOIN, 
      SELECT_RANGE, SELECT_RANGE_CHECK, SELECT_SCAN, 
      SORT_MERGE_PASSES, SORT_RANGE, SORT_ROWS, 
      SORT_SCAN, NO_INDEX_USED, NO_GOOD_INDEX_USED, 
      NESTING_EVENT_ID, NESTING_EVENT_TYPE, NESTING_EVENT_LEVEL, 
      STATEMENT_ID, SQL_TEXT, DIGEST_TEXT
      )
    values (#{threadId,jdbcType=BIGINT}, #{eventId,jdbcType=BIGINT}, #{endEventId,jdbcType=BIGINT}, 
      #{eventName,jdbcType=VARCHAR}, #{source,jdbcType=VARCHAR}, #{timerStart,jdbcType=BIGINT}, 
      #{timerEnd,jdbcType=BIGINT}, #{timerWait,jdbcType=BIGINT}, #{lockTime,jdbcType=BIGINT}, 
      #{digest,jdbcType=VARCHAR}, #{currentSchema,jdbcType=VARCHAR}, #{objectType,jdbcType=VARCHAR}, 
      #{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, #{objectInstanceBegin,jdbcType=BIGINT}, 
      #{mysqlErrno,jdbcType=INTEGER}, #{returnedSqlstate,jdbcType=VARCHAR}, #{messageText,jdbcType=VARCHAR}, 
      #{errors,jdbcType=BIGINT}, #{warnings,jdbcType=BIGINT}, #{rowsAffected,jdbcType=BIGINT}, 
      #{rowsSent,jdbcType=BIGINT}, #{rowsExamined,jdbcType=BIGINT}, #{createdTmpDiskTables,jdbcType=BIGINT}, 
      #{createdTmpTables,jdbcType=BIGINT}, #{selectFullJoin,jdbcType=BIGINT}, #{selectFullRangeJoin,jdbcType=BIGINT}, 
      #{selectRange,jdbcType=BIGINT}, #{selectRangeCheck,jdbcType=BIGINT}, #{selectScan,jdbcType=BIGINT}, 
      #{sortMergePasses,jdbcType=BIGINT}, #{sortRange,jdbcType=BIGINT}, #{sortRows,jdbcType=BIGINT}, 
      #{sortScan,jdbcType=BIGINT}, #{noIndexUsed,jdbcType=BIGINT}, #{noGoodIndexUsed,jdbcType=BIGINT}, 
      #{nestingEventId,jdbcType=BIGINT}, #{nestingEventType,jdbcType=CHAR}, #{nestingEventLevel,jdbcType=INTEGER}, 
      #{statementId,jdbcType=BIGINT}, #{sqlText,jdbcType=LONGVARCHAR}, #{digestText,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, SOURCE, TIMER_START, TIMER_END, 
    TIMER_WAIT, LOCK_TIME, DIGEST, CURRENT_SCHEMA, OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, 
    OBJECT_INSTANCE_BEGIN, MYSQL_ERRNO, RETURNED_SQLSTATE, MESSAGE_TEXT, ERRORS, WARNINGS, 
    ROWS_AFFECTED, ROWS_SENT, ROWS_EXAMINED, CREATED_TMP_DISK_TABLES, CREATED_TMP_TABLES, 
    SELECT_FULL_JOIN, SELECT_FULL_RANGE_JOIN, SELECT_RANGE, SELECT_RANGE_CHECK, SELECT_SCAN, 
    SORT_MERGE_PASSES, SORT_RANGE, SORT_ROWS, SORT_SCAN, NO_INDEX_USED, NO_GOOD_INDEX_USED, 
    NESTING_EVENT_ID, NESTING_EVENT_TYPE, NESTING_EVENT_LEVEL, STATEMENT_ID, SQL_TEXT, 
    DIGEST_TEXT
    from events_statements_history_long
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="FILE_ID" jdbcType="BIGINT" property="fileId" />
    <result column="FILE_TYPE" jdbcType="VARCHAR" property="fileType" />
    <result column="TABLESPACE_NAME" jdbcType="VARCHAR" property="tablespaceName" />
    <result column="TABLE_CATALOG" jdbcType="CHAR" property="tableCatalog" />
    <result column="LOGFILE_GROUP_NAME" jdbcType="VARCHAR" property="logfileGroupName" />
    <result column="LOGFILE_GROUP_NUMBER" jdbcType="BIGINT" property="logfileGroupNumber" />
    <result column="ENGINE" jdbcType="VARCHAR" property="engine" />
    <result column="FREE_EXTENTS" jdbcType="BIGINT" property="freeExtents" />
    <result column="TOTAL_EXTENTS" jdbcType="BIGINT" property="totalExtents" />
    <result column="EXTENT_SIZE" jdbcType="BIGINT" property="extentSize" />
    <result column="INITIAL_SIZE" jdbcType="BIGINT" property="initialSize" />
    <result column="MAXIMUM_SIZE" jdbcType="BIGINT" property="maximumSize" />
    <result column="AUTOEXTEND_SIZE" jdbcType="BIGINT" property="autoextendSize" />
    <result column="VERSION" jdbcType="BIGINT" property="version" />
    <result column="ROW_FORMAT" jdbcType="VARCHAR" property="rowFormat" />
    <result column="DATA_FREE" jdbcType="BIGINT" property="dataFree" />
    <result column="STATUS" jdbcType="VARCHAR" property="status" />
    <result column="EXTRA" jdbcType="VARCHAR" property="extra" />
    <result column="FILE_NAME" jdbcType="LONGVARCHAR" property="fileName" />
    <result column="TABLE_SCHEMA" jdbcType="BINARY" property="tableSchema" />
    <result column="TABLE_NAME" jdbcType="BINARY" property="tableName" />
    <result column="FULLTEXT_KEYS" jdbcType="BINARY" property="fulltextKeys" />
    <result column="DELETED_ROWS" jdbcType="BINARY" property="deletedRows" />
    <result column="UPDATE_COUNT" jdbcType="BINARY" property="updateCount" />
    <result column="CREATION_TIME" jdbcType="BINARY" property="creationTime" />
    <result column="LAST_UPDATE_TIME" jdbcType="BINARY" property="lastUpdateTime" />
    <result column="LAST_ACCESS_TIME" jdbcType="BINARY" property="lastAccessTime" />
    <result column="RECOVER_TIME" jdbcType="BINARY" property="recoverTime" />
    <result column="TRANSACTION_COUNTER" jdbcType="BINARY" property="transactionCounter" />
    <result column="TABLE_ROWS" jdbcType="BINARY" property="tableRows" />
    <result column="AVG_ROW_LENGTH" jdbcType="BINARY" property="avgRowLength" />
    <result column="DATA_LENGTH" jdbcType="BINARY" property="dataLength" />
    <result column="MAX_DATA_LENGTH" jdbcType="BINARY" property="maxDataLength" />
    <result column="INDEX_LENGTH" jdbcType="BINARY" property="indexLength" />
    <result column="CREATE_TIME" jdbcType="BINARY" property="createTime" />
    <result column="UPDATE_TIME" jdbcType="BINARY" property="updateTime" />
    <result column="CHECK_TIME" jdbcType="BINARY" property="checkTime" />
    <result column="CHECKSUM" jdbcType="BINARY" property="checksum" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into FILES (FILE_ID, FILE_TYPE, TABLESPACE_NAME, 
      TABLE_CATALOG, LOGFILE_GROUP_NAME, LOGFILE_GROUP_NUMBER, 
      ENGINE, FREE_EXTENTS, TOTAL_EXTENTS, 
      EXTENT_SIZE, INITIAL_SIZE, MAXIMUM_SIZE, 
      AUTOEXTEND_SIZE, VERSION, ROW_FORMAT, 
      DATA_FREE, STATUS, EXTRA, 
      FILE_NAME, TABLE_SCHEMA, TABLE_NAME, 
      FULLTEXT_KEYS, DELETED_ROWS, UPDATE_COUNT, 
      CREATION_TIME, LAST_UPDATE_TIME, LAST_ACCESS_TIME, 
      RECOVER_TIME, TRANSACTION_COUNTER, TABLE_ROWS, 
      AVG_ROW_LENGTH, DATA_LENGTH, MAX_DATA_LENGTH, 
      INDEX_LENGTH, CREATE_TIME, UPDATE_TIME, 
      CHECK_TIME, CHECKSUM)
    values (#{fileId,jdbcType=BIGINT}, #{fileType,jdbcType=VARCHAR}, #{tablespaceName,jdbcType=VARCHAR}, 
      #{tableCatalog,jdbcType=CHAR}, #{logfileGroupName,jdbcType=VARCHAR}, #{logfileGroupNumber,jdbcType=BIGINT}, 
      #{engine,jdbcType=VARCHAR}, #{freeExtents,jdbcType=BIGINT}, #{totalExtents,jdbcType=BIGINT}, 
      #{extentSize,jdbcType=BIGINT}, #{initialSize,jdbcType=BIGINT}, #{maximumSize,jdbcType=BIGINT}, 
      #{autoextendSize,jdbcType=BIGINT}, #{version,jdbcType=BIGINT}, #{rowFormat,jdbcType=VARCHAR}, 
      #{dataFree,jdbcType=BIGINT}, #{status,jdbcType=VARCHAR}, #{extra,jdbcType=VARCHAR}, 
      #{fileName,jdbcType=LONGVARCHAR}, #{tableSchema,jdbcType=BINARY}, #{tableName,jdbcType=BINARY}, 
      #{fulltextKeys,jdbcType=BINARY}, #{deletedRows,jdbcType=BINARY}, #{updateCount,jdbcType=BINARY}, 
      #{creationTime,jdbcType=BINARY}, #{lastUpdateTime,jdbcType=BINARY}, #{lastAccessTime,jdbcType=BINARY}, 
      #{recoverTime,jdbcType=BINARY}, #{transactionCounter,jdbcType=BINARY}, #{tableRows,jdbcType=BINARY}, 
      #{avgRowLength,jdbcType=BINARY}, #{dataLength,jdbcType=BINARY}, #{maxDataLength,jdbcType=BINARY}, 
      #{indexLength,jdbcType=BINARY}, #{createTime,jdbcType=BINARY}, #{updateTime,jdbcType=BINARY}, 
      #{checkTime,jdbcType=BINARY}, #{checksum,jdbcType=BINARY})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select FILE_ID, FILE_TYPE, TABLESPACE_NAME, TABLE_CATALOG, LOGFILE_GROUP_NAME, LOGFILE_GROUP_NUMBER, 
    ENGINE, FREE_EXTENTS, TOTAL_EXTENTS, EXTENT_SIZE, INITIAL_SIZE, MAXIMUM_SIZE, AUTOEXTEND_SIZE, 
    VERSION, ROW_FORMAT, DATA_FREE, STATUS, EXTRA, FILE_NAME, TABLE_SCHEMA, TABLE_NAME, 
    FULLTEXT_KEYS, DELETED_ROWS, UPDATE_COUNT, CREATION_TIME, LAST_UPDATE_TIME, LAST_ACCESS_TIME, 
    RECOVER_TIME, TRANSACTION_COUNTER, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH, MAX_DATA_LENGTH, 
    INDEX_LENGTH, CREATE_TIME, UPDATE_TIME, CHECK_TIME, CHECKSUM
    from FILES
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="event_class" jdbcType="VARCHAR" property="eventClass" />
    <result column="total" jdbcType="DECIMAL" property="total" />
    <result column="total_latency" jdbcType="DECIMAL" property="totalLatency" />
    <result column="min_latency" jdbcType="BIGINT" property="minLatency" />
    <result column="avg_latency" jdbcType="DECIMAL" property="avgLatency" />
    <result column="max_latency" jdbcType="BIGINT" property="maxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$wait_classes_global_by_latency (event_class, total, total_latency, 
      min_latency, avg_latency, max_latency
      )
    values (#{eventClass,jdbcType=VARCHAR}, #{total,jdbcType=DECIMAL}, #{totalLatency,jdbcType=DECIMAL}, 
      #{minLatency,jdbcType=BIGINT}, #{avgLatency,jdbcType=DECIMAL}, #{maxLatency,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select event_class, total, total_latency, min_latency, avg_latency, max_latency
    from x$wait_classes_global_by_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="ios" jdbcType="DECIMAL" property="ios" />
    <result column="io_latency" jdbcType="DECIMAL" property="ioLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$user_summary_by_file_io (user, ios, io_latency
      )
    values (#{user,jdbcType=VARCHAR}, #{ios,jdbcType=DECIMAL}, #{ioLatency,jdbcType=DECIMAL}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, ios, io_latency
    from x$user_summary_by_file_io
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="TABLE_ID" jdbcType="BIGINT" property="tableId" />
    <result column="NAME" jdbcType="VARCHAR" property="name" />
    <result column="N_COLS" jdbcType="INTEGER" property="nCols" />
    <result column="SPACE" jdbcType="INTEGER" property="space" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_TEMP_TABLE_INFO (TABLE_ID, NAME, N_COLS, 
      SPACE)
    values (#{tableId,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{nCols,jdbcType=INTEGER}, 
      #{space,jdbcType=INTEGER})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select TABLE_ID, NAME, N_COLS, SPACE
    from INNODB_TEMP_TABLE_INFO
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="file" jdbcType="VARCHAR" property="file" />
    <result column="count_read" jdbcType="BIGINT" property="countRead" />
    <result column="count_write" jdbcType="BIGINT" property="countWrite" />
    <result column="write_pct" jdbcType="DECIMAL" property="writePct" />
    <result column="total_read" jdbcType="LONGVARCHAR" property="totalRead" />
    <result column="avg_read" jdbcType="LONGVARCHAR" property="avgRead" />
    <result column="total_written" jdbcType="LONGVARCHAR" property="totalWritten" />
    <result column="avg_write" jdbcType="LONGVARCHAR" property="avgWrite" />
    <result column="total" jdbcType="LONGVARCHAR" property="total" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into io_global_by_file_by_bytes (file, count_read, count_write, 
      write_pct, total_read, avg_read, 
      total_written, avg_write, total
      )
    values (#{file,jdbcType=VARCHAR}, #{countRead,jdbcType=BIGINT}, #{countWrite,jdbcType=BIGINT}, 
      #{writePct,jdbcType=DECIMAL}, #{totalRead,jdbcType=LONGVARCHAR}, #{avgRead,jdbcType=LONGVARCHAR}, 
      #{totalWritten,jdbcType=LONGVARCHAR}, #{avgWrite,jdbcType=LONGVARCHAR}, #{total,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select file, count_read, count_write, write_pct, total_read, avg_read, total_written, 
    avg_write, total
    from io_global_by_file_by_bytes
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="total" jdbcType="DECIMAL" property="total" />
    <result column="total_latency" jdbcType="DECIMAL" property="totalLatency" />
    <result column="min_latency" jdbcType="BIGINT" property="minLatency" />
    <result column="avg_latency" jdbcType="DECIMAL" property="avgLatency" />
    <result column="max_latency" jdbcType="BIGINT" property="maxLatency" />
    <result column="thread_id" jdbcType="BIGINT" property="threadId" />
    <result column="processlist_id" jdbcType="BIGINT" property="processlistId" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$io_by_thread_by_latency (user, total, total_latency, 
      min_latency, avg_latency, max_latency, 
      thread_id, processlist_id)
    values (#{user,jdbcType=VARCHAR}, #{total,jdbcType=DECIMAL}, #{totalLatency,jdbcType=DECIMAL}, 
      #{minLatency,jdbcType=BIGINT}, #{avgLatency,jdbcType=DECIMAL}, #{maxLatency,jdbcType=BIGINT}, 
      #{threadId,jdbcType=BIGINT}, #{processlistId,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, total, total_latency, min_latency, avg_latency, max_latency, thread_id, 
    processlist_id
    from x$io_by_thread_by_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <result column="SOCKET_ID" jdbcType="INTEGER" property="socketId" />
    <result column="IP" jdbcType="VARCHAR" property="ip" />
    <result column="PORT" jdbcType="INTEGER" property="port" />
    <result column="STATE" jdbcType="CHAR" property="state" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from socket_instances
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into socket_instances (OBJECT_INSTANCE_BEGIN, EVENT_NAME, THREAD_ID, 
      SOCKET_ID, IP, PORT, 
      STATE)
    values (#{objectInstanceBegin,jdbcType=BIGINT}, #{eventName,jdbcType=VARCHAR}, #{threadId,jdbcType=BIGINT}, 
      #{socketId,jdbcType=INTEGER}, #{ip,jdbcType=VARCHAR}, #{port,jdbcType=INTEGER}, 
      #{state,jdbcType=CHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update socket_instances
    set EVENT_NAME = #{eventName,jdbcType=VARCHAR},
      THREAD_ID = #{threadId,jdbcType=BIGINT},
      SOCKET_ID = #{socketId,jdbcType=INTEGER},
      IP = #{ip,jdbcType=VARCHAR},
      PORT = #{port,jdbcType=INTEGER},
      STATE = #{state,jdbcType=CHAR}
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, EVENT_NAME, THREAD_ID, SOCKET_ID, IP, PORT, STATE
    from socket_instances
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, EVENT_NAME, THREAD_ID, SOCKET_ID, IP, PORT, STATE
    from socket_instances
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="source_uuid" jdbcType="CHAR" property="sourceUuid" />
    <id column="interval_start" jdbcType="BIGINT" property="intervalStart" />
    <result column="interval_end" jdbcType="BIGINT" property="intervalEnd" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from gtid_executed
    where source_uuid = #{sourceUuid,jdbcType=CHAR}
      and interval_start = #{intervalStart,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into gtid_executed (source_uuid, interval_start, interval_end
      )
    values (#{sourceUuid,jdbcType=CHAR}, #{intervalStart,jdbcType=BIGINT}, #{intervalEnd,jdbcType=BIGINT}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update gtid_executed
    set interval_end = #{intervalEnd,jdbcType=BIGINT}
    where source_uuid = #{sourceUuid,jdbcType=CHAR}
      and interval_start = #{intervalStart,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select source_uuid, interval_start, interval_end
    from gtid_executed
    where source_uuid = #{sourceUuid,jdbcType=CHAR}
      and interval_start = #{intervalStart,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select source_uuid, interval_start, interval_end
    from gtid_executed
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="total" jdbcType="DECIMAL" property="total" />
    <result column="total_latency" jdbcType="DECIMAL" property="totalLatency" />
    <result column="max_latency" jdbcType="DECIMAL" property="maxLatency" />
    <result column="lock_latency" jdbcType="DECIMAL" property="lockLatency" />
    <result column="rows_sent" jdbcType="DECIMAL" property="rowsSent" />
    <result column="rows_examined" jdbcType="DECIMAL" property="rowsExamined" />
    <result column="rows_affected" jdbcType="DECIMAL" property="rowsAffected" />
    <result column="full_scans" jdbcType="DECIMAL" property="fullScans" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$user_summary_by_statement_latency (user, total, total_latency, 
      max_latency, lock_latency, rows_sent, 
      rows_examined, rows_affected, full_scans
      )
    values (#{user,jdbcType=VARCHAR}, #{total,jdbcType=DECIMAL}, #{totalLatency,jdbcType=DECIMAL}, 
      #{maxLatency,jdbcType=DECIMAL}, #{lockLatency,jdbcType=DECIMAL}, #{rowsSent,jdbcType=DECIMAL}, 
      #{rowsExamined,jdbcType=DECIMAL}, #{rowsAffected,jdbcType=DECIMAL}, #{fullScans,jdbcType=DECIMAL}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, total, total_latency, max_latency, lock_latency, rows_sent, rows_examined, 
    rows_affected, full_scans
    from x$user_summary_by_statement_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="CHANNEL_NAME" jdbcType="CHAR" property="channelName" />
    <result column="DESIRED_DELAY" jdbcType="INTEGER" property="desiredDelay" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from replication_applier_configuration
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into replication_applier_configuration (CHANNEL_NAME, DESIRED_DELAY)
    values (#{channelName,jdbcType=CHAR}, #{desiredDelay,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update replication_applier_configuration
    set DESIRED_DELAY = #{desiredDelay,jdbcType=INTEGER}
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select CHANNEL_NAME, DESIRED_DELAY
    from replication_applier_configuration
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select CHANNEL_NAME, DESIRED_DELAY
    from replication_applier_configuration
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="VARIABLE_NAME" jdbcType="VARCHAR" property="variableName" />
    <result column="VARIABLE_VALUE" jdbcType="VARCHAR" property="variableValue" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into status_by_user (USER, VARIABLE_NAME, VARIABLE_VALUE
      )
    values (#{user,jdbcType=CHAR}, #{variableName,jdbcType=VARCHAR}, #{variableValue,jdbcType=VARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, VARIABLE_NAME, VARIABLE_VALUE
    from status_by_user
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="PROCESSLIST_ID" jdbcType="BIGINT" property="processlistId" />
    <id column="ATTR_NAME" jdbcType="VARCHAR" property="attrName" />
    <result column="ATTR_VALUE" jdbcType="VARCHAR" property="attrValue" />
    <result column="ORDINAL_POSITION" jdbcType="INTEGER" property="ordinalPosition" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from session_account_connect_attrs
    where PROCESSLIST_ID = #{processlistId,jdbcType=BIGINT}
      and ATTR_NAME = #{attrName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into session_account_connect_attrs (PROCESSLIST_ID, ATTR_NAME, ATTR_VALUE, 
      ORDINAL_POSITION)
    values (#{processlistId,jdbcType=BIGINT}, #{attrName,jdbcType=VARCHAR}, #{attrValue,jdbcType=VARCHAR}, 
      #{ordinalPosition,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update session_account_connect_attrs
    set ATTR_VALUE = #{attrValue,jdbcType=VARCHAR},
      ORDINAL_POSITION = #{ordinalPosition,jdbcType=INTEGER}
    where PROCESSLIST_ID = #{processlistId,jdbcType=BIGINT}
      and ATTR_NAME = #{attrName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select PROCESSLIST_ID, ATTR_NAME, ATTR_VALUE, ORDINAL_POSITION
    from session_account_connect_attrs
    where PROCESSLIST_ID = #{processlistId,jdbcType=BIGINT}
      and ATTR_NAME = #{attrName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select PROCESSLIST_ID, ATTR_NAME, ATTR_VALUE, ORDINAL_POSITION
    from session_account_connect_attrs
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="object_schema" jdbcType="VARCHAR" property="objectSchema" />
    <result column="object_name" jdbcType="VARCHAR" property="objectName" />
    <result column="waiting_thread_id" jdbcType="BIGINT" property="waitingThreadId" />
    <result column="waiting_pid" jdbcType="BIGINT" property="waitingPid" />
    <result column="waiting_lock_type" jdbcType="VARCHAR" property="waitingLockType" />
    <result column="waiting_lock_duration" jdbcType="VARCHAR" property="waitingLockDuration" />
    <result column="waiting_query_secs" jdbcType="BIGINT" property="waitingQuerySecs" />
    <result column="waiting_query_rows_affected" jdbcType="BIGINT" property="waitingQueryRowsAffected" />
    <result column="waiting_query_rows_examined" jdbcType="BIGINT" property="waitingQueryRowsExamined" />
    <result column="blocking_thread_id" jdbcType="BIGINT" property="blockingThreadId" />
    <result column="blocking_pid" jdbcType="BIGINT" property="blockingPid" />
    <result column="blocking_lock_type" jdbcType="VARCHAR" property="blockingLockType" />
    <result column="blocking_lock_duration" jdbcType="VARCHAR" property="blockingLockDuration" />
    <result column="sql_kill_blocking_query" jdbcType="VARCHAR" property="sqlKillBlockingQuery" />
    <result column="sql_kill_blocking_connection" jdbcType="VARCHAR" property="sqlKillBlockingConnection" />
    <result column="waiting_account" jdbcType="LONGVARCHAR" property="waitingAccount" />
    <result column="waiting_query" jdbcType="LONGVARCHAR" property="waitingQuery" />
    <result column="blocking_account" jdbcType="LONGVARCHAR" property="blockingAccount" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$schema_table_lock_waits (object_schema, object_name, waiting_thread_id, 
      waiting_pid, waiting_lock_type, waiting_lock_duration, 
      waiting_query_secs, waiting_query_rows_affected, 
      waiting_query_rows_examined, blocking_thread_id, 
      blocking_pid, blocking_lock_type, blocking_lock_duration, 
      sql_kill_blocking_query, sql_kill_blocking_connection, 
      waiting_account, waiting_query, blocking_account
      )
    values (#{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, #{waitingThreadId,jdbcType=BIGINT}, 
      #{waitingPid,jdbcType=BIGINT}, #{waitingLockType,jdbcType=VARCHAR}, #{waitingLockDuration,jdbcType=VARCHAR}, 
      #{waitingQuerySecs,jdbcType=BIGINT}, #{waitingQueryRowsAffected,jdbcType=BIGINT}, 
      #{waitingQueryRowsExamined,jdbcType=BIGINT}, #{blockingThreadId,jdbcType=BIGINT}, 
      #{blockingPid,jdbcType=BIGINT}, #{blockingLockType,jdbcType=VARCHAR}, #{blockingLockDuration,jdbcType=VARCHAR}, 
      #{sqlKillBlockingQuery,jdbcType=VARCHAR}, #{sqlKillBlockingConnection,jdbcType=VARCHAR}, 
      #{waitingAccount,jdbcType=LONGVARCHAR}, #{waitingQuery,jdbcType=LONGVARCHAR}, #{blockingAccount,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select object_schema, object_name, waiting_thread_id, waiting_pid, waiting_lock_type, 
    waiting_lock_duration, waiting_query_secs, waiting_query_rows_affected, waiting_query_rows_examined, 
    blocking_thread_id, blocking_pid, blocking_lock_type, blocking_lock_duration, sql_kill_blocking_query, 
    sql_kill_blocking_connection, waiting_account, waiting_query, blocking_account
    from x$schema_table_lock_waits
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="OBJECT_TYPE" jdbcType="VARCHAR" property="objectType" />
    <result column="OBJECT_SCHEMA" jdbcType="VARCHAR" property="objectSchema" />
    <result column="OBJECT_NAME" jdbcType="VARCHAR" property="objectName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into objects_summary_global_by_type (OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, 
      COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
      AVG_TIMER_WAIT, MAX_TIMER_WAIT)
    values (#{objectType,jdbcType=VARCHAR}, #{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, 
      #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, 
      #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
    AVG_TIMER_WAIT, MAX_TIMER_WAIT
    from objects_summary_global_by_type
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="thd_id" jdbcType="BIGINT" property="thdId" />
    <result column="conn_id" jdbcType="BIGINT" property="connId" />
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="command" jdbcType="VARCHAR" property="command" />
    <result column="state" jdbcType="VARCHAR" property="state" />
    <result column="time" jdbcType="BIGINT" property="time" />
    <result column="statement_latency" jdbcType="BIGINT" property="statementLatency" />
    <result column="progress" jdbcType="DECIMAL" property="progress" />
    <result column="lock_latency" jdbcType="BIGINT" property="lockLatency" />
    <result column="rows_examined" jdbcType="BIGINT" property="rowsExamined" />
    <result column="rows_sent" jdbcType="BIGINT" property="rowsSent" />
    <result column="rows_affected" jdbcType="BIGINT" property="rowsAffected" />
    <result column="tmp_tables" jdbcType="BIGINT" property="tmpTables" />
    <result column="tmp_disk_tables" jdbcType="BIGINT" property="tmpDiskTables" />
    <result column="full_scan" jdbcType="VARCHAR" property="fullScan" />
    <result column="last_statement_latency" jdbcType="BIGINT" property="lastStatementLatency" />
    <result column="current_memory" jdbcType="DECIMAL" property="currentMemory" />
    <result column="last_wait" jdbcType="VARCHAR" property="lastWait" />
    <result column="last_wait_latency" jdbcType="VARCHAR" property="lastWaitLatency" />
    <result column="source" jdbcType="VARCHAR" property="source" />
    <result column="trx_latency" jdbcType="BIGINT" property="trxLatency" />
    <result column="trx_state" jdbcType="CHAR" property="trxState" />
    <result column="trx_autocommit" jdbcType="CHAR" property="trxAutocommit" />
    <result column="pid" jdbcType="VARCHAR" property="pid" />
    <result column="program_name" jdbcType="VARCHAR" property="programName" />
    <result column="current_statement" jdbcType="LONGVARCHAR" property="currentStatement" />
    <result column="last_statement" jdbcType="LONGVARCHAR" property="lastStatement" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$processlist (thd_id, conn_id, user, 
      db, command, state, 
      time, statement_latency, progress, 
      lock_latency, rows_examined, rows_sent, 
      rows_affected, tmp_tables, tmp_disk_tables, 
      full_scan, last_statement_latency, current_memory, 
      last_wait, last_wait_latency, source, 
      trx_latency, trx_state, trx_autocommit, 
      pid, program_name, current_statement, 
      last_statement)
    values (#{thdId,jdbcType=BIGINT}, #{connId,jdbcType=BIGINT}, #{user,jdbcType=VARCHAR}, 
      #{db,jdbcType=VARCHAR}, #{command,jdbcType=VARCHAR}, #{state,jdbcType=VARCHAR}, 
      #{time,jdbcType=BIGINT}, #{statementLatency,jdbcType=BIGINT}, #{progress,jdbcType=DECIMAL}, 
      #{lockLatency,jdbcType=BIGINT}, #{rowsExamined,jdbcType=BIGINT}, #{rowsSent,jdbcType=BIGINT}, 
      #{rowsAffected,jdbcType=BIGINT}, #{tmpTables,jdbcType=BIGINT}, #{tmpDiskTables,jdbcType=BIGINT}, 
      #{fullScan,jdbcType=VARCHAR}, #{lastStatementLatency,jdbcType=BIGINT}, #{currentMemory,jdbcType=DECIMAL}, 
      #{lastWait,jdbcType=VARCHAR}, #{lastWaitLatency,jdbcType=VARCHAR}, #{source,jdbcType=VARCHAR}, 
      #{trxLatency,jdbcType=BIGINT}, #{trxState,jdbcType=CHAR}, #{trxAutocommit,jdbcType=CHAR}, 
      #{pid,jdbcType=VARCHAR}, #{programName,jdbcType=VARCHAR}, #{currentStatement,jdbcType=LONGVARCHAR}, 
      #{lastStatement,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select thd_id, conn_id, user, db, command, state, time, statement_latency, progress, 
    lock_latency, rows_examined, rows_sent, rows_affected, tmp_tables, tmp_disk_tables, 
    full_scan, last_statement_latency, current_memory, last_wait, last_wait_latency, 
    source, trx_latency, trx_state, trx_autocommit, pid, program_name, current_statement, 
    last_statement
    from x$processlist
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="cid" jdbcType="BIGINT" property="cid" />
    <result column="score" jdbcType="INTEGER" property="score" />
    <result column="jid" jdbcType="BIGINT" property="jid" />
    <result column="sid" jdbcType="BIGINT" property="sid" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from scores
    where cid = #{cid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into scores (cid, score, jid, 
      sid)
    values (#{cid,jdbcType=BIGINT}, #{score,jdbcType=INTEGER}, #{jid,jdbcType=BIGINT}, 
      #{sid,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update scores
    set score = #{score,jdbcType=INTEGER},
      jid = #{jid,jdbcType=BIGINT},
      sid = #{sid,jdbcType=BIGINT}
    where cid = #{cid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select cid, score, jid, sid
    from scores
    where cid = #{cid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select cid, score, jid, sid
    from scores
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="cid" jdbcType="INTEGER" property="cid" />
    <result column="title" jdbcType="VARCHAR" property="title" />
    <result column="titlePic" jdbcType="VARCHAR" property="titlepic" />
    <result column="slug" jdbcType="VARCHAR" property="slug" />
    <result column="created" jdbcType="INTEGER" property="created" />
    <result column="modified" jdbcType="INTEGER" property="modified" />
    <result column="authorId" jdbcType="INTEGER" property="authorid" />
    <result column="type" jdbcType="VARCHAR" property="type" />
    <result column="status" jdbcType="VARCHAR" property="status" />
    <result column="tags" jdbcType="VARCHAR" property="tags" />
    <result column="categories" jdbcType="VARCHAR" property="categories" />
    <result column="hits" jdbcType="INTEGER" property="hits" />
    <result column="commentsNum" jdbcType="INTEGER" property="commentsnum" />
    <result column="allowComment" jdbcType="BIT" property="allowcomment" />
    <result column="allowPing" jdbcType="BIT" property="allowping" />
    <result column="allowFeed" jdbcType="BIT" property="allowfeed" />
    <result column="content" jdbcType="LONGVARCHAR" property="content" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from t_contents
    where cid = #{cid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into t_contents (cid, title, titlePic, 
      slug, created, modified, 
      authorId, type, status, 
      tags, categories, hits, 
      commentsNum, allowComment, allowPing, 
      allowFeed, content)
    values (#{cid,jdbcType=INTEGER}, #{title,jdbcType=VARCHAR}, #{titlepic,jdbcType=VARCHAR}, 
      #{slug,jdbcType=VARCHAR}, #{created,jdbcType=INTEGER}, #{modified,jdbcType=INTEGER}, 
      #{authorid,jdbcType=INTEGER}, #{type,jdbcType=VARCHAR}, #{status,jdbcType=VARCHAR}, 
      #{tags,jdbcType=VARCHAR}, #{categories,jdbcType=VARCHAR}, #{hits,jdbcType=INTEGER}, 
      #{commentsnum,jdbcType=INTEGER}, #{allowcomment,jdbcType=BIT}, #{allowping,jdbcType=BIT}, 
      #{allowfeed,jdbcType=BIT}, #{content,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update t_contents
    set title = #{title,jdbcType=VARCHAR},
      titlePic = #{titlepic,jdbcType=VARCHAR},
      slug = #{slug,jdbcType=VARCHAR},
      created = #{created,jdbcType=INTEGER},
      modified = #{modified,jdbcType=INTEGER},
      authorId = #{authorid,jdbcType=INTEGER},
      type = #{type,jdbcType=VARCHAR},
      status = #{status,jdbcType=VARCHAR},
      tags = #{tags,jdbcType=VARCHAR},
      categories = #{categories,jdbcType=VARCHAR},
      hits = #{hits,jdbcType=INTEGER},
      commentsNum = #{commentsnum,jdbcType=INTEGER},
      allowComment = #{allowcomment,jdbcType=BIT},
      allowPing = #{allowping,jdbcType=BIT},
      allowFeed = #{allowfeed,jdbcType=BIT},
      content = #{content,jdbcType=LONGVARCHAR}
    where cid = #{cid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select cid, title, titlePic, slug, created, modified, authorId, type, status, tags, 
    categories, hits, commentsNum, allowComment, allowPing, allowFeed, content
    from t_contents
    where cid = #{cid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select cid, title, titlePic, slug, created, modified, authorId, type, status, tags, 
    categories, hits, commentsNum, allowComment, allowPing, allowFeed, content
    from t_contents
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="ENGINE" jdbcType="VARCHAR" property="engine" />
    <result column="SUPPORT" jdbcType="VARCHAR" property="support" />
    <result column="COMMENT" jdbcType="VARCHAR" property="comment" />
    <result column="TRANSACTIONS" jdbcType="VARCHAR" property="transactions" />
    <result column="XA" jdbcType="VARCHAR" property="xa" />
    <result column="SAVEPOINTS" jdbcType="VARCHAR" property="savepoints" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into ENGINES (ENGINE, SUPPORT, COMMENT, 
      TRANSACTIONS, XA, SAVEPOINTS
      )
    values (#{engine,jdbcType=VARCHAR}, #{support,jdbcType=VARCHAR}, #{comment,jdbcType=VARCHAR}, 
      #{transactions,jdbcType=VARCHAR}, #{xa,jdbcType=VARCHAR}, #{savepoints,jdbcType=VARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select ENGINE, SUPPORT, COMMENT, TRANSACTIONS, XA, SAVEPOINTS
    from ENGINES
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="CONSTRAINT_CATALOG" jdbcType="VARCHAR" property="constraintCatalog" />
    <result column="CONSTRAINT_SCHEMA" jdbcType="VARCHAR" property="constraintSchema" />
    <result column="CONSTRAINT_NAME" jdbcType="VARCHAR" property="constraintName" />
    <result column="UNIQUE_CONSTRAINT_CATALOG" jdbcType="VARCHAR" property="uniqueConstraintCatalog" />
    <result column="UNIQUE_CONSTRAINT_SCHEMA" jdbcType="VARCHAR" property="uniqueConstraintSchema" />
    <result column="UNIQUE_CONSTRAINT_NAME" jdbcType="VARCHAR" property="uniqueConstraintName" />
    <result column="MATCH_OPTION" jdbcType="CHAR" property="matchOption" />
    <result column="UPDATE_RULE" jdbcType="CHAR" property="updateRule" />
    <result column="DELETE_RULE" jdbcType="CHAR" property="deleteRule" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
    <result column="REFERENCED_TABLE_NAME" jdbcType="VARCHAR" property="referencedTableName" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into REFERENTIAL_CONSTRAINTS (CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA, 
      CONSTRAINT_NAME, UNIQUE_CONSTRAINT_CATALOG, 
      UNIQUE_CONSTRAINT_SCHEMA, UNIQUE_CONSTRAINT_NAME, 
      MATCH_OPTION, UPDATE_RULE, DELETE_RULE, 
      TABLE_NAME, REFERENCED_TABLE_NAME)
    values (#{constraintCatalog,jdbcType=VARCHAR}, #{constraintSchema,jdbcType=VARCHAR}, 
      #{constraintName,jdbcType=VARCHAR}, #{uniqueConstraintCatalog,jdbcType=VARCHAR}, 
      #{uniqueConstraintSchema,jdbcType=VARCHAR}, #{uniqueConstraintName,jdbcType=VARCHAR}, 
      #{matchOption,jdbcType=CHAR}, #{updateRule,jdbcType=CHAR}, #{deleteRule,jdbcType=CHAR}, 
      #{tableName,jdbcType=VARCHAR}, #{referencedTableName,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA, CONSTRAINT_NAME, UNIQUE_CONSTRAINT_CATALOG, 
    UNIQUE_CONSTRAINT_SCHEMA, UNIQUE_CONSTRAINT_NAME, MATCH_OPTION, UPDATE_RULE, DELETE_RULE, 
    TABLE_NAME, REFERENCED_TABLE_NAME
    from REFERENTIAL_CONSTRAINTS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="total" jdbcType="DECIMAL" property="total" />
    <result column="rows_sent" jdbcType="DECIMAL" property="rowsSent" />
    <result column="rows_examined" jdbcType="DECIMAL" property="rowsExamined" />
    <result column="rows_affected" jdbcType="DECIMAL" property="rowsAffected" />
    <result column="full_scans" jdbcType="DECIMAL" property="fullScans" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
    <result column="lock_latency" jdbcType="LONGVARCHAR" property="lockLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into host_summary_by_statement_latency (host, total, rows_sent, 
      rows_examined, rows_affected, full_scans, 
      total_latency, max_latency, lock_latency
      )
    values (#{host,jdbcType=VARCHAR}, #{total,jdbcType=DECIMAL}, #{rowsSent,jdbcType=DECIMAL}, 
      #{rowsExamined,jdbcType=DECIMAL}, #{rowsAffected,jdbcType=DECIMAL}, #{fullScans,jdbcType=DECIMAL}, 
      #{totalLatency,jdbcType=LONGVARCHAR}, #{maxLatency,jdbcType=LONGVARCHAR}, #{lockLatency,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, total, rows_sent, rows_examined, rows_affected, full_scans, total_latency, 
    max_latency, lock_latency
    from host_summary_by_statement_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="EVENT_ID" jdbcType="BIGINT" property="eventId" />
    <result column="END_EVENT_ID" jdbcType="BIGINT" property="endEventId" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="STATE" jdbcType="CHAR" property="state" />
    <result column="TRX_ID" jdbcType="BIGINT" property="trxId" />
    <result column="GTID" jdbcType="VARCHAR" property="gtid" />
    <result column="XID_FORMAT_ID" jdbcType="INTEGER" property="xidFormatId" />
    <result column="XID_GTRID" jdbcType="VARCHAR" property="xidGtrid" />
    <result column="XID_BQUAL" jdbcType="VARCHAR" property="xidBqual" />
    <result column="XA_STATE" jdbcType="VARCHAR" property="xaState" />
    <result column="SOURCE" jdbcType="VARCHAR" property="source" />
    <result column="TIMER_START" jdbcType="BIGINT" property="timerStart" />
    <result column="TIMER_END" jdbcType="BIGINT" property="timerEnd" />
    <result column="TIMER_WAIT" jdbcType="BIGINT" property="timerWait" />
    <result column="ACCESS_MODE" jdbcType="CHAR" property="accessMode" />
    <result column="ISOLATION_LEVEL" jdbcType="VARCHAR" property="isolationLevel" />
    <result column="AUTOCOMMIT" jdbcType="CHAR" property="autocommit" />
    <result column="NUMBER_OF_SAVEPOINTS" jdbcType="BIGINT" property="numberOfSavepoints" />
    <result column="NUMBER_OF_ROLLBACK_TO_SAVEPOINT" jdbcType="BIGINT" property="numberOfRollbackToSavepoint" />
    <result column="NUMBER_OF_RELEASE_SAVEPOINT" jdbcType="BIGINT" property="numberOfReleaseSavepoint" />
    <result column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="NESTING_EVENT_ID" jdbcType="BIGINT" property="nestingEventId" />
    <result column="NESTING_EVENT_TYPE" jdbcType="CHAR" property="nestingEventType" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from events_transactions_history
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_transactions_history (THREAD_ID, EVENT_ID, END_EVENT_ID, 
      EVENT_NAME, STATE, TRX_ID, 
      GTID, XID_FORMAT_ID, XID_GTRID, 
      XID_BQUAL, XA_STATE, SOURCE, 
      TIMER_START, TIMER_END, TIMER_WAIT, 
      ACCESS_MODE, ISOLATION_LEVEL, AUTOCOMMIT, 
      NUMBER_OF_SAVEPOINTS, NUMBER_OF_ROLLBACK_TO_SAVEPOINT, 
      NUMBER_OF_RELEASE_SAVEPOINT, OBJECT_INSTANCE_BEGIN, 
      NESTING_EVENT_ID, NESTING_EVENT_TYPE)
    values (#{threadId,jdbcType=BIGINT}, #{eventId,jdbcType=BIGINT}, #{endEventId,jdbcType=BIGINT}, 
      #{eventName,jdbcType=VARCHAR}, #{state,jdbcType=CHAR}, #{trxId,jdbcType=BIGINT}, 
      #{gtid,jdbcType=VARCHAR}, #{xidFormatId,jdbcType=INTEGER}, #{xidGtrid,jdbcType=VARCHAR}, 
      #{xidBqual,jdbcType=VARCHAR}, #{xaState,jdbcType=VARCHAR}, #{source,jdbcType=VARCHAR}, 
      #{timerStart,jdbcType=BIGINT}, #{timerEnd,jdbcType=BIGINT}, #{timerWait,jdbcType=BIGINT}, 
      #{accessMode,jdbcType=CHAR}, #{isolationLevel,jdbcType=VARCHAR}, #{autocommit,jdbcType=CHAR}, 
      #{numberOfSavepoints,jdbcType=BIGINT}, #{numberOfRollbackToSavepoint,jdbcType=BIGINT}, 
      #{numberOfReleaseSavepoint,jdbcType=BIGINT}, #{objectInstanceBegin,jdbcType=BIGINT}, 
      #{nestingEventId,jdbcType=BIGINT}, #{nestingEventType,jdbcType=CHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_transactions_history
    set END_EVENT_ID = #{endEventId,jdbcType=BIGINT},
      EVENT_NAME = #{eventName,jdbcType=VARCHAR},
      STATE = #{state,jdbcType=CHAR},
      TRX_ID = #{trxId,jdbcType=BIGINT},
      GTID = #{gtid,jdbcType=VARCHAR},
      XID_FORMAT_ID = #{xidFormatId,jdbcType=INTEGER},
      XID_GTRID = #{xidGtrid,jdbcType=VARCHAR},
      XID_BQUAL = #{xidBqual,jdbcType=VARCHAR},
      XA_STATE = #{xaState,jdbcType=VARCHAR},
      SOURCE = #{source,jdbcType=VARCHAR},
      TIMER_START = #{timerStart,jdbcType=BIGINT},
      TIMER_END = #{timerEnd,jdbcType=BIGINT},
      TIMER_WAIT = #{timerWait,jdbcType=BIGINT},
      ACCESS_MODE = #{accessMode,jdbcType=CHAR},
      ISOLATION_LEVEL = #{isolationLevel,jdbcType=VARCHAR},
      AUTOCOMMIT = #{autocommit,jdbcType=CHAR},
      NUMBER_OF_SAVEPOINTS = #{numberOfSavepoints,jdbcType=BIGINT},
      NUMBER_OF_ROLLBACK_TO_SAVEPOINT = #{numberOfRollbackToSavepoint,jdbcType=BIGINT},
      NUMBER_OF_RELEASE_SAVEPOINT = #{numberOfReleaseSavepoint,jdbcType=BIGINT},
      OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT},
      NESTING_EVENT_ID = #{nestingEventId,jdbcType=BIGINT},
      NESTING_EVENT_TYPE = #{nestingEventType,jdbcType=CHAR}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, STATE, TRX_ID, GTID, XID_FORMAT_ID, 
    XID_GTRID, XID_BQUAL, XA_STATE, SOURCE, TIMER_START, TIMER_END, TIMER_WAIT, ACCESS_MODE, 
    ISOLATION_LEVEL, AUTOCOMMIT, NUMBER_OF_SAVEPOINTS, NUMBER_OF_ROLLBACK_TO_SAVEPOINT, 
    NUMBER_OF_RELEASE_SAVEPOINT, OBJECT_INSTANCE_BEGIN, NESTING_EVENT_ID, NESTING_EVENT_TYPE
    from events_transactions_history
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, STATE, TRX_ID, GTID, XID_FORMAT_ID, 
    XID_GTRID, XID_BQUAL, XA_STATE, SOURCE, TIMER_START, TIMER_END, TIMER_WAIT, ACCESS_MODE, 
    ISOLATION_LEVEL, AUTOCOMMIT, NUMBER_OF_SAVEPOINTS, NUMBER_OF_ROLLBACK_TO_SAVEPOINT, 
    NUMBER_OF_RELEASE_SAVEPOINT, OBJECT_INSTANCE_BEGIN, NESTING_EVENT_ID, NESTING_EVENT_TYPE
    from events_transactions_history
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="CHANNEL_NAME" jdbcType="CHAR" property="channelName" />
    <result column="MEMBER_ID" jdbcType="CHAR" property="memberId" />
    <result column="MEMBER_HOST" jdbcType="CHAR" property="memberHost" />
    <result column="MEMBER_PORT" jdbcType="INTEGER" property="memberPort" />
    <result column="MEMBER_STATE" jdbcType="CHAR" property="memberState" />
    <result column="MEMBER_ROLE" jdbcType="CHAR" property="memberRole" />
    <result column="MEMBER_VERSION" jdbcType="CHAR" property="memberVersion" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into replication_group_members (CHANNEL_NAME, MEMBER_ID, MEMBER_HOST, 
      MEMBER_PORT, MEMBER_STATE, MEMBER_ROLE, 
      MEMBER_VERSION)
    values (#{channelName,jdbcType=CHAR}, #{memberId,jdbcType=CHAR}, #{memberHost,jdbcType=CHAR}, 
      #{memberPort,jdbcType=INTEGER}, #{memberState,jdbcType=CHAR}, #{memberRole,jdbcType=CHAR}, 
      #{memberVersion,jdbcType=CHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select CHANNEL_NAME, MEMBER_ID, MEMBER_HOST, MEMBER_PORT, MEMBER_STATE, MEMBER_ROLE, 
    MEMBER_VERSION
    from replication_group_members
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="exec_count" jdbcType="BIGINT" property="execCount" />
    <result column="errors" jdbcType="BIGINT" property="errors" />
    <result column="error_pct" jdbcType="DECIMAL" property="errorPct" />
    <result column="warnings" jdbcType="BIGINT" property="warnings" />
    <result column="warning_pct" jdbcType="DECIMAL" property="warningPct" />
    <result column="first_seen" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="last_seen" jdbcType="TIMESTAMP" property="lastSeen" />
    <result column="digest" jdbcType="VARCHAR" property="digest" />
    <result column="query" jdbcType="LONGVARCHAR" property="query" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into statements_with_errors_or_warnings (db, exec_count, errors, 
      error_pct, warnings, warning_pct, 
      first_seen, last_seen, digest, 
      query)
    values (#{db,jdbcType=VARCHAR}, #{execCount,jdbcType=BIGINT}, #{errors,jdbcType=BIGINT}, 
      #{errorPct,jdbcType=DECIMAL}, #{warnings,jdbcType=BIGINT}, #{warningPct,jdbcType=DECIMAL}, 
      #{firstSeen,jdbcType=TIMESTAMP}, #{lastSeen,jdbcType=TIMESTAMP}, #{digest,jdbcType=VARCHAR}, 
      #{query,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select db, exec_count, errors, error_pct, warnings, warning_pct, first_seen, last_seen, 
    digest, query
    from statements_with_errors_or_warnings
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="did" jdbcType="VARCHAR" property="did" />
    <result column="dealnum" jdbcType="VARCHAR" property="dealnum" />
    <result column="uid" jdbcType="INTEGER" property="uid" />
    <result column="pid" jdbcType="INTEGER" property="pid" />
    <result column="num" jdbcType="INTEGER" property="num" />
    <result column="times" jdbcType="TIMESTAMP" property="times" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from indent
    where did = #{did,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into indent (did, dealnum, uid, 
      pid, num, times)
    values (#{did,jdbcType=VARCHAR}, #{dealnum,jdbcType=VARCHAR}, #{uid,jdbcType=INTEGER}, 
      #{pid,jdbcType=INTEGER}, #{num,jdbcType=INTEGER}, #{times,jdbcType=TIMESTAMP})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update indent
    set dealnum = #{dealnum,jdbcType=VARCHAR},
      uid = #{uid,jdbcType=INTEGER},
      pid = #{pid,jdbcType=INTEGER},
      num = #{num,jdbcType=INTEGER},
      times = #{times,jdbcType=TIMESTAMP}
    where did = #{did,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select did, dealnum, uid, pid, num, times
    from indent
    where did = #{did,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select did, dealnum, uid, pid, num, times
    from indent
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="mid" jdbcType="INTEGER" property="mid" />
    <result column="name" jdbcType="VARCHAR" property="name" />
    <result column="slug" jdbcType="VARCHAR" property="slug" />
    <result column="type" jdbcType="VARCHAR" property="type" />
    <result column="contentType" jdbcType="VARCHAR" property="contenttype" />
    <result column="description" jdbcType="VARCHAR" property="description" />
    <result column="sort" jdbcType="INTEGER" property="sort" />
    <result column="parent" jdbcType="INTEGER" property="parent" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from t_metas
    where mid = #{mid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into t_metas (mid, name, slug, 
      type, contentType, description, 
      sort, parent)
    values (#{mid,jdbcType=INTEGER}, #{name,jdbcType=VARCHAR}, #{slug,jdbcType=VARCHAR}, 
      #{type,jdbcType=VARCHAR}, #{contenttype,jdbcType=VARCHAR}, #{description,jdbcType=VARCHAR}, 
      #{sort,jdbcType=INTEGER}, #{parent,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update t_metas
    set name = #{name,jdbcType=VARCHAR},
      slug = #{slug,jdbcType=VARCHAR},
      type = #{type,jdbcType=VARCHAR},
      contentType = #{contenttype,jdbcType=VARCHAR},
      description = #{description,jdbcType=VARCHAR},
      sort = #{sort,jdbcType=INTEGER},
      parent = #{parent,jdbcType=INTEGER}
    where mid = #{mid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select mid, name, slug, type, contentType, description, sort, parent
    from t_metas
    where mid = #{mid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select mid, name, slug, type, contentType, description, sort, parent
    from t_metas
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="PLUGIN_NAME" jdbcType="VARCHAR" property="pluginName" />
    <result column="PLUGIN_VERSION" jdbcType="VARCHAR" property="pluginVersion" />
    <result column="PLUGIN_STATUS" jdbcType="VARCHAR" property="pluginStatus" />
    <result column="PLUGIN_TYPE" jdbcType="VARCHAR" property="pluginType" />
    <result column="PLUGIN_TYPE_VERSION" jdbcType="VARCHAR" property="pluginTypeVersion" />
    <result column="PLUGIN_LIBRARY" jdbcType="VARCHAR" property="pluginLibrary" />
    <result column="PLUGIN_LIBRARY_VERSION" jdbcType="VARCHAR" property="pluginLibraryVersion" />
    <result column="PLUGIN_AUTHOR" jdbcType="VARCHAR" property="pluginAuthor" />
    <result column="PLUGIN_DESCRIPTION" jdbcType="VARCHAR" property="pluginDescription" />
    <result column="PLUGIN_LICENSE" jdbcType="VARCHAR" property="pluginLicense" />
    <result column="LOAD_OPTION" jdbcType="VARCHAR" property="loadOption" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into PLUGINS (PLUGIN_NAME, PLUGIN_VERSION, PLUGIN_STATUS, 
      PLUGIN_TYPE, PLUGIN_TYPE_VERSION, PLUGIN_LIBRARY, 
      PLUGIN_LIBRARY_VERSION, PLUGIN_AUTHOR, PLUGIN_DESCRIPTION, 
      PLUGIN_LICENSE, LOAD_OPTION)
    values (#{pluginName,jdbcType=VARCHAR}, #{pluginVersion,jdbcType=VARCHAR}, #{pluginStatus,jdbcType=VARCHAR}, 
      #{pluginType,jdbcType=VARCHAR}, #{pluginTypeVersion,jdbcType=VARCHAR}, #{pluginLibrary,jdbcType=VARCHAR}, 
      #{pluginLibraryVersion,jdbcType=VARCHAR}, #{pluginAuthor,jdbcType=VARCHAR}, #{pluginDescription,jdbcType=VARCHAR}, 
      #{pluginLicense,jdbcType=VARCHAR}, #{loadOption,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select PLUGIN_NAME, PLUGIN_VERSION, PLUGIN_STATUS, PLUGIN_TYPE, PLUGIN_TYPE_VERSION, 
    PLUGIN_LIBRARY, PLUGIN_LIBRARY_VERSION, PLUGIN_AUTHOR, PLUGIN_DESCRIPTION, PLUGIN_LICENSE, 
    LOAD_OPTION
    from PLUGINS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from events_waits_summary_by_instance
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_waits_summary_by_instance (OBJECT_INSTANCE_BEGIN, EVENT_NAME, COUNT_STAR, 
      SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
      MAX_TIMER_WAIT)
    values (#{objectInstanceBegin,jdbcType=BIGINT}, #{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, 
      #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, 
      #{maxTimerWait,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_waits_summary_by_instance
    set EVENT_NAME = #{eventName,jdbcType=VARCHAR},
      COUNT_STAR = #{countStar,jdbcType=BIGINT},
      SUM_TIMER_WAIT = #{sumTimerWait,jdbcType=BIGINT},
      MIN_TIMER_WAIT = #{minTimerWait,jdbcType=BIGINT},
      AVG_TIMER_WAIT = #{avgTimerWait,jdbcType=BIGINT},
      MAX_TIMER_WAIT = #{maxTimerWait,jdbcType=BIGINT}
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
    AVG_TIMER_WAIT, MAX_TIMER_WAIT
    from events_waits_summary_by_instance
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
    AVG_TIMER_WAIT, MAX_TIMER_WAIT
    from events_waits_summary_by_instance
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="EVENT_ID" jdbcType="BIGINT" property="eventId" />
    <result column="END_EVENT_ID" jdbcType="BIGINT" property="endEventId" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="SOURCE" jdbcType="VARCHAR" property="source" />
    <result column="TIMER_START" jdbcType="BIGINT" property="timerStart" />
    <result column="TIMER_END" jdbcType="BIGINT" property="timerEnd" />
    <result column="TIMER_WAIT" jdbcType="BIGINT" property="timerWait" />
    <result column="WORK_COMPLETED" jdbcType="BIGINT" property="workCompleted" />
    <result column="WORK_ESTIMATED" jdbcType="BIGINT" property="workEstimated" />
    <result column="NESTING_EVENT_ID" jdbcType="BIGINT" property="nestingEventId" />
    <result column="NESTING_EVENT_TYPE" jdbcType="CHAR" property="nestingEventType" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from events_stages_history
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_stages_history (THREAD_ID, EVENT_ID, END_EVENT_ID, 
      EVENT_NAME, SOURCE, TIMER_START, 
      TIMER_END, TIMER_WAIT, WORK_COMPLETED, 
      WORK_ESTIMATED, NESTING_EVENT_ID, NESTING_EVENT_TYPE
      )
    values (#{threadId,jdbcType=BIGINT}, #{eventId,jdbcType=BIGINT}, #{endEventId,jdbcType=BIGINT}, 
      #{eventName,jdbcType=VARCHAR}, #{source,jdbcType=VARCHAR}, #{timerStart,jdbcType=BIGINT}, 
      #{timerEnd,jdbcType=BIGINT}, #{timerWait,jdbcType=BIGINT}, #{workCompleted,jdbcType=BIGINT}, 
      #{workEstimated,jdbcType=BIGINT}, #{nestingEventId,jdbcType=BIGINT}, #{nestingEventType,jdbcType=CHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_stages_history
    set END_EVENT_ID = #{endEventId,jdbcType=BIGINT},
      EVENT_NAME = #{eventName,jdbcType=VARCHAR},
      SOURCE = #{source,jdbcType=VARCHAR},
      TIMER_START = #{timerStart,jdbcType=BIGINT},
      TIMER_END = #{timerEnd,jdbcType=BIGINT},
      TIMER_WAIT = #{timerWait,jdbcType=BIGINT},
      WORK_COMPLETED = #{workCompleted,jdbcType=BIGINT},
      WORK_ESTIMATED = #{workEstimated,jdbcType=BIGINT},
      NESTING_EVENT_ID = #{nestingEventId,jdbcType=BIGINT},
      NESTING_EVENT_TYPE = #{nestingEventType,jdbcType=CHAR}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, SOURCE, TIMER_START, TIMER_END, 
    TIMER_WAIT, WORK_COMPLETED, WORK_ESTIMATED, NESTING_EVENT_ID, NESTING_EVENT_TYPE
    from events_stages_history
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, SOURCE, TIMER_START, TIMER_END, 
    TIMER_WAIT, WORK_COMPLETED, WORK_ESTIMATED, NESTING_EVENT_ID, NESTING_EVENT_TYPE
    from events_stages_history
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="gid" jdbcType="BIGINT" property="gid" />
    <result column="target" jdbcType="VARCHAR" property="target" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from contexttag
    where gid = #{gid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into contexttag (gid, target)
    values (#{gid,jdbcType=BIGINT}, #{target,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update contexttag
    set target = #{target,jdbcType=VARCHAR}
    where gid = #{gid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select gid, target
    from contexttag
    where gid = #{gid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select gid, target
    from contexttag
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="event_name" jdbcType="VARCHAR" property="eventName" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="latency" jdbcType="BIGINT" property="latency" />
    <result column="max_latency" jdbcType="BIGINT" property="maxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$user_summary_by_file_io_type (user, event_name, total, 
      latency, max_latency)
    values (#{user,jdbcType=VARCHAR}, #{eventName,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{latency,jdbcType=BIGINT}, #{maxLatency,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, event_name, total, latency, max_latency
    from x$user_summary_by_file_io_type
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="exec_count" jdbcType="BIGINT" property="execCount" />
    <result column="no_index_used_count" jdbcType="BIGINT" property="noIndexUsedCount" />
    <result column="no_good_index_used_count" jdbcType="BIGINT" property="noGoodIndexUsedCount" />
    <result column="no_index_used_pct" jdbcType="DECIMAL" property="noIndexUsedPct" />
    <result column="rows_sent" jdbcType="BIGINT" property="rowsSent" />
    <result column="rows_examined" jdbcType="BIGINT" property="rowsExamined" />
    <result column="rows_sent_avg" jdbcType="DECIMAL" property="rowsSentAvg" />
    <result column="rows_examined_avg" jdbcType="DECIMAL" property="rowsExaminedAvg" />
    <result column="first_seen" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="last_seen" jdbcType="TIMESTAMP" property="lastSeen" />
    <result column="digest" jdbcType="VARCHAR" property="digest" />
    <result column="query" jdbcType="LONGVARCHAR" property="query" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into statements_with_full_table_scans (db, exec_count, no_index_used_count, 
      no_good_index_used_count, no_index_used_pct, rows_sent, 
      rows_examined, rows_sent_avg, rows_examined_avg, 
      first_seen, last_seen, digest, 
      query, total_latency)
    values (#{db,jdbcType=VARCHAR}, #{execCount,jdbcType=BIGINT}, #{noIndexUsedCount,jdbcType=BIGINT}, 
      #{noGoodIndexUsedCount,jdbcType=BIGINT}, #{noIndexUsedPct,jdbcType=DECIMAL}, #{rowsSent,jdbcType=BIGINT}, 
      #{rowsExamined,jdbcType=BIGINT}, #{rowsSentAvg,jdbcType=DECIMAL}, #{rowsExaminedAvg,jdbcType=DECIMAL}, 
      #{firstSeen,jdbcType=TIMESTAMP}, #{lastSeen,jdbcType=TIMESTAMP}, #{digest,jdbcType=VARCHAR}, 
      #{query,jdbcType=LONGVARCHAR}, #{totalLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select db, exec_count, no_index_used_count, no_good_index_used_count, no_index_used_pct, 
    rows_sent, rows_examined, rows_sent_avg, rows_examined_avg, first_seen, last_seen, 
    digest, query, total_latency
    from statements_with_full_table_scans
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="event_name" jdbcType="VARCHAR" property="eventName" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="avg_latency" jdbcType="LONGVARCHAR" property="avgLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into host_summary_by_stages (host, event_name, total, 
      total_latency, avg_latency)
    values (#{host,jdbcType=VARCHAR}, #{eventName,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{totalLatency,jdbcType=LONGVARCHAR}, #{avgLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, event_name, total, total_latency, avg_latency
    from host_summary_by_stages
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_stages_summary_by_account_by_event_name (USER, HOST, EVENT_NAME, 
      COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
      AVG_TIMER_WAIT, MAX_TIMER_WAIT)
    values (#{user,jdbcType=CHAR}, #{host,jdbcType=CHAR}, #{eventName,jdbcType=VARCHAR}, 
      #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, 
      #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, HOST, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT
    from events_stages_summary_by_account_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="SPACE" jdbcType="INTEGER" property="space" />
    <result column="NAME" jdbcType="VARCHAR" property="name" />
    <result column="FLAG" jdbcType="INTEGER" property="flag" />
    <result column="ROW_FORMAT" jdbcType="VARCHAR" property="rowFormat" />
    <result column="PAGE_SIZE" jdbcType="INTEGER" property="pageSize" />
    <result column="ZIP_PAGE_SIZE" jdbcType="INTEGER" property="zipPageSize" />
    <result column="SPACE_TYPE" jdbcType="VARCHAR" property="spaceType" />
    <result column="FS_BLOCK_SIZE" jdbcType="INTEGER" property="fsBlockSize" />
    <result column="FILE_SIZE" jdbcType="BIGINT" property="fileSize" />
    <result column="ALLOCATED_SIZE" jdbcType="BIGINT" property="allocatedSize" />
    <result column="SERVER_VERSION" jdbcType="VARCHAR" property="serverVersion" />
    <result column="SPACE_VERSION" jdbcType="INTEGER" property="spaceVersion" />
    <result column="ENCRYPTION" jdbcType="VARCHAR" property="encryption" />
    <result column="STATE" jdbcType="VARCHAR" property="state" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_TABLESPACES (SPACE, NAME, FLAG, 
      ROW_FORMAT, PAGE_SIZE, ZIP_PAGE_SIZE, 
      SPACE_TYPE, FS_BLOCK_SIZE, FILE_SIZE, 
      ALLOCATED_SIZE, SERVER_VERSION, SPACE_VERSION, 
      ENCRYPTION, STATE)
    values (#{space,jdbcType=INTEGER}, #{name,jdbcType=VARCHAR}, #{flag,jdbcType=INTEGER}, 
      #{rowFormat,jdbcType=VARCHAR}, #{pageSize,jdbcType=INTEGER}, #{zipPageSize,jdbcType=INTEGER}, 
      #{spaceType,jdbcType=VARCHAR}, #{fsBlockSize,jdbcType=INTEGER}, #{fileSize,jdbcType=BIGINT}, 
      #{allocatedSize,jdbcType=BIGINT}, #{serverVersion,jdbcType=VARCHAR}, #{spaceVersion,jdbcType=INTEGER}, 
      #{encryption,jdbcType=VARCHAR}, #{state,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select SPACE, NAME, FLAG, ROW_FORMAT, PAGE_SIZE, ZIP_PAGE_SIZE, SPACE_TYPE, FS_BLOCK_SIZE, 
    FILE_SIZE, ALLOCATED_SIZE, SERVER_VERSION, SPACE_VERSION, ENCRYPTION, STATE
    from INNODB_TABLESPACES
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Time_zone_id" jdbcType="INTEGER" property="timeZoneId" />
    <id column="Transition_time" jdbcType="BIGINT" property="transitionTime" />
    <result column="Transition_type_id" jdbcType="INTEGER" property="transitionTypeId" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from time_zone_transition
    where Time_zone_id = #{timeZoneId,jdbcType=INTEGER}
      and Transition_time = #{transitionTime,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into time_zone_transition (Time_zone_id, Transition_time, Transition_type_id
      )
    values (#{timeZoneId,jdbcType=INTEGER}, #{transitionTime,jdbcType=BIGINT}, #{transitionTypeId,jdbcType=INTEGER}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update time_zone_transition
    set Transition_type_id = #{transitionTypeId,jdbcType=INTEGER}
    where Time_zone_id = #{timeZoneId,jdbcType=INTEGER}
      and Transition_time = #{transitionTime,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select Time_zone_id, Transition_time, Transition_type_id
    from time_zone_transition
    where Time_zone_id = #{timeZoneId,jdbcType=INTEGER}
      and Transition_time = #{transitionTime,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Time_zone_id, Transition_time, Transition_type_id
    from time_zone_transition
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="COUNT_READ" jdbcType="BIGINT" property="countRead" />
    <result column="SUM_TIMER_READ" jdbcType="BIGINT" property="sumTimerRead" />
    <result column="MIN_TIMER_READ" jdbcType="BIGINT" property="minTimerRead" />
    <result column="AVG_TIMER_READ" jdbcType="BIGINT" property="avgTimerRead" />
    <result column="MAX_TIMER_READ" jdbcType="BIGINT" property="maxTimerRead" />
    <result column="SUM_NUMBER_OF_BYTES_READ" jdbcType="BIGINT" property="sumNumberOfBytesRead" />
    <result column="COUNT_WRITE" jdbcType="BIGINT" property="countWrite" />
    <result column="SUM_TIMER_WRITE" jdbcType="BIGINT" property="sumTimerWrite" />
    <result column="MIN_TIMER_WRITE" jdbcType="BIGINT" property="minTimerWrite" />
    <result column="AVG_TIMER_WRITE" jdbcType="BIGINT" property="avgTimerWrite" />
    <result column="MAX_TIMER_WRITE" jdbcType="BIGINT" property="maxTimerWrite" />
    <result column="SUM_NUMBER_OF_BYTES_WRITE" jdbcType="BIGINT" property="sumNumberOfBytesWrite" />
    <result column="COUNT_MISC" jdbcType="BIGINT" property="countMisc" />
    <result column="SUM_TIMER_MISC" jdbcType="BIGINT" property="sumTimerMisc" />
    <result column="MIN_TIMER_MISC" jdbcType="BIGINT" property="minTimerMisc" />
    <result column="AVG_TIMER_MISC" jdbcType="BIGINT" property="avgTimerMisc" />
    <result column="MAX_TIMER_MISC" jdbcType="BIGINT" property="maxTimerMisc" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from socket_summary_by_event_name
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into socket_summary_by_event_name (EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, 
      MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, 
      COUNT_READ, SUM_TIMER_READ, MIN_TIMER_READ, 
      AVG_TIMER_READ, MAX_TIMER_READ, SUM_NUMBER_OF_BYTES_READ, 
      COUNT_WRITE, SUM_TIMER_WRITE, MIN_TIMER_WRITE, 
      AVG_TIMER_WRITE, MAX_TIMER_WRITE, SUM_NUMBER_OF_BYTES_WRITE, 
      COUNT_MISC, SUM_TIMER_MISC, MIN_TIMER_MISC, 
      AVG_TIMER_MISC, MAX_TIMER_MISC)
    values (#{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, 
      #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT}, 
      #{countRead,jdbcType=BIGINT}, #{sumTimerRead,jdbcType=BIGINT}, #{minTimerRead,jdbcType=BIGINT}, 
      #{avgTimerRead,jdbcType=BIGINT}, #{maxTimerRead,jdbcType=BIGINT}, #{sumNumberOfBytesRead,jdbcType=BIGINT}, 
      #{countWrite,jdbcType=BIGINT}, #{sumTimerWrite,jdbcType=BIGINT}, #{minTimerWrite,jdbcType=BIGINT}, 
      #{avgTimerWrite,jdbcType=BIGINT}, #{maxTimerWrite,jdbcType=BIGINT}, #{sumNumberOfBytesWrite,jdbcType=BIGINT}, 
      #{countMisc,jdbcType=BIGINT}, #{sumTimerMisc,jdbcType=BIGINT}, #{minTimerMisc,jdbcType=BIGINT}, 
      #{avgTimerMisc,jdbcType=BIGINT}, #{maxTimerMisc,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update socket_summary_by_event_name
    set COUNT_STAR = #{countStar,jdbcType=BIGINT},
      SUM_TIMER_WAIT = #{sumTimerWait,jdbcType=BIGINT},
      MIN_TIMER_WAIT = #{minTimerWait,jdbcType=BIGINT},
      AVG_TIMER_WAIT = #{avgTimerWait,jdbcType=BIGINT},
      MAX_TIMER_WAIT = #{maxTimerWait,jdbcType=BIGINT},
      COUNT_READ = #{countRead,jdbcType=BIGINT},
      SUM_TIMER_READ = #{sumTimerRead,jdbcType=BIGINT},
      MIN_TIMER_READ = #{minTimerRead,jdbcType=BIGINT},
      AVG_TIMER_READ = #{avgTimerRead,jdbcType=BIGINT},
      MAX_TIMER_READ = #{maxTimerRead,jdbcType=BIGINT},
      SUM_NUMBER_OF_BYTES_READ = #{sumNumberOfBytesRead,jdbcType=BIGINT},
      COUNT_WRITE = #{countWrite,jdbcType=BIGINT},
      SUM_TIMER_WRITE = #{sumTimerWrite,jdbcType=BIGINT},
      MIN_TIMER_WRITE = #{minTimerWrite,jdbcType=BIGINT},
      AVG_TIMER_WRITE = #{avgTimerWrite,jdbcType=BIGINT},
      MAX_TIMER_WRITE = #{maxTimerWrite,jdbcType=BIGINT},
      SUM_NUMBER_OF_BYTES_WRITE = #{sumNumberOfBytesWrite,jdbcType=BIGINT},
      COUNT_MISC = #{countMisc,jdbcType=BIGINT},
      SUM_TIMER_MISC = #{sumTimerMisc,jdbcType=BIGINT},
      MIN_TIMER_MISC = #{minTimerMisc,jdbcType=BIGINT},
      AVG_TIMER_MISC = #{avgTimerMisc,jdbcType=BIGINT},
      MAX_TIMER_MISC = #{maxTimerMisc,jdbcType=BIGINT}
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, 
    COUNT_READ, SUM_TIMER_READ, MIN_TIMER_READ, AVG_TIMER_READ, MAX_TIMER_READ, SUM_NUMBER_OF_BYTES_READ, 
    COUNT_WRITE, SUM_TIMER_WRITE, MIN_TIMER_WRITE, AVG_TIMER_WRITE, MAX_TIMER_WRITE, 
    SUM_NUMBER_OF_BYTES_WRITE, COUNT_MISC, SUM_TIMER_MISC, MIN_TIMER_MISC, AVG_TIMER_MISC, 
    MAX_TIMER_MISC
    from socket_summary_by_event_name
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, 
    COUNT_READ, SUM_TIMER_READ, MIN_TIMER_READ, AVG_TIMER_READ, MAX_TIMER_READ, SUM_NUMBER_OF_BYTES_READ, 
    COUNT_WRITE, SUM_TIMER_WRITE, MIN_TIMER_WRITE, AVG_TIMER_WRITE, MAX_TIMER_WRITE, 
    SUM_NUMBER_OF_BYTES_WRITE, COUNT_MISC, SUM_TIMER_MISC, MIN_TIMER_MISC, AVG_TIMER_MISC, 
    MAX_TIMER_MISC
    from socket_summary_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="statement" jdbcType="VARCHAR" property="statement" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="max_latency" jdbcType="BIGINT" property="maxLatency" />
    <result column="lock_latency" jdbcType="BIGINT" property="lockLatency" />
    <result column="rows_sent" jdbcType="BIGINT" property="rowsSent" />
    <result column="rows_examined" jdbcType="BIGINT" property="rowsExamined" />
    <result column="rows_affected" jdbcType="BIGINT" property="rowsAffected" />
    <result column="full_scans" jdbcType="BIGINT" property="fullScans" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$host_summary_by_statement_type (host, statement, total, 
      total_latency, max_latency, lock_latency, 
      rows_sent, rows_examined, rows_affected, 
      full_scans)
    values (#{host,jdbcType=VARCHAR}, #{statement,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{totalLatency,jdbcType=BIGINT}, #{maxLatency,jdbcType=BIGINT}, #{lockLatency,jdbcType=BIGINT}, 
      #{rowsSent,jdbcType=BIGINT}, #{rowsExamined,jdbcType=BIGINT}, #{rowsAffected,jdbcType=BIGINT}, 
      #{fullScans,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, statement, total, total_latency, max_latency, lock_latency, rows_sent, 
    rows_examined, rows_affected, full_scans
    from x$host_summary_by_statement_type
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="CONSTRAINT_CATALOG" jdbcType="VARCHAR" property="constraintCatalog" />
    <result column="CONSTRAINT_SCHEMA" jdbcType="VARCHAR" property="constraintSchema" />
    <result column="CONSTRAINT_NAME" jdbcType="VARCHAR" property="constraintName" />
    <result column="CHECK_CLAUSE" jdbcType="LONGVARCHAR" property="checkClause" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into CHECK_CONSTRAINTS (CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA, 
      CONSTRAINT_NAME, CHECK_CLAUSE)
    values (#{constraintCatalog,jdbcType=VARCHAR}, #{constraintSchema,jdbcType=VARCHAR}, 
      #{constraintName,jdbcType=VARCHAR}, #{checkClause,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA, CONSTRAINT_NAME, CHECK_CLAUSE
    from CHECK_CONSTRAINTS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="uid" jdbcType="BIGINT" property="uid" />
    <result column="name" jdbcType="VARCHAR" property="name" />
    <result column="password" jdbcType="VARCHAR" property="password" />
    <result column="birthday" jdbcType="TIMESTAMP" property="birthday" />
    <result column="email" jdbcType="VARCHAR" property="email" />
    <result column="tel" jdbcType="VARCHAR" property="tel" />
    <result column="realname" jdbcType="VARCHAR" property="realname" />
    <result column="classes" jdbcType="BIGINT" property="classes" />
    <result column="taskid" jdbcType="BIGINT" property="taskid" />
    <result column="admin" jdbcType="BIGINT" property="admin" />
    <result column="version" jdbcType="INTEGER" property="version" />
    <result column="status" jdbcType="INTEGER" property="status" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from userinfo
    where uid = #{uid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into userinfo (uid, name, password, 
      birthday, email, tel, 
      realname, classes, taskid, 
      admin, version, status
      )
    values (#{uid,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{password,jdbcType=VARCHAR}, 
      #{birthday,jdbcType=TIMESTAMP}, #{email,jdbcType=VARCHAR}, #{tel,jdbcType=VARCHAR}, 
      #{realname,jdbcType=VARCHAR}, #{classes,jdbcType=BIGINT}, #{taskid,jdbcType=BIGINT}, 
      #{admin,jdbcType=BIGINT}, #{version,jdbcType=INTEGER}, #{status,jdbcType=INTEGER}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update userinfo
    set name = #{name,jdbcType=VARCHAR},
      password = #{password,jdbcType=VARCHAR},
      birthday = #{birthday,jdbcType=TIMESTAMP},
      email = #{email,jdbcType=VARCHAR},
      tel = #{tel,jdbcType=VARCHAR},
      realname = #{realname,jdbcType=VARCHAR},
      classes = #{classes,jdbcType=BIGINT},
      taskid = #{taskid,jdbcType=BIGINT},
      admin = #{admin,jdbcType=BIGINT},
      version = #{version,jdbcType=INTEGER},
      status = #{status,jdbcType=INTEGER}
    where uid = #{uid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select uid, name, password, birthday, email, tel, realname, classes, taskid, admin, 
    version, status
    from userinfo
    where uid = #{uid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select uid, name, password, birthday, email, tel, realname, classes, taskid, admin, 
    version, status
    from userinfo
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="statement" jdbcType="VARCHAR" property="statement" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="rows_sent" jdbcType="BIGINT" property="rowsSent" />
    <result column="rows_examined" jdbcType="BIGINT" property="rowsExamined" />
    <result column="rows_affected" jdbcType="BIGINT" property="rowsAffected" />
    <result column="full_scans" jdbcType="BIGINT" property="fullScans" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
    <result column="lock_latency" jdbcType="LONGVARCHAR" property="lockLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into host_summary_by_statement_type (host, statement, total, 
      rows_sent, rows_examined, rows_affected, 
      full_scans, total_latency, max_latency, 
      lock_latency)
    values (#{host,jdbcType=VARCHAR}, #{statement,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{rowsSent,jdbcType=BIGINT}, #{rowsExamined,jdbcType=BIGINT}, #{rowsAffected,jdbcType=BIGINT}, 
      #{fullScans,jdbcType=BIGINT}, #{totalLatency,jdbcType=LONGVARCHAR}, #{maxLatency,jdbcType=LONGVARCHAR}, 
      #{lockLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, statement, total, rows_sent, rows_examined, rows_affected, full_scans, 
    total_latency, max_latency, lock_latency
    from host_summary_by_statement_type
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_ALLOC" jdbcType="BIGINT" property="countAlloc" />
    <result column="COUNT_FREE" jdbcType="BIGINT" property="countFree" />
    <result column="SUM_NUMBER_OF_BYTES_ALLOC" jdbcType="BIGINT" property="sumNumberOfBytesAlloc" />
    <result column="SUM_NUMBER_OF_BYTES_FREE" jdbcType="BIGINT" property="sumNumberOfBytesFree" />
    <result column="LOW_COUNT_USED" jdbcType="BIGINT" property="lowCountUsed" />
    <result column="CURRENT_COUNT_USED" jdbcType="BIGINT" property="currentCountUsed" />
    <result column="HIGH_COUNT_USED" jdbcType="BIGINT" property="highCountUsed" />
    <result column="LOW_NUMBER_OF_BYTES_USED" jdbcType="BIGINT" property="lowNumberOfBytesUsed" />
    <result column="CURRENT_NUMBER_OF_BYTES_USED" jdbcType="BIGINT" property="currentNumberOfBytesUsed" />
    <result column="HIGH_NUMBER_OF_BYTES_USED" jdbcType="BIGINT" property="highNumberOfBytesUsed" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into memory_summary_by_host_by_event_name (HOST, EVENT_NAME, COUNT_ALLOC, 
      COUNT_FREE, SUM_NUMBER_OF_BYTES_ALLOC, SUM_NUMBER_OF_BYTES_FREE, 
      LOW_COUNT_USED, CURRENT_COUNT_USED, HIGH_COUNT_USED, 
      LOW_NUMBER_OF_BYTES_USED, CURRENT_NUMBER_OF_BYTES_USED, 
      HIGH_NUMBER_OF_BYTES_USED)
    values (#{host,jdbcType=CHAR}, #{eventName,jdbcType=VARCHAR}, #{countAlloc,jdbcType=BIGINT}, 
      #{countFree,jdbcType=BIGINT}, #{sumNumberOfBytesAlloc,jdbcType=BIGINT}, #{sumNumberOfBytesFree,jdbcType=BIGINT}, 
      #{lowCountUsed,jdbcType=BIGINT}, #{currentCountUsed,jdbcType=BIGINT}, #{highCountUsed,jdbcType=BIGINT}, 
      #{lowNumberOfBytesUsed,jdbcType=BIGINT}, #{currentNumberOfBytesUsed,jdbcType=BIGINT}, 
      #{highNumberOfBytesUsed,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select HOST, EVENT_NAME, COUNT_ALLOC, COUNT_FREE, SUM_NUMBER_OF_BYTES_ALLOC, SUM_NUMBER_OF_BYTES_FREE, 
    LOW_COUNT_USED, CURRENT_COUNT_USED, HIGH_COUNT_USED, LOW_NUMBER_OF_BYTES_USED, CURRENT_NUMBER_OF_BYTES_USED, 
    HIGH_NUMBER_OF_BYTES_USED
    from memory_summary_by_host_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="COUNT_READ_WRITE" jdbcType="BIGINT" property="countReadWrite" />
    <result column="SUM_TIMER_READ_WRITE" jdbcType="BIGINT" property="sumTimerReadWrite" />
    <result column="MIN_TIMER_READ_WRITE" jdbcType="BIGINT" property="minTimerReadWrite" />
    <result column="AVG_TIMER_READ_WRITE" jdbcType="BIGINT" property="avgTimerReadWrite" />
    <result column="MAX_TIMER_READ_WRITE" jdbcType="BIGINT" property="maxTimerReadWrite" />
    <result column="COUNT_READ_ONLY" jdbcType="BIGINT" property="countReadOnly" />
    <result column="SUM_TIMER_READ_ONLY" jdbcType="BIGINT" property="sumTimerReadOnly" />
    <result column="MIN_TIMER_READ_ONLY" jdbcType="BIGINT" property="minTimerReadOnly" />
    <result column="AVG_TIMER_READ_ONLY" jdbcType="BIGINT" property="avgTimerReadOnly" />
    <result column="MAX_TIMER_READ_ONLY" jdbcType="BIGINT" property="maxTimerReadOnly" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from events_transactions_summary_by_thread_by_event_name
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_transactions_summary_by_thread_by_event_name (THREAD_ID, EVENT_NAME, COUNT_STAR, 
      SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
      MAX_TIMER_WAIT, COUNT_READ_WRITE, SUM_TIMER_READ_WRITE, 
      MIN_TIMER_READ_WRITE, AVG_TIMER_READ_WRITE, MAX_TIMER_READ_WRITE, 
      COUNT_READ_ONLY, SUM_TIMER_READ_ONLY, MIN_TIMER_READ_ONLY, 
      AVG_TIMER_READ_ONLY, MAX_TIMER_READ_ONLY)
    values (#{threadId,jdbcType=BIGINT}, #{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, 
      #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, 
      #{maxTimerWait,jdbcType=BIGINT}, #{countReadWrite,jdbcType=BIGINT}, #{sumTimerReadWrite,jdbcType=BIGINT}, 
      #{minTimerReadWrite,jdbcType=BIGINT}, #{avgTimerReadWrite,jdbcType=BIGINT}, #{maxTimerReadWrite,jdbcType=BIGINT}, 
      #{countReadOnly,jdbcType=BIGINT}, #{sumTimerReadOnly,jdbcType=BIGINT}, #{minTimerReadOnly,jdbcType=BIGINT}, 
      #{avgTimerReadOnly,jdbcType=BIGINT}, #{maxTimerReadOnly,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_transactions_summary_by_thread_by_event_name
    set COUNT_STAR = #{countStar,jdbcType=BIGINT},
      SUM_TIMER_WAIT = #{sumTimerWait,jdbcType=BIGINT},
      MIN_TIMER_WAIT = #{minTimerWait,jdbcType=BIGINT},
      AVG_TIMER_WAIT = #{avgTimerWait,jdbcType=BIGINT},
      MAX_TIMER_WAIT = #{maxTimerWait,jdbcType=BIGINT},
      COUNT_READ_WRITE = #{countReadWrite,jdbcType=BIGINT},
      SUM_TIMER_READ_WRITE = #{sumTimerReadWrite,jdbcType=BIGINT},
      MIN_TIMER_READ_WRITE = #{minTimerReadWrite,jdbcType=BIGINT},
      AVG_TIMER_READ_WRITE = #{avgTimerReadWrite,jdbcType=BIGINT},
      MAX_TIMER_READ_WRITE = #{maxTimerReadWrite,jdbcType=BIGINT},
      COUNT_READ_ONLY = #{countReadOnly,jdbcType=BIGINT},
      SUM_TIMER_READ_ONLY = #{sumTimerReadOnly,jdbcType=BIGINT},
      MIN_TIMER_READ_ONLY = #{minTimerReadOnly,jdbcType=BIGINT},
      AVG_TIMER_READ_ONLY = #{avgTimerReadOnly,jdbcType=BIGINT},
      MAX_TIMER_READ_ONLY = #{maxTimerReadOnly,jdbcType=BIGINT}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT, COUNT_READ_WRITE, SUM_TIMER_READ_WRITE, MIN_TIMER_READ_WRITE, AVG_TIMER_READ_WRITE, 
    MAX_TIMER_READ_WRITE, COUNT_READ_ONLY, SUM_TIMER_READ_ONLY, MIN_TIMER_READ_ONLY, 
    AVG_TIMER_READ_ONLY, MAX_TIMER_READ_ONLY
    from events_transactions_summary_by_thread_by_event_name
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT, COUNT_READ_WRITE, SUM_TIMER_READ_WRITE, MIN_TIMER_READ_WRITE, AVG_TIMER_READ_WRITE, 
    MAX_TIMER_READ_WRITE, COUNT_READ_ONLY, SUM_TIMER_READ_ONLY, MIN_TIMER_READ_ONLY, 
    AVG_TIMER_READ_ONLY, MAX_TIMER_READ_ONLY
    from events_transactions_summary_by_thread_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="tid" jdbcType="BIGINT" property="tid" />
    <result column="title" jdbcType="VARBINARY" property="title" />
    <result column="title2" jdbcType="VARBINARY" property="title2" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from titleblog
    where tid = #{tid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into titleblog (tid, title, title2
      )
    values (#{tid,jdbcType=BIGINT}, #{title,jdbcType=VARBINARY}, #{title2,jdbcType=VARBINARY}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update titleblog
    set title = #{title,jdbcType=VARBINARY},
      title2 = #{title2,jdbcType=VARBINARY}
    where tid = #{tid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select tid, title, title2
    from titleblog
    where tid = #{tid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select tid, title, title2
    from titleblog
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Channel_name" jdbcType="CHAR" property="channelName" />
    <id column="Id" jdbcType="INTEGER" property="id" />
    <result column="Relay_log_pos" jdbcType="BIGINT" property="relayLogPos" />
    <result column="Master_log_pos" jdbcType="BIGINT" property="masterLogPos" />
    <result column="Checkpoint_relay_log_pos" jdbcType="BIGINT" property="checkpointRelayLogPos" />
    <result column="Checkpoint_master_log_pos" jdbcType="BIGINT" property="checkpointMasterLogPos" />
    <result column="Checkpoint_seqno" jdbcType="INTEGER" property="checkpointSeqno" />
    <result column="Checkpoint_group_size" jdbcType="INTEGER" property="checkpointGroupSize" />
    <result column="Relay_log_name" jdbcType="LONGVARCHAR" property="relayLogName" />
    <result column="Master_log_name" jdbcType="LONGVARCHAR" property="masterLogName" />
    <result column="Checkpoint_relay_log_name" jdbcType="LONGVARCHAR" property="checkpointRelayLogName" />
    <result column="Checkpoint_master_log_name" jdbcType="LONGVARCHAR" property="checkpointMasterLogName" />
    <result column="Checkpoint_group_bitmap" jdbcType="LONGVARBINARY" property="checkpointGroupBitmap" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from slave_worker_info
    where Channel_name = #{channelName,jdbcType=CHAR}
      and Id = #{id,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into slave_worker_info (Channel_name, Relay_log_pos, Master_log_pos, 
      Checkpoint_relay_log_pos, Checkpoint_master_log_pos, 
      Checkpoint_seqno, Checkpoint_group_size, Relay_log_name, 
      Master_log_name, Checkpoint_relay_log_name, 
      Checkpoint_master_log_name, Checkpoint_group_bitmap
      )
    values (#{channelName,jdbcType=CHAR}, #{relayLogPos,jdbcType=BIGINT}, #{masterLogPos,jdbcType=BIGINT}, 
      #{checkpointRelayLogPos,jdbcType=BIGINT}, #{checkpointMasterLogPos,jdbcType=BIGINT}, 
      #{checkpointSeqno,jdbcType=INTEGER}, #{checkpointGroupSize,jdbcType=INTEGER}, #{relayLogName,jdbcType=LONGVARCHAR}, 
      #{masterLogName,jdbcType=LONGVARCHAR}, #{checkpointRelayLogName,jdbcType=LONGVARCHAR}, 
      #{checkpointMasterLogName,jdbcType=LONGVARCHAR}, #{checkpointGroupBitmap,jdbcType=LONGVARBINARY}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update slave_worker_info
    set Relay_log_pos = #{relayLogPos,jdbcType=BIGINT},
      Master_log_pos = #{masterLogPos,jdbcType=BIGINT},
      Checkpoint_relay_log_pos = #{checkpointRelayLogPos,jdbcType=BIGINT},
      Checkpoint_master_log_pos = #{checkpointMasterLogPos,jdbcType=BIGINT},
      Checkpoint_seqno = #{checkpointSeqno,jdbcType=INTEGER},
      Checkpoint_group_size = #{checkpointGroupSize,jdbcType=INTEGER},
      Relay_log_name = #{relayLogName,jdbcType=LONGVARCHAR},
      Master_log_name = #{masterLogName,jdbcType=LONGVARCHAR},
      Checkpoint_relay_log_name = #{checkpointRelayLogName,jdbcType=LONGVARCHAR},
      Checkpoint_master_log_name = #{checkpointMasterLogName,jdbcType=LONGVARCHAR},
      Checkpoint_group_bitmap = #{checkpointGroupBitmap,jdbcType=LONGVARBINARY}
    where Channel_name = #{channelName,jdbcType=CHAR}
      and Id = #{id,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select Channel_name, Id, Relay_log_pos, Master_log_pos, Checkpoint_relay_log_pos, 
    Checkpoint_master_log_pos, Checkpoint_seqno, Checkpoint_group_size, Relay_log_name, 
    Master_log_name, Checkpoint_relay_log_name, Checkpoint_master_log_name, Checkpoint_group_bitmap
    from slave_worker_info
    where Channel_name = #{channelName,jdbcType=CHAR}
      and Id = #{id,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Channel_name, Id, Relay_log_pos, Master_log_pos, Checkpoint_relay_log_pos, 
    Checkpoint_master_log_pos, Checkpoint_seqno, Checkpoint_group_size, Relay_log_name, 
    Master_log_name, Checkpoint_relay_log_name, Checkpoint_master_log_name, Checkpoint_group_bitmap
    from slave_worker_info
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="eid" jdbcType="BIGINT" property="eid" />
    <result column="changeDate" jdbcType="TIMESTAMP" property="changedate" />
    <result column="createDate" jdbcType="TIMESTAMP" property="createdate" />
    <result column="tid" jdbcType="BIGINT" property="tid" />
    <result column="gid" jdbcType="BIGINT" property="gid" />
    <result column="cid" jdbcType="BIGINT" property="cid" />
    <result column="status" jdbcType="INTEGER" property="status" />
    <result column="context" jdbcType="LONGVARCHAR" property="context" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from editorblog
    where eid = #{eid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into editorblog (eid, changeDate, createDate, 
      tid, gid, cid, status, 
      context)
    values (#{eid,jdbcType=BIGINT}, #{changedate,jdbcType=TIMESTAMP}, #{createdate,jdbcType=TIMESTAMP}, 
      #{tid,jdbcType=BIGINT}, #{gid,jdbcType=BIGINT}, #{cid,jdbcType=BIGINT}, #{status,jdbcType=INTEGER}, 
      #{context,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update editorblog
    set changeDate = #{changedate,jdbcType=TIMESTAMP},
      createDate = #{createdate,jdbcType=TIMESTAMP},
      tid = #{tid,jdbcType=BIGINT},
      gid = #{gid,jdbcType=BIGINT},
      cid = #{cid,jdbcType=BIGINT},
      status = #{status,jdbcType=INTEGER},
      context = #{context,jdbcType=LONGVARCHAR}
    where eid = #{eid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select eid, changeDate, createDate, tid, gid, cid, status, context
    from editorblog
    where eid = #{eid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select eid, changeDate, createDate, tid, gid, cid, status, context
    from editorblog
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="id" jdbcType="INTEGER" property="id" />
    <result column="fname" jdbcType="VARCHAR" property="fname" />
    <result column="ftype" jdbcType="VARCHAR" property="ftype" />
    <result column="authorId" jdbcType="INTEGER" property="authorid" />
    <result column="created" jdbcType="INTEGER" property="created" />
    <result column="fkey" jdbcType="LONGVARCHAR" property="fkey" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from t_attach
    where id = #{id,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into t_attach (fname, ftype, authorId, 
      created, fkey)
    values (#{fname,jdbcType=VARCHAR}, #{ftype,jdbcType=VARCHAR}, #{authorid,jdbcType=INTEGER}, 
      #{created,jdbcType=INTEGER}, #{fkey,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update t_attach
    set fname = #{fname,jdbcType=VARCHAR},
      ftype = #{ftype,jdbcType=VARCHAR},
      authorId = #{authorid,jdbcType=INTEGER},
      created = #{created,jdbcType=INTEGER},
      fkey = #{fkey,jdbcType=LONGVARCHAR}
    where id = #{id,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select id, fname, ftype, authorId, created, fkey
    from t_attach
    where id = #{id,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select id, fname, ftype, authorId, created, fkey
    from t_attach
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="KEY" jdbcType="VARCHAR" property="key" />
    <result column="VALUE" jdbcType="VARCHAR" property="value" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_FT_CONFIG (KEY, VALUE)
    values (#{key,jdbcType=VARCHAR}, #{value,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select KEY, VALUE
    from INNODB_FT_CONFIG
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="NAME" jdbcType="VARCHAR" property="name" />
    <result column="WRITE_LOCKED_BY_THREAD_ID" jdbcType="BIGINT" property="writeLockedByThreadId" />
    <result column="READ_LOCKED_BY_COUNT" jdbcType="INTEGER" property="readLockedByCount" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from rwlock_instances
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into rwlock_instances (OBJECT_INSTANCE_BEGIN, NAME, WRITE_LOCKED_BY_THREAD_ID, 
      READ_LOCKED_BY_COUNT)
    values (#{objectInstanceBegin,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{writeLockedByThreadId,jdbcType=BIGINT}, 
      #{readLockedByCount,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update rwlock_instances
    set NAME = #{name,jdbcType=VARCHAR},
      WRITE_LOCKED_BY_THREAD_ID = #{writeLockedByThreadId,jdbcType=BIGINT},
      READ_LOCKED_BY_COUNT = #{readLockedByCount,jdbcType=INTEGER}
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, NAME, WRITE_LOCKED_BY_THREAD_ID, READ_LOCKED_BY_COUNT
    from rwlock_instances
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, NAME, WRITE_LOCKED_BY_THREAD_ID, READ_LOCKED_BY_COUNT
    from rwlock_instances
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="COLLATION_NAME" jdbcType="VARCHAR" property="collationName" />
    <result column="CHARACTER_SET_NAME" jdbcType="VARCHAR" property="characterSetName" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into COLLATION_CHARACTER_SET_APPLICABILITY (COLLATION_NAME, CHARACTER_SET_NAME)
    values (#{collationName,jdbcType=VARCHAR}, #{characterSetName,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select COLLATION_NAME, CHARACTER_SET_NAME
    from COLLATION_CHARACTER_SET_APPLICABILITY
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="CHANNEL_NAME" jdbcType="CHAR" property="channelName" />
    <id column="WORKER_ID" jdbcType="BIGINT" property="workerId" />
    <result column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <result column="SERVICE_STATE" jdbcType="CHAR" property="serviceState" />
    <result column="LAST_ERROR_NUMBER" jdbcType="INTEGER" property="lastErrorNumber" />
    <result column="LAST_ERROR_MESSAGE" jdbcType="VARCHAR" property="lastErrorMessage" />
    <result column="LAST_ERROR_TIMESTAMP" jdbcType="TIMESTAMP" property="lastErrorTimestamp" />
    <result column="LAST_APPLIED_TRANSACTION" jdbcType="CHAR" property="lastAppliedTransaction" />
    <result column="LAST_APPLIED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP" jdbcType="TIMESTAMP" property="lastAppliedTransactionOriginalCommitTimestamp" />
    <result column="LAST_APPLIED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP" jdbcType="TIMESTAMP" property="lastAppliedTransactionImmediateCommitTimestamp" />
    <result column="LAST_APPLIED_TRANSACTION_START_APPLY_TIMESTAMP" jdbcType="TIMESTAMP" property="lastAppliedTransactionStartApplyTimestamp" />
    <result column="LAST_APPLIED_TRANSACTION_END_APPLY_TIMESTAMP" jdbcType="TIMESTAMP" property="lastAppliedTransactionEndApplyTimestamp" />
    <result column="APPLYING_TRANSACTION" jdbcType="CHAR" property="applyingTransaction" />
    <result column="APPLYING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP" jdbcType="TIMESTAMP" property="applyingTransactionOriginalCommitTimestamp" />
    <result column="APPLYING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP" jdbcType="TIMESTAMP" property="applyingTransactionImmediateCommitTimestamp" />
    <result column="APPLYING_TRANSACTION_START_APPLY_TIMESTAMP" jdbcType="TIMESTAMP" property="applyingTransactionStartApplyTimestamp" />
    <result column="LAST_APPLIED_TRANSACTION_RETRIES_COUNT" jdbcType="BIGINT" property="lastAppliedTransactionRetriesCount" />
    <result column="LAST_APPLIED_TRANSACTION_LAST_TRANSIENT_ERROR_NUMBER" jdbcType="INTEGER" property="lastAppliedTransactionLastTransientErrorNumber" />
    <result column="LAST_APPLIED_TRANSACTION_LAST_TRANSIENT_ERROR_MESSAGE" jdbcType="VARCHAR" property="lastAppliedTransactionLastTransientErrorMessage" />
    <result column="LAST_APPLIED_TRANSACTION_LAST_TRANSIENT_ERROR_TIMESTAMP" jdbcType="TIMESTAMP" property="lastAppliedTransactionLastTransientErrorTimestamp" />
    <result column="APPLYING_TRANSACTION_RETRIES_COUNT" jdbcType="BIGINT" property="applyingTransactionRetriesCount" />
    <result column="APPLYING_TRANSACTION_LAST_TRANSIENT_ERROR_NUMBER" jdbcType="INTEGER" property="applyingTransactionLastTransientErrorNumber" />
    <result column="APPLYING_TRANSACTION_LAST_TRANSIENT_ERROR_MESSAGE" jdbcType="VARCHAR" property="applyingTransactionLastTransientErrorMessage" />
    <result column="APPLYING_TRANSACTION_LAST_TRANSIENT_ERROR_TIMESTAMP" jdbcType="TIMESTAMP" property="applyingTransactionLastTransientErrorTimestamp" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from replication_applier_status_by_worker
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
      and WORKER_ID = #{workerId,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into replication_applier_status_by_worker (CHANNEL_NAME, WORKER_ID, THREAD_ID, 
      SERVICE_STATE, LAST_ERROR_NUMBER, LAST_ERROR_MESSAGE, 
      LAST_ERROR_TIMESTAMP, LAST_APPLIED_TRANSACTION, 
      LAST_APPLIED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, LAST_APPLIED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, 
      LAST_APPLIED_TRANSACTION_START_APPLY_TIMESTAMP, LAST_APPLIED_TRANSACTION_END_APPLY_TIMESTAMP, 
      APPLYING_TRANSACTION, APPLYING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, 
      APPLYING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, APPLYING_TRANSACTION_START_APPLY_TIMESTAMP, 
      LAST_APPLIED_TRANSACTION_RETRIES_COUNT, LAST_APPLIED_TRANSACTION_LAST_TRANSIENT_ERROR_NUMBER, 
      LAST_APPLIED_TRANSACTION_LAST_TRANSIENT_ERROR_MESSAGE, LAST_APPLIED_TRANSACTION_LAST_TRANSIENT_ERROR_TIMESTAMP, 
      APPLYING_TRANSACTION_RETRIES_COUNT, APPLYING_TRANSACTION_LAST_TRANSIENT_ERROR_NUMBER, 
      APPLYING_TRANSACTION_LAST_TRANSIENT_ERROR_MESSAGE, APPLYING_TRANSACTION_LAST_TRANSIENT_ERROR_TIMESTAMP
      )
    values (#{channelName,jdbcType=CHAR}, #{workerId,jdbcType=BIGINT}, #{threadId,jdbcType=BIGINT}, 
      #{serviceState,jdbcType=CHAR}, #{lastErrorNumber,jdbcType=INTEGER}, #{lastErrorMessage,jdbcType=VARCHAR}, 
      #{lastErrorTimestamp,jdbcType=TIMESTAMP}, #{lastAppliedTransaction,jdbcType=CHAR}, 
      #{lastAppliedTransactionOriginalCommitTimestamp,jdbcType=TIMESTAMP}, #{lastAppliedTransactionImmediateCommitTimestamp,jdbcType=TIMESTAMP}, 
      #{lastAppliedTransactionStartApplyTimestamp,jdbcType=TIMESTAMP}, #{lastAppliedTransactionEndApplyTimestamp,jdbcType=TIMESTAMP}, 
      #{applyingTransaction,jdbcType=CHAR}, #{applyingTransactionOriginalCommitTimestamp,jdbcType=TIMESTAMP}, 
      #{applyingTransactionImmediateCommitTimestamp,jdbcType=TIMESTAMP}, #{applyingTransactionStartApplyTimestamp,jdbcType=TIMESTAMP}, 
      #{lastAppliedTransactionRetriesCount,jdbcType=BIGINT}, #{lastAppliedTransactionLastTransientErrorNumber,jdbcType=INTEGER}, 
      #{lastAppliedTransactionLastTransientErrorMessage,jdbcType=VARCHAR}, #{lastAppliedTransactionLastTransientErrorTimestamp,jdbcType=TIMESTAMP}, 
      #{applyingTransactionRetriesCount,jdbcType=BIGINT}, #{applyingTransactionLastTransientErrorNumber,jdbcType=INTEGER}, 
      #{applyingTransactionLastTransientErrorMessage,jdbcType=VARCHAR}, #{applyingTransactionLastTransientErrorTimestamp,jdbcType=TIMESTAMP}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update replication_applier_status_by_worker
    set THREAD_ID = #{threadId,jdbcType=BIGINT},
      SERVICE_STATE = #{serviceState,jdbcType=CHAR},
      LAST_ERROR_NUMBER = #{lastErrorNumber,jdbcType=INTEGER},
      LAST_ERROR_MESSAGE = #{lastErrorMessage,jdbcType=VARCHAR},
      LAST_ERROR_TIMESTAMP = #{lastErrorTimestamp,jdbcType=TIMESTAMP},
      LAST_APPLIED_TRANSACTION = #{lastAppliedTransaction,jdbcType=CHAR},
      LAST_APPLIED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP = #{lastAppliedTransactionOriginalCommitTimestamp,jdbcType=TIMESTAMP},
      LAST_APPLIED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP = #{lastAppliedTransactionImmediateCommitTimestamp,jdbcType=TIMESTAMP},
      LAST_APPLIED_TRANSACTION_START_APPLY_TIMESTAMP = #{lastAppliedTransactionStartApplyTimestamp,jdbcType=TIMESTAMP},
      LAST_APPLIED_TRANSACTION_END_APPLY_TIMESTAMP = #{lastAppliedTransactionEndApplyTimestamp,jdbcType=TIMESTAMP},
      APPLYING_TRANSACTION = #{applyingTransaction,jdbcType=CHAR},
      APPLYING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP = #{applyingTransactionOriginalCommitTimestamp,jdbcType=TIMESTAMP},
      APPLYING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP = #{applyingTransactionImmediateCommitTimestamp,jdbcType=TIMESTAMP},
      APPLYING_TRANSACTION_START_APPLY_TIMESTAMP = #{applyingTransactionStartApplyTimestamp,jdbcType=TIMESTAMP},
      LAST_APPLIED_TRANSACTION_RETRIES_COUNT = #{lastAppliedTransactionRetriesCount,jdbcType=BIGINT},
      LAST_APPLIED_TRANSACTION_LAST_TRANSIENT_ERROR_NUMBER = #{lastAppliedTransactionLastTransientErrorNumber,jdbcType=INTEGER},
      LAST_APPLIED_TRANSACTION_LAST_TRANSIENT_ERROR_MESSAGE = #{lastAppliedTransactionLastTransientErrorMessage,jdbcType=VARCHAR},
      LAST_APPLIED_TRANSACTION_LAST_TRANSIENT_ERROR_TIMESTAMP = #{lastAppliedTransactionLastTransientErrorTimestamp,jdbcType=TIMESTAMP},
      APPLYING_TRANSACTION_RETRIES_COUNT = #{applyingTransactionRetriesCount,jdbcType=BIGINT},
      APPLYING_TRANSACTION_LAST_TRANSIENT_ERROR_NUMBER = #{applyingTransactionLastTransientErrorNumber,jdbcType=INTEGER},
      APPLYING_TRANSACTION_LAST_TRANSIENT_ERROR_MESSAGE = #{applyingTransactionLastTransientErrorMessage,jdbcType=VARCHAR},
      APPLYING_TRANSACTION_LAST_TRANSIENT_ERROR_TIMESTAMP = #{applyingTransactionLastTransientErrorTimestamp,jdbcType=TIMESTAMP}
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
      and WORKER_ID = #{workerId,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select CHANNEL_NAME, WORKER_ID, THREAD_ID, SERVICE_STATE, LAST_ERROR_NUMBER, LAST_ERROR_MESSAGE, 
    LAST_ERROR_TIMESTAMP, LAST_APPLIED_TRANSACTION, LAST_APPLIED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, 
    LAST_APPLIED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, LAST_APPLIED_TRANSACTION_START_APPLY_TIMESTAMP, 
    LAST_APPLIED_TRANSACTION_END_APPLY_TIMESTAMP, APPLYING_TRANSACTION, APPLYING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, 
    APPLYING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, APPLYING_TRANSACTION_START_APPLY_TIMESTAMP, 
    LAST_APPLIED_TRANSACTION_RETRIES_COUNT, LAST_APPLIED_TRANSACTION_LAST_TRANSIENT_ERROR_NUMBER, 
    LAST_APPLIED_TRANSACTION_LAST_TRANSIENT_ERROR_MESSAGE, LAST_APPLIED_TRANSACTION_LAST_TRANSIENT_ERROR_TIMESTAMP, 
    APPLYING_TRANSACTION_RETRIES_COUNT, APPLYING_TRANSACTION_LAST_TRANSIENT_ERROR_NUMBER, 
    APPLYING_TRANSACTION_LAST_TRANSIENT_ERROR_MESSAGE, APPLYING_TRANSACTION_LAST_TRANSIENT_ERROR_TIMESTAMP
    from replication_applier_status_by_worker
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
      and WORKER_ID = #{workerId,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select CHANNEL_NAME, WORKER_ID, THREAD_ID, SERVICE_STATE, LAST_ERROR_NUMBER, LAST_ERROR_MESSAGE, 
    LAST_ERROR_TIMESTAMP, LAST_APPLIED_TRANSACTION, LAST_APPLIED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, 
    LAST_APPLIED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, LAST_APPLIED_TRANSACTION_START_APPLY_TIMESTAMP, 
    LAST_APPLIED_TRANSACTION_END_APPLY_TIMESTAMP, APPLYING_TRANSACTION, APPLYING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, 
    APPLYING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, APPLYING_TRANSACTION_START_APPLY_TIMESTAMP, 
    LAST_APPLIED_TRANSACTION_RETRIES_COUNT, LAST_APPLIED_TRANSACTION_LAST_TRANSIENT_ERROR_NUMBER, 
    LAST_APPLIED_TRANSACTION_LAST_TRANSIENT_ERROR_MESSAGE, LAST_APPLIED_TRANSACTION_LAST_TRANSIENT_ERROR_TIMESTAMP, 
    APPLYING_TRANSACTION_RETRIES_COUNT, APPLYING_TRANSACTION_LAST_TRANSIENT_ERROR_NUMBER, 
    APPLYING_TRANSACTION_LAST_TRANSIENT_ERROR_MESSAGE, APPLYING_TRANSACTION_LAST_TRANSIENT_ERROR_TIMESTAMP
    from replication_applier_status_by_worker
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="full_scan" jdbcType="VARCHAR" property="fullScan" />
    <result column="exec_count" jdbcType="BIGINT" property="execCount" />
    <result column="err_count" jdbcType="BIGINT" property="errCount" />
    <result column="warn_count" jdbcType="BIGINT" property="warnCount" />
    <result column="rows_sent" jdbcType="BIGINT" property="rowsSent" />
    <result column="rows_sent_avg" jdbcType="DECIMAL" property="rowsSentAvg" />
    <result column="rows_examined" jdbcType="BIGINT" property="rowsExamined" />
    <result column="rows_examined_avg" jdbcType="DECIMAL" property="rowsExaminedAvg" />
    <result column="rows_affected" jdbcType="BIGINT" property="rowsAffected" />
    <result column="rows_affected_avg" jdbcType="DECIMAL" property="rowsAffectedAvg" />
    <result column="tmp_tables" jdbcType="BIGINT" property="tmpTables" />
    <result column="tmp_disk_tables" jdbcType="BIGINT" property="tmpDiskTables" />
    <result column="rows_sorted" jdbcType="BIGINT" property="rowsSorted" />
    <result column="sort_merge_passes" jdbcType="BIGINT" property="sortMergePasses" />
    <result column="digest" jdbcType="VARCHAR" property="digest" />
    <result column="first_seen" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="last_seen" jdbcType="TIMESTAMP" property="lastSeen" />
    <result column="query" jdbcType="LONGVARCHAR" property="query" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
    <result column="avg_latency" jdbcType="LONGVARCHAR" property="avgLatency" />
    <result column="lock_latency" jdbcType="LONGVARCHAR" property="lockLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into statement_analysis (db, full_scan, exec_count, 
      err_count, warn_count, rows_sent, 
      rows_sent_avg, rows_examined, rows_examined_avg, 
      rows_affected, rows_affected_avg, tmp_tables, 
      tmp_disk_tables, rows_sorted, sort_merge_passes, 
      digest, first_seen, last_seen, 
      query, total_latency, max_latency, 
      avg_latency, lock_latency)
    values (#{db,jdbcType=VARCHAR}, #{fullScan,jdbcType=VARCHAR}, #{execCount,jdbcType=BIGINT}, 
      #{errCount,jdbcType=BIGINT}, #{warnCount,jdbcType=BIGINT}, #{rowsSent,jdbcType=BIGINT}, 
      #{rowsSentAvg,jdbcType=DECIMAL}, #{rowsExamined,jdbcType=BIGINT}, #{rowsExaminedAvg,jdbcType=DECIMAL}, 
      #{rowsAffected,jdbcType=BIGINT}, #{rowsAffectedAvg,jdbcType=DECIMAL}, #{tmpTables,jdbcType=BIGINT}, 
      #{tmpDiskTables,jdbcType=BIGINT}, #{rowsSorted,jdbcType=BIGINT}, #{sortMergePasses,jdbcType=BIGINT}, 
      #{digest,jdbcType=VARCHAR}, #{firstSeen,jdbcType=TIMESTAMP}, #{lastSeen,jdbcType=TIMESTAMP}, 
      #{query,jdbcType=LONGVARCHAR}, #{totalLatency,jdbcType=LONGVARCHAR}, #{maxLatency,jdbcType=LONGVARCHAR}, 
      #{avgLatency,jdbcType=LONGVARCHAR}, #{lockLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select db, full_scan, exec_count, err_count, warn_count, rows_sent, rows_sent_avg, 
    rows_examined, rows_examined_avg, rows_affected, rows_affected_avg, tmp_tables, tmp_disk_tables, 
    rows_sorted, sort_merge_passes, digest, first_seen, last_seen, query, total_latency, 
    max_latency, avg_latency, lock_latency
    from statement_analysis
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="VARIABLE_NAME" jdbcType="VARCHAR" property="variableName" />
    <result column="VARIABLE_SOURCE" jdbcType="CHAR" property="variableSource" />
    <result column="VARIABLE_PATH" jdbcType="VARCHAR" property="variablePath" />
    <result column="MIN_VALUE" jdbcType="VARCHAR" property="minValue" />
    <result column="MAX_VALUE" jdbcType="VARCHAR" property="maxValue" />
    <result column="SET_TIME" jdbcType="TIMESTAMP" property="setTime" />
    <result column="SET_USER" jdbcType="CHAR" property="setUser" />
    <result column="SET_HOST" jdbcType="CHAR" property="setHost" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into variables_info (VARIABLE_NAME, VARIABLE_SOURCE, VARIABLE_PATH, 
      MIN_VALUE, MAX_VALUE, SET_TIME, 
      SET_USER, SET_HOST)
    values (#{variableName,jdbcType=VARCHAR}, #{variableSource,jdbcType=CHAR}, #{variablePath,jdbcType=VARCHAR}, 
      #{minValue,jdbcType=VARCHAR}, #{maxValue,jdbcType=VARCHAR}, #{setTime,jdbcType=TIMESTAMP}, 
      #{setUser,jdbcType=CHAR}, #{setHost,jdbcType=CHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select VARIABLE_NAME, VARIABLE_SOURCE, VARIABLE_PATH, MIN_VALUE, MAX_VALUE, SET_TIME, 
    SET_USER, SET_HOST
    from variables_info
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="id" jdbcType="INTEGER" property="id" />
    <result column="name" jdbcType="VARCHAR" property="name" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from department
    where id = #{id,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into department (name)
    values (#{name,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update department
    set name = #{name,jdbcType=VARCHAR}
    where id = #{id,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select id, name
    from department
    where id = #{id,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select id, name
    from department
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="ID" jdbcType="BIGINT" property="id" />
    <result column="USER" jdbcType="VARCHAR" property="user" />
    <result column="HOST" jdbcType="VARCHAR" property="host" />
    <result column="DB" jdbcType="VARCHAR" property="db" />
    <result column="COMMAND" jdbcType="VARCHAR" property="command" />
    <result column="TIME" jdbcType="INTEGER" property="time" />
    <result column="STATE" jdbcType="VARCHAR" property="state" />
    <result column="INFO" jdbcType="VARCHAR" property="info" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Long">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into PROCESSLIST (USER, HOST, DB, 
      COMMAND, TIME, STATE, 
      INFO)
    values (#{user,jdbcType=VARCHAR}, #{host,jdbcType=VARCHAR}, #{db,jdbcType=VARCHAR}, 
      #{command,jdbcType=VARCHAR}, #{time,jdbcType=INTEGER}, #{state,jdbcType=VARCHAR}, 
      #{info,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select ID, USER, HOST, DB, COMMAND, TIME, STATE, INFO
    from PROCESSLIST
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="TABLE_ID" jdbcType="BIGINT" property="tableId" />
    <result column="NAME" jdbcType="VARCHAR" property="name" />
    <result column="POS" jdbcType="BIGINT" property="pos" />
    <result column="MTYPE" jdbcType="INTEGER" property="mtype" />
    <result column="PRTYPE" jdbcType="INTEGER" property="prtype" />
    <result column="LEN" jdbcType="INTEGER" property="len" />
    <result column="HAS_DEFAULT" jdbcType="INTEGER" property="hasDefault" />
    <result column="DEFAULT_VALUE" jdbcType="LONGVARCHAR" property="defaultValue" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_COLUMNS (TABLE_ID, NAME, POS, 
      MTYPE, PRTYPE, LEN, 
      HAS_DEFAULT, DEFAULT_VALUE)
    values (#{tableId,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{pos,jdbcType=BIGINT}, 
      #{mtype,jdbcType=INTEGER}, #{prtype,jdbcType=INTEGER}, #{len,jdbcType=INTEGER}, 
      #{hasDefault,jdbcType=INTEGER}, #{defaultValue,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select TABLE_ID, NAME, POS, MTYPE, PRTYPE, LEN, HAS_DEFAULT, DEFAULT_VALUE
    from INNODB_COLUMNS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="CHARACTER_SET_NAME" jdbcType="VARCHAR" property="characterSetName" />
    <result column="DEFAULT_COLLATE_NAME" jdbcType="VARCHAR" property="defaultCollateName" />
    <result column="DESCRIPTION" jdbcType="VARCHAR" property="description" />
    <result column="MAXLEN" jdbcType="INTEGER" property="maxlen" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into CHARACTER_SETS (CHARACTER_SET_NAME, DEFAULT_COLLATE_NAME, 
      DESCRIPTION, MAXLEN)
    values (#{characterSetName,jdbcType=VARCHAR}, #{defaultCollateName,jdbcType=VARCHAR}, 
      #{description,jdbcType=VARCHAR}, #{maxlen,jdbcType=INTEGER})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select CHARACTER_SET_NAME, DEFAULT_COLLATE_NAME, DESCRIPTION, MAXLEN
    from CHARACTER_SETS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="VARIABLE_NAME" jdbcType="VARCHAR" property="variableName" />
    <result column="VARIABLE_VALUE" jdbcType="VARCHAR" property="variableValue" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from global_variables
    where VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into global_variables (VARIABLE_NAME, VARIABLE_VALUE)
    values (#{variableName,jdbcType=VARCHAR}, #{variableValue,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update global_variables
    set VARIABLE_VALUE = #{variableValue,jdbcType=VARCHAR}
    where VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select VARIABLE_NAME, VARIABLE_VALUE
    from global_variables
    where VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select VARIABLE_NAME, VARIABLE_VALUE
    from global_variables
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="WORD" jdbcType="VARCHAR" property="word" />
    <result column="RESERVED" jdbcType="INTEGER" property="reserved" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into KEYWORDS (WORD, RESERVED)
    values (#{word,jdbcType=VARCHAR}, #{reserved,jdbcType=INTEGER})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select WORD, RESERVED
    from KEYWORDS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="wait_started" jdbcType="TIMESTAMP" property="waitStarted" />
    <result column="wait_age" jdbcType="TIME" property="waitAge" />
    <result column="wait_age_secs" jdbcType="BIGINT" property="waitAgeSecs" />
    <result column="locked_table_schema" jdbcType="VARCHAR" property="lockedTableSchema" />
    <result column="locked_table_name" jdbcType="VARCHAR" property="lockedTableName" />
    <result column="locked_table_partition" jdbcType="VARCHAR" property="lockedTablePartition" />
    <result column="locked_table_subpartition" jdbcType="VARCHAR" property="lockedTableSubpartition" />
    <result column="locked_index" jdbcType="VARCHAR" property="lockedIndex" />
    <result column="locked_type" jdbcType="VARCHAR" property="lockedType" />
    <result column="waiting_trx_id" jdbcType="VARCHAR" property="waitingTrxId" />
    <result column="waiting_trx_started" jdbcType="TIMESTAMP" property="waitingTrxStarted" />
    <result column="waiting_trx_age" jdbcType="TIME" property="waitingTrxAge" />
    <result column="waiting_trx_rows_locked" jdbcType="BIGINT" property="waitingTrxRowsLocked" />
    <result column="waiting_trx_rows_modified" jdbcType="BIGINT" property="waitingTrxRowsModified" />
    <result column="waiting_pid" jdbcType="BIGINT" property="waitingPid" />
    <result column="waiting_lock_id" jdbcType="VARCHAR" property="waitingLockId" />
    <result column="waiting_lock_mode" jdbcType="VARCHAR" property="waitingLockMode" />
    <result column="blocking_trx_id" jdbcType="VARCHAR" property="blockingTrxId" />
    <result column="blocking_pid" jdbcType="BIGINT" property="blockingPid" />
    <result column="blocking_lock_id" jdbcType="VARCHAR" property="blockingLockId" />
    <result column="blocking_lock_mode" jdbcType="VARCHAR" property="blockingLockMode" />
    <result column="blocking_trx_started" jdbcType="TIMESTAMP" property="blockingTrxStarted" />
    <result column="blocking_trx_age" jdbcType="TIME" property="blockingTrxAge" />
    <result column="blocking_trx_rows_locked" jdbcType="BIGINT" property="blockingTrxRowsLocked" />
    <result column="blocking_trx_rows_modified" jdbcType="BIGINT" property="blockingTrxRowsModified" />
    <result column="sql_kill_blocking_query" jdbcType="VARCHAR" property="sqlKillBlockingQuery" />
    <result column="sql_kill_blocking_connection" jdbcType="VARCHAR" property="sqlKillBlockingConnection" />
    <result column="locked_table" jdbcType="LONGVARCHAR" property="lockedTable" />
    <result column="waiting_query" jdbcType="LONGVARCHAR" property="waitingQuery" />
    <result column="blocking_query" jdbcType="LONGVARCHAR" property="blockingQuery" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into innodb_lock_waits (wait_started, wait_age, wait_age_secs, 
      locked_table_schema, locked_table_name, locked_table_partition, 
      locked_table_subpartition, locked_index, locked_type, 
      waiting_trx_id, waiting_trx_started, waiting_trx_age, 
      waiting_trx_rows_locked, waiting_trx_rows_modified, 
      waiting_pid, waiting_lock_id, waiting_lock_mode, 
      blocking_trx_id, blocking_pid, blocking_lock_id, 
      blocking_lock_mode, blocking_trx_started, 
      blocking_trx_age, blocking_trx_rows_locked, blocking_trx_rows_modified, 
      sql_kill_blocking_query, sql_kill_blocking_connection, 
      locked_table, waiting_query, blocking_query
      )
    values (#{waitStarted,jdbcType=TIMESTAMP}, #{waitAge,jdbcType=TIME}, #{waitAgeSecs,jdbcType=BIGINT}, 
      #{lockedTableSchema,jdbcType=VARCHAR}, #{lockedTableName,jdbcType=VARCHAR}, #{lockedTablePartition,jdbcType=VARCHAR}, 
      #{lockedTableSubpartition,jdbcType=VARCHAR}, #{lockedIndex,jdbcType=VARCHAR}, #{lockedType,jdbcType=VARCHAR}, 
      #{waitingTrxId,jdbcType=VARCHAR}, #{waitingTrxStarted,jdbcType=TIMESTAMP}, #{waitingTrxAge,jdbcType=TIME}, 
      #{waitingTrxRowsLocked,jdbcType=BIGINT}, #{waitingTrxRowsModified,jdbcType=BIGINT}, 
      #{waitingPid,jdbcType=BIGINT}, #{waitingLockId,jdbcType=VARCHAR}, #{waitingLockMode,jdbcType=VARCHAR}, 
      #{blockingTrxId,jdbcType=VARCHAR}, #{blockingPid,jdbcType=BIGINT}, #{blockingLockId,jdbcType=VARCHAR}, 
      #{blockingLockMode,jdbcType=VARCHAR}, #{blockingTrxStarted,jdbcType=TIMESTAMP}, 
      #{blockingTrxAge,jdbcType=TIME}, #{blockingTrxRowsLocked,jdbcType=BIGINT}, #{blockingTrxRowsModified,jdbcType=BIGINT}, 
      #{sqlKillBlockingQuery,jdbcType=VARCHAR}, #{sqlKillBlockingConnection,jdbcType=VARCHAR}, 
      #{lockedTable,jdbcType=LONGVARCHAR}, #{waitingQuery,jdbcType=LONGVARCHAR}, #{blockingQuery,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select wait_started, wait_age, wait_age_secs, locked_table_schema, locked_table_name, 
    locked_table_partition, locked_table_subpartition, locked_index, locked_type, waiting_trx_id, 
    waiting_trx_started, waiting_trx_age, waiting_trx_rows_locked, waiting_trx_rows_modified, 
    waiting_pid, waiting_lock_id, waiting_lock_mode, blocking_trx_id, blocking_pid, blocking_lock_id, 
    blocking_lock_mode, blocking_trx_started, blocking_trx_age, blocking_trx_rows_locked, 
    blocking_trx_rows_modified, sql_kill_blocking_query, sql_kill_blocking_connection, 
    locked_table, waiting_query, blocking_query
    from innodb_lock_waits
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="FILE_NAME" jdbcType="VARCHAR" property="fileName" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="COUNT_READ" jdbcType="BIGINT" property="countRead" />
    <result column="SUM_TIMER_READ" jdbcType="BIGINT" property="sumTimerRead" />
    <result column="MIN_TIMER_READ" jdbcType="BIGINT" property="minTimerRead" />
    <result column="AVG_TIMER_READ" jdbcType="BIGINT" property="avgTimerRead" />
    <result column="MAX_TIMER_READ" jdbcType="BIGINT" property="maxTimerRead" />
    <result column="SUM_NUMBER_OF_BYTES_READ" jdbcType="BIGINT" property="sumNumberOfBytesRead" />
    <result column="COUNT_WRITE" jdbcType="BIGINT" property="countWrite" />
    <result column="SUM_TIMER_WRITE" jdbcType="BIGINT" property="sumTimerWrite" />
    <result column="MIN_TIMER_WRITE" jdbcType="BIGINT" property="minTimerWrite" />
    <result column="AVG_TIMER_WRITE" jdbcType="BIGINT" property="avgTimerWrite" />
    <result column="MAX_TIMER_WRITE" jdbcType="BIGINT" property="maxTimerWrite" />
    <result column="SUM_NUMBER_OF_BYTES_WRITE" jdbcType="BIGINT" property="sumNumberOfBytesWrite" />
    <result column="COUNT_MISC" jdbcType="BIGINT" property="countMisc" />
    <result column="SUM_TIMER_MISC" jdbcType="BIGINT" property="sumTimerMisc" />
    <result column="MIN_TIMER_MISC" jdbcType="BIGINT" property="minTimerMisc" />
    <result column="AVG_TIMER_MISC" jdbcType="BIGINT" property="avgTimerMisc" />
    <result column="MAX_TIMER_MISC" jdbcType="BIGINT" property="maxTimerMisc" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from file_summary_by_instance
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into file_summary_by_instance (OBJECT_INSTANCE_BEGIN, FILE_NAME, EVENT_NAME, 
      COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
      AVG_TIMER_WAIT, MAX_TIMER_WAIT, COUNT_READ, 
      SUM_TIMER_READ, MIN_TIMER_READ, AVG_TIMER_READ, 
      MAX_TIMER_READ, SUM_NUMBER_OF_BYTES_READ, COUNT_WRITE, 
      SUM_TIMER_WRITE, MIN_TIMER_WRITE, AVG_TIMER_WRITE, 
      MAX_TIMER_WRITE, SUM_NUMBER_OF_BYTES_WRITE, COUNT_MISC, 
      SUM_TIMER_MISC, MIN_TIMER_MISC, AVG_TIMER_MISC, 
      MAX_TIMER_MISC)
    values (#{objectInstanceBegin,jdbcType=BIGINT}, #{fileName,jdbcType=VARCHAR}, #{eventName,jdbcType=VARCHAR}, 
      #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, 
      #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT}, #{countRead,jdbcType=BIGINT}, 
      #{sumTimerRead,jdbcType=BIGINT}, #{minTimerRead,jdbcType=BIGINT}, #{avgTimerRead,jdbcType=BIGINT}, 
      #{maxTimerRead,jdbcType=BIGINT}, #{sumNumberOfBytesRead,jdbcType=BIGINT}, #{countWrite,jdbcType=BIGINT}, 
      #{sumTimerWrite,jdbcType=BIGINT}, #{minTimerWrite,jdbcType=BIGINT}, #{avgTimerWrite,jdbcType=BIGINT}, 
      #{maxTimerWrite,jdbcType=BIGINT}, #{sumNumberOfBytesWrite,jdbcType=BIGINT}, #{countMisc,jdbcType=BIGINT}, 
      #{sumTimerMisc,jdbcType=BIGINT}, #{minTimerMisc,jdbcType=BIGINT}, #{avgTimerMisc,jdbcType=BIGINT}, 
      #{maxTimerMisc,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update file_summary_by_instance
    set FILE_NAME = #{fileName,jdbcType=VARCHAR},
      EVENT_NAME = #{eventName,jdbcType=VARCHAR},
      COUNT_STAR = #{countStar,jdbcType=BIGINT},
      SUM_TIMER_WAIT = #{sumTimerWait,jdbcType=BIGINT},
      MIN_TIMER_WAIT = #{minTimerWait,jdbcType=BIGINT},
      AVG_TIMER_WAIT = #{avgTimerWait,jdbcType=BIGINT},
      MAX_TIMER_WAIT = #{maxTimerWait,jdbcType=BIGINT},
      COUNT_READ = #{countRead,jdbcType=BIGINT},
      SUM_TIMER_READ = #{sumTimerRead,jdbcType=BIGINT},
      MIN_TIMER_READ = #{minTimerRead,jdbcType=BIGINT},
      AVG_TIMER_READ = #{avgTimerRead,jdbcType=BIGINT},
      MAX_TIMER_READ = #{maxTimerRead,jdbcType=BIGINT},
      SUM_NUMBER_OF_BYTES_READ = #{sumNumberOfBytesRead,jdbcType=BIGINT},
      COUNT_WRITE = #{countWrite,jdbcType=BIGINT},
      SUM_TIMER_WRITE = #{sumTimerWrite,jdbcType=BIGINT},
      MIN_TIMER_WRITE = #{minTimerWrite,jdbcType=BIGINT},
      AVG_TIMER_WRITE = #{avgTimerWrite,jdbcType=BIGINT},
      MAX_TIMER_WRITE = #{maxTimerWrite,jdbcType=BIGINT},
      SUM_NUMBER_OF_BYTES_WRITE = #{sumNumberOfBytesWrite,jdbcType=BIGINT},
      COUNT_MISC = #{countMisc,jdbcType=BIGINT},
      SUM_TIMER_MISC = #{sumTimerMisc,jdbcType=BIGINT},
      MIN_TIMER_MISC = #{minTimerMisc,jdbcType=BIGINT},
      AVG_TIMER_MISC = #{avgTimerMisc,jdbcType=BIGINT},
      MAX_TIMER_MISC = #{maxTimerMisc,jdbcType=BIGINT}
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, FILE_NAME, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, 
    MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, COUNT_READ, SUM_TIMER_READ, MIN_TIMER_READ, 
    AVG_TIMER_READ, MAX_TIMER_READ, SUM_NUMBER_OF_BYTES_READ, COUNT_WRITE, SUM_TIMER_WRITE, 
    MIN_TIMER_WRITE, AVG_TIMER_WRITE, MAX_TIMER_WRITE, SUM_NUMBER_OF_BYTES_WRITE, COUNT_MISC, 
    SUM_TIMER_MISC, MIN_TIMER_MISC, AVG_TIMER_MISC, MAX_TIMER_MISC
    from file_summary_by_instance
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, FILE_NAME, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, 
    MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, COUNT_READ, SUM_TIMER_READ, MIN_TIMER_READ, 
    AVG_TIMER_READ, MAX_TIMER_READ, SUM_NUMBER_OF_BYTES_READ, COUNT_WRITE, SUM_TIMER_WRITE, 
    MIN_TIMER_WRITE, AVG_TIMER_WRITE, MAX_TIMER_WRITE, SUM_NUMBER_OF_BYTES_WRITE, COUNT_MISC, 
    SUM_TIMER_MISC, MIN_TIMER_MISC, AVG_TIMER_MISC, MAX_TIMER_MISC
    from file_summary_by_instance
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="event_name" jdbcType="VARCHAR" property="eventName" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="avg_latency" jdbcType="BIGINT" property="avgLatency" />
    <result column="max_latency" jdbcType="BIGINT" property="maxLatency" />
    <result column="read_latency" jdbcType="BIGINT" property="readLatency" />
    <result column="write_latency" jdbcType="BIGINT" property="writeLatency" />
    <result column="misc_latency" jdbcType="BIGINT" property="miscLatency" />
    <result column="count_read" jdbcType="BIGINT" property="countRead" />
    <result column="total_read" jdbcType="BIGINT" property="totalRead" />
    <result column="avg_read" jdbcType="DECIMAL" property="avgRead" />
    <result column="count_write" jdbcType="BIGINT" property="countWrite" />
    <result column="total_written" jdbcType="BIGINT" property="totalWritten" />
    <result column="avg_written" jdbcType="DECIMAL" property="avgWritten" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$io_global_by_wait_by_latency (event_name, total, total_latency, 
      avg_latency, max_latency, read_latency, 
      write_latency, misc_latency, count_read, 
      total_read, avg_read, count_write, 
      total_written, avg_written)
    values (#{eventName,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, #{totalLatency,jdbcType=BIGINT}, 
      #{avgLatency,jdbcType=BIGINT}, #{maxLatency,jdbcType=BIGINT}, #{readLatency,jdbcType=BIGINT}, 
      #{writeLatency,jdbcType=BIGINT}, #{miscLatency,jdbcType=BIGINT}, #{countRead,jdbcType=BIGINT}, 
      #{totalRead,jdbcType=BIGINT}, #{avgRead,jdbcType=DECIMAL}, #{countWrite,jdbcType=BIGINT}, 
      #{totalWritten,jdbcType=BIGINT}, #{avgWritten,jdbcType=DECIMAL})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select event_name, total, total_latency, avg_latency, max_latency, read_latency, 
    write_latency, misc_latency, count_read, total_read, avg_read, count_write, total_written, 
    avg_written
    from x$io_global_by_wait_by_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="SUM_LOCK_TIME" jdbcType="BIGINT" property="sumLockTime" />
    <result column="SUM_ERRORS" jdbcType="BIGINT" property="sumErrors" />
    <result column="SUM_WARNINGS" jdbcType="BIGINT" property="sumWarnings" />
    <result column="SUM_ROWS_AFFECTED" jdbcType="BIGINT" property="sumRowsAffected" />
    <result column="SUM_ROWS_SENT" jdbcType="BIGINT" property="sumRowsSent" />
    <result column="SUM_ROWS_EXAMINED" jdbcType="BIGINT" property="sumRowsExamined" />
    <result column="SUM_CREATED_TMP_DISK_TABLES" jdbcType="BIGINT" property="sumCreatedTmpDiskTables" />
    <result column="SUM_CREATED_TMP_TABLES" jdbcType="BIGINT" property="sumCreatedTmpTables" />
    <result column="SUM_SELECT_FULL_JOIN" jdbcType="BIGINT" property="sumSelectFullJoin" />
    <result column="SUM_SELECT_FULL_RANGE_JOIN" jdbcType="BIGINT" property="sumSelectFullRangeJoin" />
    <result column="SUM_SELECT_RANGE" jdbcType="BIGINT" property="sumSelectRange" />
    <result column="SUM_SELECT_RANGE_CHECK" jdbcType="BIGINT" property="sumSelectRangeCheck" />
    <result column="SUM_SELECT_SCAN" jdbcType="BIGINT" property="sumSelectScan" />
    <result column="SUM_SORT_MERGE_PASSES" jdbcType="BIGINT" property="sumSortMergePasses" />
    <result column="SUM_SORT_RANGE" jdbcType="BIGINT" property="sumSortRange" />
    <result column="SUM_SORT_ROWS" jdbcType="BIGINT" property="sumSortRows" />
    <result column="SUM_SORT_SCAN" jdbcType="BIGINT" property="sumSortScan" />
    <result column="SUM_NO_INDEX_USED" jdbcType="BIGINT" property="sumNoIndexUsed" />
    <result column="SUM_NO_GOOD_INDEX_USED" jdbcType="BIGINT" property="sumNoGoodIndexUsed" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from events_statements_summary_global_by_event_name
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_statements_summary_global_by_event_name (EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, 
      MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, 
      SUM_LOCK_TIME, SUM_ERRORS, SUM_WARNINGS, 
      SUM_ROWS_AFFECTED, SUM_ROWS_SENT, SUM_ROWS_EXAMINED, 
      SUM_CREATED_TMP_DISK_TABLES, SUM_CREATED_TMP_TABLES, 
      SUM_SELECT_FULL_JOIN, SUM_SELECT_FULL_RANGE_JOIN, 
      SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, 
      SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, 
      SUM_SORT_SCAN, SUM_NO_INDEX_USED, SUM_NO_GOOD_INDEX_USED
      )
    values (#{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, 
      #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT}, 
      #{sumLockTime,jdbcType=BIGINT}, #{sumErrors,jdbcType=BIGINT}, #{sumWarnings,jdbcType=BIGINT}, 
      #{sumRowsAffected,jdbcType=BIGINT}, #{sumRowsSent,jdbcType=BIGINT}, #{sumRowsExamined,jdbcType=BIGINT}, 
      #{sumCreatedTmpDiskTables,jdbcType=BIGINT}, #{sumCreatedTmpTables,jdbcType=BIGINT}, 
      #{sumSelectFullJoin,jdbcType=BIGINT}, #{sumSelectFullRangeJoin,jdbcType=BIGINT}, 
      #{sumSelectRange,jdbcType=BIGINT}, #{sumSelectRangeCheck,jdbcType=BIGINT}, #{sumSelectScan,jdbcType=BIGINT}, 
      #{sumSortMergePasses,jdbcType=BIGINT}, #{sumSortRange,jdbcType=BIGINT}, #{sumSortRows,jdbcType=BIGINT}, 
      #{sumSortScan,jdbcType=BIGINT}, #{sumNoIndexUsed,jdbcType=BIGINT}, #{sumNoGoodIndexUsed,jdbcType=BIGINT}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_statements_summary_global_by_event_name
    set COUNT_STAR = #{countStar,jdbcType=BIGINT},
      SUM_TIMER_WAIT = #{sumTimerWait,jdbcType=BIGINT},
      MIN_TIMER_WAIT = #{minTimerWait,jdbcType=BIGINT},
      AVG_TIMER_WAIT = #{avgTimerWait,jdbcType=BIGINT},
      MAX_TIMER_WAIT = #{maxTimerWait,jdbcType=BIGINT},
      SUM_LOCK_TIME = #{sumLockTime,jdbcType=BIGINT},
      SUM_ERRORS = #{sumErrors,jdbcType=BIGINT},
      SUM_WARNINGS = #{sumWarnings,jdbcType=BIGINT},
      SUM_ROWS_AFFECTED = #{sumRowsAffected,jdbcType=BIGINT},
      SUM_ROWS_SENT = #{sumRowsSent,jdbcType=BIGINT},
      SUM_ROWS_EXAMINED = #{sumRowsExamined,jdbcType=BIGINT},
      SUM_CREATED_TMP_DISK_TABLES = #{sumCreatedTmpDiskTables,jdbcType=BIGINT},
      SUM_CREATED_TMP_TABLES = #{sumCreatedTmpTables,jdbcType=BIGINT},
      SUM_SELECT_FULL_JOIN = #{sumSelectFullJoin,jdbcType=BIGINT},
      SUM_SELECT_FULL_RANGE_JOIN = #{sumSelectFullRangeJoin,jdbcType=BIGINT},
      SUM_SELECT_RANGE = #{sumSelectRange,jdbcType=BIGINT},
      SUM_SELECT_RANGE_CHECK = #{sumSelectRangeCheck,jdbcType=BIGINT},
      SUM_SELECT_SCAN = #{sumSelectScan,jdbcType=BIGINT},
      SUM_SORT_MERGE_PASSES = #{sumSortMergePasses,jdbcType=BIGINT},
      SUM_SORT_RANGE = #{sumSortRange,jdbcType=BIGINT},
      SUM_SORT_ROWS = #{sumSortRows,jdbcType=BIGINT},
      SUM_SORT_SCAN = #{sumSortScan,jdbcType=BIGINT},
      SUM_NO_INDEX_USED = #{sumNoIndexUsed,jdbcType=BIGINT},
      SUM_NO_GOOD_INDEX_USED = #{sumNoGoodIndexUsed,jdbcType=BIGINT}
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, 
    SUM_LOCK_TIME, SUM_ERRORS, SUM_WARNINGS, SUM_ROWS_AFFECTED, SUM_ROWS_SENT, SUM_ROWS_EXAMINED, 
    SUM_CREATED_TMP_DISK_TABLES, SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, SUM_SELECT_FULL_RANGE_JOIN, 
    SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, SUM_SORT_MERGE_PASSES, 
    SUM_SORT_RANGE, SUM_SORT_ROWS, SUM_SORT_SCAN, SUM_NO_INDEX_USED, SUM_NO_GOOD_INDEX_USED
    from events_statements_summary_global_by_event_name
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, 
    SUM_LOCK_TIME, SUM_ERRORS, SUM_WARNINGS, SUM_ROWS_AFFECTED, SUM_ROWS_SENT, SUM_ROWS_EXAMINED, 
    SUM_CREATED_TMP_DISK_TABLES, SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, SUM_SELECT_FULL_RANGE_JOIN, 
    SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, SUM_SORT_MERGE_PASSES, 
    SUM_SORT_RANGE, SUM_SORT_ROWS, SUM_SORT_SCAN, SUM_NO_INDEX_USED, SUM_NO_GOOD_INDEX_USED
    from events_statements_summary_global_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="tid" jdbcType="INTEGER" property="tid" />
    <result column="tname" jdbcType="VARCHAR" property="tname" />
    <result column="tcount" jdbcType="INTEGER" property="tcount" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from hall
    where tid = #{tid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into hall (tid, tname, tcount
      )
    values (#{tid,jdbcType=INTEGER}, #{tname,jdbcType=VARCHAR}, #{tcount,jdbcType=INTEGER}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update hall
    set tname = #{tname,jdbcType=VARCHAR},
      tcount = #{tcount,jdbcType=INTEGER}
    where tid = #{tid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select tid, tname, tcount
    from hall
    where tid = #{tid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select tid, tname, tcount
    from hall
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="SPECIFIC_NAME" jdbcType="VARCHAR" property="specificName" />
    <result column="ROUTINE_CATALOG" jdbcType="VARCHAR" property="routineCatalog" />
    <result column="ROUTINE_SCHEMA" jdbcType="VARCHAR" property="routineSchema" />
    <result column="ROUTINE_NAME" jdbcType="VARCHAR" property="routineName" />
    <result column="ROUTINE_TYPE" jdbcType="CHAR" property="routineType" />
    <result column="CHARACTER_MAXIMUM_LENGTH" jdbcType="BIGINT" property="characterMaximumLength" />
    <result column="CHARACTER_OCTET_LENGTH" jdbcType="BIGINT" property="characterOctetLength" />
    <result column="NUMERIC_PRECISION" jdbcType="INTEGER" property="numericPrecision" />
    <result column="NUMERIC_SCALE" jdbcType="INTEGER" property="numericScale" />
    <result column="DATETIME_PRECISION" jdbcType="INTEGER" property="datetimePrecision" />
    <result column="CHARACTER_SET_NAME" jdbcType="VARCHAR" property="characterSetName" />
    <result column="COLLATION_NAME" jdbcType="VARCHAR" property="collationName" />
    <result column="ROUTINE_BODY" jdbcType="VARCHAR" property="routineBody" />
    <result column="EXTERNAL_LANGUAGE" jdbcType="VARCHAR" property="externalLanguage" />
    <result column="PARAMETER_STYLE" jdbcType="VARCHAR" property="parameterStyle" />
    <result column="IS_DETERMINISTIC" jdbcType="VARCHAR" property="isDeterministic" />
    <result column="SQL_DATA_ACCESS" jdbcType="CHAR" property="sqlDataAccess" />
    <result column="SECURITY_TYPE" jdbcType="CHAR" property="securityType" />
    <result column="CREATED" jdbcType="TIMESTAMP" property="created" />
    <result column="LAST_ALTERED" jdbcType="TIMESTAMP" property="lastAltered" />
    <result column="SQL_MODE" jdbcType="CHAR" property="sqlMode" />
    <result column="DEFINER" jdbcType="VARCHAR" property="definer" />
    <result column="CHARACTER_SET_CLIENT" jdbcType="VARCHAR" property="characterSetClient" />
    <result column="COLLATION_CONNECTION" jdbcType="VARCHAR" property="collationConnection" />
    <result column="DATABASE_COLLATION" jdbcType="VARCHAR" property="databaseCollation" />
    <result column="DATA_TYPE" jdbcType="LONGVARCHAR" property="dataType" />
    <result column="DTD_IDENTIFIER" jdbcType="LONGVARCHAR" property="dtdIdentifier" />
    <result column="ROUTINE_DEFINITION" jdbcType="LONGVARCHAR" property="routineDefinition" />
    <result column="EXTERNAL_NAME" jdbcType="BINARY" property="externalName" />
    <result column="SQL_PATH" jdbcType="BINARY" property="sqlPath" />
    <result column="ROUTINE_COMMENT" jdbcType="LONGVARCHAR" property="routineComment" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into ROUTINES (SPECIFIC_NAME, ROUTINE_CATALOG, ROUTINE_SCHEMA, 
      ROUTINE_NAME, ROUTINE_TYPE, CHARACTER_MAXIMUM_LENGTH, 
      CHARACTER_OCTET_LENGTH, NUMERIC_PRECISION, 
      NUMERIC_SCALE, DATETIME_PRECISION, CHARACTER_SET_NAME, 
      COLLATION_NAME, ROUTINE_BODY, EXTERNAL_LANGUAGE, 
      PARAMETER_STYLE, IS_DETERMINISTIC, SQL_DATA_ACCESS, 
      SECURITY_TYPE, CREATED, LAST_ALTERED, 
      SQL_MODE, DEFINER, CHARACTER_SET_CLIENT, 
      COLLATION_CONNECTION, DATABASE_COLLATION, 
      DATA_TYPE, DTD_IDENTIFIER, ROUTINE_DEFINITION, 
      EXTERNAL_NAME, SQL_PATH, ROUTINE_COMMENT
      )
    values (#{specificName,jdbcType=VARCHAR}, #{routineCatalog,jdbcType=VARCHAR}, #{routineSchema,jdbcType=VARCHAR}, 
      #{routineName,jdbcType=VARCHAR}, #{routineType,jdbcType=CHAR}, #{characterMaximumLength,jdbcType=BIGINT}, 
      #{characterOctetLength,jdbcType=BIGINT}, #{numericPrecision,jdbcType=INTEGER}, 
      #{numericScale,jdbcType=INTEGER}, #{datetimePrecision,jdbcType=INTEGER}, #{characterSetName,jdbcType=VARCHAR}, 
      #{collationName,jdbcType=VARCHAR}, #{routineBody,jdbcType=VARCHAR}, #{externalLanguage,jdbcType=VARCHAR}, 
      #{parameterStyle,jdbcType=VARCHAR}, #{isDeterministic,jdbcType=VARCHAR}, #{sqlDataAccess,jdbcType=CHAR}, 
      #{securityType,jdbcType=CHAR}, #{created,jdbcType=TIMESTAMP}, #{lastAltered,jdbcType=TIMESTAMP}, 
      #{sqlMode,jdbcType=CHAR}, #{definer,jdbcType=VARCHAR}, #{characterSetClient,jdbcType=VARCHAR}, 
      #{collationConnection,jdbcType=VARCHAR}, #{databaseCollation,jdbcType=VARCHAR}, 
      #{dataType,jdbcType=LONGVARCHAR}, #{dtdIdentifier,jdbcType=LONGVARCHAR}, #{routineDefinition,jdbcType=LONGVARCHAR}, 
      #{externalName,jdbcType=BINARY}, #{sqlPath,jdbcType=BINARY}, #{routineComment,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select SPECIFIC_NAME, ROUTINE_CATALOG, ROUTINE_SCHEMA, ROUTINE_NAME, ROUTINE_TYPE, 
    CHARACTER_MAXIMUM_LENGTH, CHARACTER_OCTET_LENGTH, NUMERIC_PRECISION, NUMERIC_SCALE, 
    DATETIME_PRECISION, CHARACTER_SET_NAME, COLLATION_NAME, ROUTINE_BODY, EXTERNAL_LANGUAGE, 
    PARAMETER_STYLE, IS_DETERMINISTIC, SQL_DATA_ACCESS, SECURITY_TYPE, CREATED, LAST_ALTERED, 
    SQL_MODE, DEFINER, CHARACTER_SET_CLIENT, COLLATION_CONNECTION, DATABASE_COLLATION, 
    DATA_TYPE, DTD_IDENTIFIER, ROUTINE_DEFINITION, EXTERNAL_NAME, SQL_PATH, ROUTINE_COMMENT
    from ROUTINES
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="event" jdbcType="VARCHAR" property="event" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="avg_latency" jdbcType="LONGVARCHAR" property="avgLatency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into waits_by_host_by_latency (host, event, total, 
      total_latency, avg_latency, max_latency
      )
    values (#{host,jdbcType=VARCHAR}, #{event,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{totalLatency,jdbcType=LONGVARCHAR}, #{avgLatency,jdbcType=LONGVARCHAR}, #{maxLatency,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, event, total, total_latency, avg_latency, max_latency
    from waits_by_host_by_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="GRANTEE" jdbcType="VARCHAR" property="grantee" />
    <result column="TABLE_CATALOG" jdbcType="VARCHAR" property="tableCatalog" />
    <result column="TABLE_SCHEMA" jdbcType="VARCHAR" property="tableSchema" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
    <result column="PRIVILEGE_TYPE" jdbcType="VARCHAR" property="privilegeType" />
    <result column="IS_GRANTABLE" jdbcType="VARCHAR" property="isGrantable" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into TABLE_PRIVILEGES (GRANTEE, TABLE_CATALOG, TABLE_SCHEMA, 
      TABLE_NAME, PRIVILEGE_TYPE, IS_GRANTABLE
      )
    values (#{grantee,jdbcType=VARCHAR}, #{tableCatalog,jdbcType=VARCHAR}, #{tableSchema,jdbcType=VARCHAR}, 
      #{tableName,jdbcType=VARCHAR}, #{privilegeType,jdbcType=VARCHAR}, #{isGrantable,jdbcType=VARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select GRANTEE, TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, PRIVILEGE_TYPE, IS_GRANTABLE
    from TABLE_PRIVILEGES
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="sugid" jdbcType="BIGINT" property="sugid" />
    <result column="sug" jdbcType="VARCHAR" property="sug" />
    <result column="sug_type" jdbcType="VARCHAR" property="sugType" />
    <result column="sug_url" jdbcType="VARCHAR" property="sugUrl" />
    <result column="sug_date" jdbcType="TIMESTAMP" property="sugDate" />
    <result column="qqAddress" jdbcType="VARCHAR" property="qqaddress" />
    <result column="status" jdbcType="INTEGER" property="status" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from suggest
    where sugid = #{sugid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into suggest (sugid, sug, sug_type, 
      sug_url, sug_date, qqAddress, 
      status)
    values (#{sugid,jdbcType=BIGINT}, #{sug,jdbcType=VARCHAR}, #{sugType,jdbcType=VARCHAR}, 
      #{sugUrl,jdbcType=VARCHAR}, #{sugDate,jdbcType=TIMESTAMP}, #{qqaddress,jdbcType=VARCHAR}, 
      #{status,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update suggest
    set sug = #{sug,jdbcType=VARCHAR},
      sug_type = #{sugType,jdbcType=VARCHAR},
      sug_url = #{sugUrl,jdbcType=VARCHAR},
      sug_date = #{sugDate,jdbcType=TIMESTAMP},
      qqAddress = #{qqaddress,jdbcType=VARCHAR},
      status = #{status,jdbcType=INTEGER}
    where sugid = #{sugid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select sugid, sug, sug_type, sug_url, sug_date, qqAddress, status
    from suggest
    where sugid = #{sugid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select sugid, sug, sug_type, sug_url, sug_date, qqAddress, status
    from suggest
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="ID" jdbcType="VARCHAR" property="id" />
    <result column="FOR_NAME" jdbcType="VARCHAR" property="forName" />
    <result column="REF_NAME" jdbcType="VARCHAR" property="refName" />
    <result column="N_COLS" jdbcType="BIGINT" property="nCols" />
    <result column="TYPE" jdbcType="BIGINT" property="type" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.String">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into INNODB_FOREIGN (FOR_NAME, REF_NAME, N_COLS, 
      TYPE)
    values (#{forName,jdbcType=VARCHAR}, #{refName,jdbcType=VARCHAR}, #{nCols,jdbcType=BIGINT}, 
      #{type,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select ID, FOR_NAME, REF_NAME, N_COLS, TYPE
    from INNODB_FOREIGN
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="id" jdbcType="INTEGER" property="id" />
    <result column="username" jdbcType="VARCHAR" property="username" />
    <result column="number" jdbcType="VARCHAR" property="number" />
    <result column="gender" jdbcType="VARCHAR" property="gender" />
    <result column="dep_id" jdbcType="INTEGER" property="depId" />
    <result column="company_id" jdbcType="INTEGER" property="companyId" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from users
    where id = #{id,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into users (username, number, gender, 
      dep_id, company_id)
    values (#{username,jdbcType=VARCHAR}, #{number,jdbcType=VARCHAR}, #{gender,jdbcType=VARCHAR}, 
      #{depId,jdbcType=INTEGER}, #{companyId,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update users
    set username = #{username,jdbcType=VARCHAR},
      number = #{number,jdbcType=VARCHAR},
      gender = #{gender,jdbcType=VARCHAR},
      dep_id = #{depId,jdbcType=INTEGER},
      company_id = #{companyId,jdbcType=INTEGER}
    where id = #{id,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select id, username, number, gender, dep_id, company_id
    from users
    where id = #{id,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select id, username, number, gender, dep_id, company_id
    from users
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="CHANNEL_NAME" jdbcType="CHAR" property="channelName" />
    <result column="GROUP_NAME" jdbcType="CHAR" property="groupName" />
    <result column="SOURCE_UUID" jdbcType="CHAR" property="sourceUuid" />
    <result column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <result column="SERVICE_STATE" jdbcType="CHAR" property="serviceState" />
    <result column="COUNT_RECEIVED_HEARTBEATS" jdbcType="BIGINT" property="countReceivedHeartbeats" />
    <result column="LAST_HEARTBEAT_TIMESTAMP" jdbcType="TIMESTAMP" property="lastHeartbeatTimestamp" />
    <result column="LAST_ERROR_NUMBER" jdbcType="INTEGER" property="lastErrorNumber" />
    <result column="LAST_ERROR_MESSAGE" jdbcType="VARCHAR" property="lastErrorMessage" />
    <result column="LAST_ERROR_TIMESTAMP" jdbcType="TIMESTAMP" property="lastErrorTimestamp" />
    <result column="LAST_QUEUED_TRANSACTION" jdbcType="CHAR" property="lastQueuedTransaction" />
    <result column="LAST_QUEUED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP" jdbcType="TIMESTAMP" property="lastQueuedTransactionOriginalCommitTimestamp" />
    <result column="LAST_QUEUED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP" jdbcType="TIMESTAMP" property="lastQueuedTransactionImmediateCommitTimestamp" />
    <result column="LAST_QUEUED_TRANSACTION_START_QUEUE_TIMESTAMP" jdbcType="TIMESTAMP" property="lastQueuedTransactionStartQueueTimestamp" />
    <result column="LAST_QUEUED_TRANSACTION_END_QUEUE_TIMESTAMP" jdbcType="TIMESTAMP" property="lastQueuedTransactionEndQueueTimestamp" />
    <result column="QUEUEING_TRANSACTION" jdbcType="CHAR" property="queueingTransaction" />
    <result column="QUEUEING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP" jdbcType="TIMESTAMP" property="queueingTransactionOriginalCommitTimestamp" />
    <result column="QUEUEING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP" jdbcType="TIMESTAMP" property="queueingTransactionImmediateCommitTimestamp" />
    <result column="QUEUEING_TRANSACTION_START_QUEUE_TIMESTAMP" jdbcType="TIMESTAMP" property="queueingTransactionStartQueueTimestamp" />
    <result column="RECEIVED_TRANSACTION_SET" jdbcType="LONGVARCHAR" property="receivedTransactionSet" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from replication_connection_status
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into replication_connection_status (CHANNEL_NAME, GROUP_NAME, SOURCE_UUID, 
      THREAD_ID, SERVICE_STATE, COUNT_RECEIVED_HEARTBEATS, 
      LAST_HEARTBEAT_TIMESTAMP, LAST_ERROR_NUMBER, 
      LAST_ERROR_MESSAGE, LAST_ERROR_TIMESTAMP, 
      LAST_QUEUED_TRANSACTION, LAST_QUEUED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, 
      LAST_QUEUED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, LAST_QUEUED_TRANSACTION_START_QUEUE_TIMESTAMP, 
      LAST_QUEUED_TRANSACTION_END_QUEUE_TIMESTAMP, QUEUEING_TRANSACTION, 
      QUEUEING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, QUEUEING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, 
      QUEUEING_TRANSACTION_START_QUEUE_TIMESTAMP, RECEIVED_TRANSACTION_SET
      )
    values (#{channelName,jdbcType=CHAR}, #{groupName,jdbcType=CHAR}, #{sourceUuid,jdbcType=CHAR}, 
      #{threadId,jdbcType=BIGINT}, #{serviceState,jdbcType=CHAR}, #{countReceivedHeartbeats,jdbcType=BIGINT}, 
      #{lastHeartbeatTimestamp,jdbcType=TIMESTAMP}, #{lastErrorNumber,jdbcType=INTEGER}, 
      #{lastErrorMessage,jdbcType=VARCHAR}, #{lastErrorTimestamp,jdbcType=TIMESTAMP}, 
      #{lastQueuedTransaction,jdbcType=CHAR}, #{lastQueuedTransactionOriginalCommitTimestamp,jdbcType=TIMESTAMP}, 
      #{lastQueuedTransactionImmediateCommitTimestamp,jdbcType=TIMESTAMP}, #{lastQueuedTransactionStartQueueTimestamp,jdbcType=TIMESTAMP}, 
      #{lastQueuedTransactionEndQueueTimestamp,jdbcType=TIMESTAMP}, #{queueingTransaction,jdbcType=CHAR}, 
      #{queueingTransactionOriginalCommitTimestamp,jdbcType=TIMESTAMP}, #{queueingTransactionImmediateCommitTimestamp,jdbcType=TIMESTAMP}, 
      #{queueingTransactionStartQueueTimestamp,jdbcType=TIMESTAMP}, #{receivedTransactionSet,jdbcType=LONGVARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update replication_connection_status
    set GROUP_NAME = #{groupName,jdbcType=CHAR},
      SOURCE_UUID = #{sourceUuid,jdbcType=CHAR},
      THREAD_ID = #{threadId,jdbcType=BIGINT},
      SERVICE_STATE = #{serviceState,jdbcType=CHAR},
      COUNT_RECEIVED_HEARTBEATS = #{countReceivedHeartbeats,jdbcType=BIGINT},
      LAST_HEARTBEAT_TIMESTAMP = #{lastHeartbeatTimestamp,jdbcType=TIMESTAMP},
      LAST_ERROR_NUMBER = #{lastErrorNumber,jdbcType=INTEGER},
      LAST_ERROR_MESSAGE = #{lastErrorMessage,jdbcType=VARCHAR},
      LAST_ERROR_TIMESTAMP = #{lastErrorTimestamp,jdbcType=TIMESTAMP},
      LAST_QUEUED_TRANSACTION = #{lastQueuedTransaction,jdbcType=CHAR},
      LAST_QUEUED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP = #{lastQueuedTransactionOriginalCommitTimestamp,jdbcType=TIMESTAMP},
      LAST_QUEUED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP = #{lastQueuedTransactionImmediateCommitTimestamp,jdbcType=TIMESTAMP},
      LAST_QUEUED_TRANSACTION_START_QUEUE_TIMESTAMP = #{lastQueuedTransactionStartQueueTimestamp,jdbcType=TIMESTAMP},
      LAST_QUEUED_TRANSACTION_END_QUEUE_TIMESTAMP = #{lastQueuedTransactionEndQueueTimestamp,jdbcType=TIMESTAMP},
      QUEUEING_TRANSACTION = #{queueingTransaction,jdbcType=CHAR},
      QUEUEING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP = #{queueingTransactionOriginalCommitTimestamp,jdbcType=TIMESTAMP},
      QUEUEING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP = #{queueingTransactionImmediateCommitTimestamp,jdbcType=TIMESTAMP},
      QUEUEING_TRANSACTION_START_QUEUE_TIMESTAMP = #{queueingTransactionStartQueueTimestamp,jdbcType=TIMESTAMP},
      RECEIVED_TRANSACTION_SET = #{receivedTransactionSet,jdbcType=LONGVARCHAR}
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select CHANNEL_NAME, GROUP_NAME, SOURCE_UUID, THREAD_ID, SERVICE_STATE, COUNT_RECEIVED_HEARTBEATS, 
    LAST_HEARTBEAT_TIMESTAMP, LAST_ERROR_NUMBER, LAST_ERROR_MESSAGE, LAST_ERROR_TIMESTAMP, 
    LAST_QUEUED_TRANSACTION, LAST_QUEUED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, LAST_QUEUED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, 
    LAST_QUEUED_TRANSACTION_START_QUEUE_TIMESTAMP, LAST_QUEUED_TRANSACTION_END_QUEUE_TIMESTAMP, 
    QUEUEING_TRANSACTION, QUEUEING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, QUEUEING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, 
    QUEUEING_TRANSACTION_START_QUEUE_TIMESTAMP, RECEIVED_TRANSACTION_SET
    from replication_connection_status
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select CHANNEL_NAME, GROUP_NAME, SOURCE_UUID, THREAD_ID, SERVICE_STATE, COUNT_RECEIVED_HEARTBEATS, 
    LAST_HEARTBEAT_TIMESTAMP, LAST_ERROR_NUMBER, LAST_ERROR_MESSAGE, LAST_ERROR_TIMESTAMP, 
    LAST_QUEUED_TRANSACTION, LAST_QUEUED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, LAST_QUEUED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, 
    LAST_QUEUED_TRANSACTION_START_QUEUE_TIMESTAMP, LAST_QUEUED_TRANSACTION_END_QUEUE_TIMESTAMP, 
    QUEUEING_TRANSACTION, QUEUEING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP, QUEUEING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP, 
    QUEUEING_TRANSACTION_START_QUEUE_TIMESTAMP, RECEIVED_TRANSACTION_SET
    from replication_connection_status
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="wait_started" jdbcType="TIMESTAMP" property="waitStarted" />
    <result column="wait_age" jdbcType="TIME" property="waitAge" />
    <result column="wait_age_secs" jdbcType="BIGINT" property="waitAgeSecs" />
    <result column="locked_table_schema" jdbcType="VARCHAR" property="lockedTableSchema" />
    <result column="locked_table_name" jdbcType="VARCHAR" property="lockedTableName" />
    <result column="locked_table_partition" jdbcType="VARCHAR" property="lockedTablePartition" />
    <result column="locked_table_subpartition" jdbcType="VARCHAR" property="lockedTableSubpartition" />
    <result column="locked_index" jdbcType="VARCHAR" property="lockedIndex" />
    <result column="locked_type" jdbcType="VARCHAR" property="lockedType" />
    <result column="waiting_trx_id" jdbcType="VARCHAR" property="waitingTrxId" />
    <result column="waiting_trx_started" jdbcType="TIMESTAMP" property="waitingTrxStarted" />
    <result column="waiting_trx_age" jdbcType="TIME" property="waitingTrxAge" />
    <result column="waiting_trx_rows_locked" jdbcType="BIGINT" property="waitingTrxRowsLocked" />
    <result column="waiting_trx_rows_modified" jdbcType="BIGINT" property="waitingTrxRowsModified" />
    <result column="waiting_pid" jdbcType="BIGINT" property="waitingPid" />
    <result column="waiting_query" jdbcType="VARCHAR" property="waitingQuery" />
    <result column="waiting_lock_id" jdbcType="VARCHAR" property="waitingLockId" />
    <result column="waiting_lock_mode" jdbcType="VARCHAR" property="waitingLockMode" />
    <result column="blocking_trx_id" jdbcType="VARCHAR" property="blockingTrxId" />
    <result column="blocking_pid" jdbcType="BIGINT" property="blockingPid" />
    <result column="blocking_query" jdbcType="VARCHAR" property="blockingQuery" />
    <result column="blocking_lock_id" jdbcType="VARCHAR" property="blockingLockId" />
    <result column="blocking_lock_mode" jdbcType="VARCHAR" property="blockingLockMode" />
    <result column="blocking_trx_started" jdbcType="TIMESTAMP" property="blockingTrxStarted" />
    <result column="blocking_trx_age" jdbcType="TIME" property="blockingTrxAge" />
    <result column="blocking_trx_rows_locked" jdbcType="BIGINT" property="blockingTrxRowsLocked" />
    <result column="blocking_trx_rows_modified" jdbcType="BIGINT" property="blockingTrxRowsModified" />
    <result column="sql_kill_blocking_query" jdbcType="VARCHAR" property="sqlKillBlockingQuery" />
    <result column="sql_kill_blocking_connection" jdbcType="VARCHAR" property="sqlKillBlockingConnection" />
    <result column="locked_table" jdbcType="LONGVARCHAR" property="lockedTable" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$innodb_lock_waits (wait_started, wait_age, wait_age_secs, 
      locked_table_schema, locked_table_name, locked_table_partition, 
      locked_table_subpartition, locked_index, locked_type, 
      waiting_trx_id, waiting_trx_started, waiting_trx_age, 
      waiting_trx_rows_locked, waiting_trx_rows_modified, 
      waiting_pid, waiting_query, waiting_lock_id, 
      waiting_lock_mode, blocking_trx_id, blocking_pid, 
      blocking_query, blocking_lock_id, blocking_lock_mode, 
      blocking_trx_started, blocking_trx_age, blocking_trx_rows_locked, 
      blocking_trx_rows_modified, sql_kill_blocking_query, 
      sql_kill_blocking_connection, locked_table
      )
    values (#{waitStarted,jdbcType=TIMESTAMP}, #{waitAge,jdbcType=TIME}, #{waitAgeSecs,jdbcType=BIGINT}, 
      #{lockedTableSchema,jdbcType=VARCHAR}, #{lockedTableName,jdbcType=VARCHAR}, #{lockedTablePartition,jdbcType=VARCHAR}, 
      #{lockedTableSubpartition,jdbcType=VARCHAR}, #{lockedIndex,jdbcType=VARCHAR}, #{lockedType,jdbcType=VARCHAR}, 
      #{waitingTrxId,jdbcType=VARCHAR}, #{waitingTrxStarted,jdbcType=TIMESTAMP}, #{waitingTrxAge,jdbcType=TIME}, 
      #{waitingTrxRowsLocked,jdbcType=BIGINT}, #{waitingTrxRowsModified,jdbcType=BIGINT}, 
      #{waitingPid,jdbcType=BIGINT}, #{waitingQuery,jdbcType=VARCHAR}, #{waitingLockId,jdbcType=VARCHAR}, 
      #{waitingLockMode,jdbcType=VARCHAR}, #{blockingTrxId,jdbcType=VARCHAR}, #{blockingPid,jdbcType=BIGINT}, 
      #{blockingQuery,jdbcType=VARCHAR}, #{blockingLockId,jdbcType=VARCHAR}, #{blockingLockMode,jdbcType=VARCHAR}, 
      #{blockingTrxStarted,jdbcType=TIMESTAMP}, #{blockingTrxAge,jdbcType=TIME}, #{blockingTrxRowsLocked,jdbcType=BIGINT}, 
      #{blockingTrxRowsModified,jdbcType=BIGINT}, #{sqlKillBlockingQuery,jdbcType=VARCHAR}, 
      #{sqlKillBlockingConnection,jdbcType=VARCHAR}, #{lockedTable,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select wait_started, wait_age, wait_age_secs, locked_table_schema, locked_table_name, 
    locked_table_partition, locked_table_subpartition, locked_index, locked_type, waiting_trx_id, 
    waiting_trx_started, waiting_trx_age, waiting_trx_rows_locked, waiting_trx_rows_modified, 
    waiting_pid, waiting_query, waiting_lock_id, waiting_lock_mode, blocking_trx_id, 
    blocking_pid, blocking_query, blocking_lock_id, blocking_lock_mode, blocking_trx_started, 
    blocking_trx_age, blocking_trx_rows_locked, blocking_trx_rows_modified, sql_kill_blocking_query, 
    sql_kill_blocking_connection, locked_table
    from x$innodb_lock_waits
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="CHANNEL_NAME" jdbcType="CHAR" property="channelName" />
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="PORT" jdbcType="INTEGER" property="port" />
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="NETWORK_INTERFACE" jdbcType="CHAR" property="networkInterface" />
    <result column="AUTO_POSITION" jdbcType="CHAR" property="autoPosition" />
    <result column="SSL_ALLOWED" jdbcType="CHAR" property="sslAllowed" />
    <result column="SSL_CA_FILE" jdbcType="VARCHAR" property="sslCaFile" />
    <result column="SSL_CA_PATH" jdbcType="VARCHAR" property="sslCaPath" />
    <result column="SSL_CERTIFICATE" jdbcType="VARCHAR" property="sslCertificate" />
    <result column="SSL_CIPHER" jdbcType="VARCHAR" property="sslCipher" />
    <result column="SSL_KEY" jdbcType="VARCHAR" property="sslKey" />
    <result column="SSL_VERIFY_SERVER_CERTIFICATE" jdbcType="CHAR" property="sslVerifyServerCertificate" />
    <result column="SSL_CRL_FILE" jdbcType="VARCHAR" property="sslCrlFile" />
    <result column="SSL_CRL_PATH" jdbcType="VARCHAR" property="sslCrlPath" />
    <result column="CONNECTION_RETRY_INTERVAL" jdbcType="INTEGER" property="connectionRetryInterval" />
    <result column="CONNECTION_RETRY_COUNT" jdbcType="BIGINT" property="connectionRetryCount" />
    <result column="HEARTBEAT_INTERVAL" jdbcType="DOUBLE" property="heartbeatInterval" />
    <result column="TLS_VERSION" jdbcType="VARCHAR" property="tlsVersion" />
    <result column="PUBLIC_KEY_PATH" jdbcType="VARCHAR" property="publicKeyPath" />
    <result column="GET_PUBLIC_KEY" jdbcType="CHAR" property="getPublicKey" />
    <result column="NETWORK_NAMESPACE" jdbcType="VARCHAR" property="networkNamespace" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from replication_connection_configuration
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into replication_connection_configuration (CHANNEL_NAME, HOST, PORT, 
      USER, NETWORK_INTERFACE, AUTO_POSITION, 
      SSL_ALLOWED, SSL_CA_FILE, SSL_CA_PATH, 
      SSL_CERTIFICATE, SSL_CIPHER, SSL_KEY, 
      SSL_VERIFY_SERVER_CERTIFICATE, SSL_CRL_FILE, SSL_CRL_PATH, 
      CONNECTION_RETRY_INTERVAL, CONNECTION_RETRY_COUNT, 
      HEARTBEAT_INTERVAL, TLS_VERSION, PUBLIC_KEY_PATH, 
      GET_PUBLIC_KEY, NETWORK_NAMESPACE)
    values (#{channelName,jdbcType=CHAR}, #{host,jdbcType=CHAR}, #{port,jdbcType=INTEGER}, 
      #{user,jdbcType=CHAR}, #{networkInterface,jdbcType=CHAR}, #{autoPosition,jdbcType=CHAR}, 
      #{sslAllowed,jdbcType=CHAR}, #{sslCaFile,jdbcType=VARCHAR}, #{sslCaPath,jdbcType=VARCHAR}, 
      #{sslCertificate,jdbcType=VARCHAR}, #{sslCipher,jdbcType=VARCHAR}, #{sslKey,jdbcType=VARCHAR}, 
      #{sslVerifyServerCertificate,jdbcType=CHAR}, #{sslCrlFile,jdbcType=VARCHAR}, #{sslCrlPath,jdbcType=VARCHAR}, 
      #{connectionRetryInterval,jdbcType=INTEGER}, #{connectionRetryCount,jdbcType=BIGINT}, 
      #{heartbeatInterval,jdbcType=DOUBLE}, #{tlsVersion,jdbcType=VARCHAR}, #{publicKeyPath,jdbcType=VARCHAR}, 
      #{getPublicKey,jdbcType=CHAR}, #{networkNamespace,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update replication_connection_configuration
    set HOST = #{host,jdbcType=CHAR},
      PORT = #{port,jdbcType=INTEGER},
      USER = #{user,jdbcType=CHAR},
      NETWORK_INTERFACE = #{networkInterface,jdbcType=CHAR},
      AUTO_POSITION = #{autoPosition,jdbcType=CHAR},
      SSL_ALLOWED = #{sslAllowed,jdbcType=CHAR},
      SSL_CA_FILE = #{sslCaFile,jdbcType=VARCHAR},
      SSL_CA_PATH = #{sslCaPath,jdbcType=VARCHAR},
      SSL_CERTIFICATE = #{sslCertificate,jdbcType=VARCHAR},
      SSL_CIPHER = #{sslCipher,jdbcType=VARCHAR},
      SSL_KEY = #{sslKey,jdbcType=VARCHAR},
      SSL_VERIFY_SERVER_CERTIFICATE = #{sslVerifyServerCertificate,jdbcType=CHAR},
      SSL_CRL_FILE = #{sslCrlFile,jdbcType=VARCHAR},
      SSL_CRL_PATH = #{sslCrlPath,jdbcType=VARCHAR},
      CONNECTION_RETRY_INTERVAL = #{connectionRetryInterval,jdbcType=INTEGER},
      CONNECTION_RETRY_COUNT = #{connectionRetryCount,jdbcType=BIGINT},
      HEARTBEAT_INTERVAL = #{heartbeatInterval,jdbcType=DOUBLE},
      TLS_VERSION = #{tlsVersion,jdbcType=VARCHAR},
      PUBLIC_KEY_PATH = #{publicKeyPath,jdbcType=VARCHAR},
      GET_PUBLIC_KEY = #{getPublicKey,jdbcType=CHAR},
      NETWORK_NAMESPACE = #{networkNamespace,jdbcType=VARCHAR}
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select CHANNEL_NAME, HOST, PORT, USER, NETWORK_INTERFACE, AUTO_POSITION, SSL_ALLOWED, 
    SSL_CA_FILE, SSL_CA_PATH, SSL_CERTIFICATE, SSL_CIPHER, SSL_KEY, SSL_VERIFY_SERVER_CERTIFICATE, 
    SSL_CRL_FILE, SSL_CRL_PATH, CONNECTION_RETRY_INTERVAL, CONNECTION_RETRY_COUNT, HEARTBEAT_INTERVAL, 
    TLS_VERSION, PUBLIC_KEY_PATH, GET_PUBLIC_KEY, NETWORK_NAMESPACE
    from replication_connection_configuration
    where CHANNEL_NAME = #{channelName,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select CHANNEL_NAME, HOST, PORT, USER, NETWORK_INTERFACE, AUTO_POSITION, SSL_ALLOWED, 
    SSL_CA_FILE, SSL_CA_PATH, SSL_CERTIFICATE, SSL_CIPHER, SSL_KEY, SSL_VERIFY_SERVER_CERTIFICATE, 
    SSL_CRL_FILE, SSL_CRL_PATH, CONNECTION_RETRY_INTERVAL, CONNECTION_RETRY_COUNT, HEARTBEAT_INTERVAL, 
    TLS_VERSION, PUBLIC_KEY_PATH, GET_PUBLIC_KEY, NETWORK_NAMESPACE
    from replication_connection_configuration
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="id" jdbcType="BIGINT" property="id" />
    <result column="name" jdbcType="VARCHAR" property="name" />
    <result column="price" jdbcType="BIGINT" property="price" />
    <result column="sale_price" jdbcType="BIGINT" property="salePrice" />
    <result column="sale_point" jdbcType="VARCHAR" property="salePoint" />
    <result column="image_url" jdbcType="VARCHAR" property="imageUrl" />
    <result column="stock" jdbcType="BIGINT" property="stock" />
    <result column="flag" jdbcType="INTEGER" property="flag" />
    <result column="create_time" jdbcType="VARCHAR" property="createTime" />
    <result column="update_time" jdbcType="VARCHAR" property="updateTime" />
    <result column="create_user" jdbcType="BIGINT" property="createUser" />
    <result column="update_user" jdbcType="BIGINT" property="updateUser" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from t_products
    where id = #{id,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Long">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into t_products (name, price, sale_price, 
      sale_point, image_url, stock, 
      flag, create_time, update_time, 
      create_user, update_user)
    values (#{name,jdbcType=VARCHAR}, #{price,jdbcType=BIGINT}, #{salePrice,jdbcType=BIGINT}, 
      #{salePoint,jdbcType=VARCHAR}, #{imageUrl,jdbcType=VARCHAR}, #{stock,jdbcType=BIGINT}, 
      #{flag,jdbcType=INTEGER}, #{createTime,jdbcType=VARCHAR}, #{updateTime,jdbcType=VARCHAR}, 
      #{createUser,jdbcType=BIGINT}, #{updateUser,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update t_products
    set name = #{name,jdbcType=VARCHAR},
      price = #{price,jdbcType=BIGINT},
      sale_price = #{salePrice,jdbcType=BIGINT},
      sale_point = #{salePoint,jdbcType=VARCHAR},
      image_url = #{imageUrl,jdbcType=VARCHAR},
      stock = #{stock,jdbcType=BIGINT},
      flag = #{flag,jdbcType=INTEGER},
      create_time = #{createTime,jdbcType=VARCHAR},
      update_time = #{updateTime,jdbcType=VARCHAR},
      create_user = #{createUser,jdbcType=BIGINT},
      update_user = #{updateUser,jdbcType=BIGINT}
    where id = #{id,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select id, name, price, sale_price, sale_point, image_url, stock, flag, create_time, 
    update_time, create_user, update_user
    from t_products
    where id = #{id,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select id, name, price, sale_price, sale_point, image_url, stock, flag, create_time, 
    update_time, create_user, update_user
    from t_products
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="VARIABLE_NAME" jdbcType="VARCHAR" property="variableName" />
    <result column="VARIABLE_VALUE" jdbcType="VARCHAR" property="variableValue" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into status_by_account (USER, HOST, VARIABLE_NAME, 
      VARIABLE_VALUE)
    values (#{user,jdbcType=CHAR}, #{host,jdbcType=CHAR}, #{variableName,jdbcType=VARCHAR}, 
      #{variableValue,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, HOST, VARIABLE_NAME, VARIABLE_VALUE
    from status_by_account
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="statements" jdbcType="DECIMAL" property="statements" />
    <result column="statement_latency" jdbcType="DECIMAL" property="statementLatency" />
    <result column="statement_avg_latency" jdbcType="DECIMAL" property="statementAvgLatency" />
    <result column="table_scans" jdbcType="DECIMAL" property="tableScans" />
    <result column="file_ios" jdbcType="DECIMAL" property="fileIos" />
    <result column="file_io_latency" jdbcType="DECIMAL" property="fileIoLatency" />
    <result column="current_connections" jdbcType="DECIMAL" property="currentConnections" />
    <result column="total_connections" jdbcType="DECIMAL" property="totalConnections" />
    <result column="unique_users" jdbcType="BIGINT" property="uniqueUsers" />
    <result column="current_memory" jdbcType="DECIMAL" property="currentMemory" />
    <result column="total_memory_allocated" jdbcType="DECIMAL" property="totalMemoryAllocated" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$host_summary (host, statements, statement_latency, 
      statement_avg_latency, table_scans, file_ios, 
      file_io_latency, current_connections, total_connections, 
      unique_users, current_memory, total_memory_allocated
      )
    values (#{host,jdbcType=VARCHAR}, #{statements,jdbcType=DECIMAL}, #{statementLatency,jdbcType=DECIMAL}, 
      #{statementAvgLatency,jdbcType=DECIMAL}, #{tableScans,jdbcType=DECIMAL}, #{fileIos,jdbcType=DECIMAL}, 
      #{fileIoLatency,jdbcType=DECIMAL}, #{currentConnections,jdbcType=DECIMAL}, #{totalConnections,jdbcType=DECIMAL}, 
      #{uniqueUsers,jdbcType=BIGINT}, #{currentMemory,jdbcType=DECIMAL}, #{totalMemoryAllocated,jdbcType=DECIMAL}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, statements, statement_latency, statement_avg_latency, table_scans, file_ios, 
    file_io_latency, current_connections, total_connections, unique_users, current_memory, 
    total_memory_allocated
    from x$host_summary
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="cost_name" jdbcType="VARCHAR" property="costName" />
    <result column="cost_value" jdbcType="REAL" property="costValue" />
    <result column="last_update" jdbcType="TIMESTAMP" property="lastUpdate" />
    <result column="comment" jdbcType="VARCHAR" property="comment" />
    <result column="default_value" jdbcType="REAL" property="defaultValue" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from server_cost
    where cost_name = #{costName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into server_cost (cost_name, cost_value, last_update, 
      comment, default_value)
    values (#{costName,jdbcType=VARCHAR}, #{costValue,jdbcType=REAL}, #{lastUpdate,jdbcType=TIMESTAMP}, 
      #{comment,jdbcType=VARCHAR}, #{defaultValue,jdbcType=REAL})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update server_cost
    set cost_value = #{costValue,jdbcType=REAL},
      last_update = #{lastUpdate,jdbcType=TIMESTAMP},
      comment = #{comment,jdbcType=VARCHAR},
      default_value = #{defaultValue,jdbcType=REAL}
    where cost_name = #{costName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select cost_name, cost_value, last_update, comment, default_value
    from server_cost
    where cost_name = #{costName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select cost_name, cost_value, last_update, comment, default_value
    from server_cost
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="help_keyword_id" jdbcType="INTEGER" property="helpKeywordId" />
    <result column="name" jdbcType="CHAR" property="name" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from help_keyword
    where help_keyword_id = #{helpKeywordId,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into help_keyword (help_keyword_id, name)
    values (#{helpKeywordId,jdbcType=INTEGER}, #{name,jdbcType=CHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update help_keyword
    set name = #{name,jdbcType=CHAR}
    where help_keyword_id = #{helpKeywordId,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select help_keyword_id, name
    from help_keyword
    where help_keyword_id = #{helpKeywordId,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select help_keyword_id, name
    from help_keyword
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="TABLESPACE_NAME" jdbcType="VARCHAR" property="tablespaceName" />
    <result column="ENGINE" jdbcType="VARCHAR" property="engine" />
    <result column="TABLESPACE_TYPE" jdbcType="VARCHAR" property="tablespaceType" />
    <result column="LOGFILE_GROUP_NAME" jdbcType="VARCHAR" property="logfileGroupName" />
    <result column="EXTENT_SIZE" jdbcType="BIGINT" property="extentSize" />
    <result column="AUTOEXTEND_SIZE" jdbcType="BIGINT" property="autoextendSize" />
    <result column="MAXIMUM_SIZE" jdbcType="BIGINT" property="maximumSize" />
    <result column="NODEGROUP_ID" jdbcType="BIGINT" property="nodegroupId" />
    <result column="TABLESPACE_COMMENT" jdbcType="VARCHAR" property="tablespaceComment" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into TABLESPACES (TABLESPACE_NAME, ENGINE, TABLESPACE_TYPE, 
      LOGFILE_GROUP_NAME, EXTENT_SIZE, AUTOEXTEND_SIZE, 
      MAXIMUM_SIZE, NODEGROUP_ID, TABLESPACE_COMMENT
      )
    values (#{tablespaceName,jdbcType=VARCHAR}, #{engine,jdbcType=VARCHAR}, #{tablespaceType,jdbcType=VARCHAR}, 
      #{logfileGroupName,jdbcType=VARCHAR}, #{extentSize,jdbcType=BIGINT}, #{autoextendSize,jdbcType=BIGINT}, 
      #{maximumSize,jdbcType=BIGINT}, #{nodegroupId,jdbcType=BIGINT}, #{tablespaceComment,jdbcType=VARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select TABLESPACE_NAME, ENGINE, TABLESPACE_TYPE, LOGFILE_GROUP_NAME, EXTENT_SIZE, 
    AUTOEXTEND_SIZE, MAXIMUM_SIZE, NODEGROUP_ID, TABLESPACE_COMMENT
    from TABLESPACES
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="OBJECT_TYPE" jdbcType="CHAR" property="objectType" />
    <result column="OBJECT_SCHEMA" jdbcType="VARCHAR" property="objectSchema" />
    <result column="OBJECT_NAME" jdbcType="VARCHAR" property="objectName" />
    <result column="ENABLED" jdbcType="CHAR" property="enabled" />
    <result column="TIMED" jdbcType="CHAR" property="timed" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into setup_objects (OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, 
      ENABLED, TIMED)
    values (#{objectType,jdbcType=CHAR}, #{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, 
      #{enabled,jdbcType=CHAR}, #{timed,jdbcType=CHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, ENABLED, TIMED
    from setup_objects
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="VARIABLE_NAME" jdbcType="VARCHAR" property="variableName" />
    <result column="VARIABLE_VALUE" jdbcType="VARCHAR" property="variableValue" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from global_status
    where VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into global_status (VARIABLE_NAME, VARIABLE_VALUE)
    values (#{variableName,jdbcType=VARCHAR}, #{variableValue,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update global_status
    set VARIABLE_VALUE = #{variableValue,jdbcType=VARCHAR}
    where VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select VARIABLE_NAME, VARIABLE_VALUE
    from global_status
    where VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select VARIABLE_NAME, VARIABLE_VALUE
    from global_status
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="POOL_ID" jdbcType="BIGINT" property="poolId" />
    <result column="LRU_POSITION" jdbcType="BIGINT" property="lruPosition" />
    <result column="SPACE" jdbcType="BIGINT" property="space" />
    <result column="PAGE_NUMBER" jdbcType="BIGINT" property="pageNumber" />
    <result column="PAGE_TYPE" jdbcType="VARCHAR" property="pageType" />
    <result column="FLUSH_TYPE" jdbcType="BIGINT" property="flushType" />
    <result column="FIX_COUNT" jdbcType="BIGINT" property="fixCount" />
    <result column="IS_HASHED" jdbcType="VARCHAR" property="isHashed" />
    <result column="NEWEST_MODIFICATION" jdbcType="BIGINT" property="newestModification" />
    <result column="OLDEST_MODIFICATION" jdbcType="BIGINT" property="oldestModification" />
    <result column="ACCESS_TIME" jdbcType="BIGINT" property="accessTime" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
    <result column="INDEX_NAME" jdbcType="VARCHAR" property="indexName" />
    <result column="NUMBER_RECORDS" jdbcType="BIGINT" property="numberRecords" />
    <result column="DATA_SIZE" jdbcType="BIGINT" property="dataSize" />
    <result column="COMPRESSED_SIZE" jdbcType="BIGINT" property="compressedSize" />
    <result column="COMPRESSED" jdbcType="VARCHAR" property="compressed" />
    <result column="IO_FIX" jdbcType="VARCHAR" property="ioFix" />
    <result column="IS_OLD" jdbcType="VARCHAR" property="isOld" />
    <result column="FREE_PAGE_CLOCK" jdbcType="BIGINT" property="freePageClock" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_BUFFER_PAGE_LRU (POOL_ID, LRU_POSITION, SPACE, 
      PAGE_NUMBER, PAGE_TYPE, FLUSH_TYPE, 
      FIX_COUNT, IS_HASHED, NEWEST_MODIFICATION, 
      OLDEST_MODIFICATION, ACCESS_TIME, TABLE_NAME, 
      INDEX_NAME, NUMBER_RECORDS, DATA_SIZE, 
      COMPRESSED_SIZE, COMPRESSED, IO_FIX, 
      IS_OLD, FREE_PAGE_CLOCK)
    values (#{poolId,jdbcType=BIGINT}, #{lruPosition,jdbcType=BIGINT}, #{space,jdbcType=BIGINT}, 
      #{pageNumber,jdbcType=BIGINT}, #{pageType,jdbcType=VARCHAR}, #{flushType,jdbcType=BIGINT}, 
      #{fixCount,jdbcType=BIGINT}, #{isHashed,jdbcType=VARCHAR}, #{newestModification,jdbcType=BIGINT}, 
      #{oldestModification,jdbcType=BIGINT}, #{accessTime,jdbcType=BIGINT}, #{tableName,jdbcType=VARCHAR}, 
      #{indexName,jdbcType=VARCHAR}, #{numberRecords,jdbcType=BIGINT}, #{dataSize,jdbcType=BIGINT}, 
      #{compressedSize,jdbcType=BIGINT}, #{compressed,jdbcType=VARCHAR}, #{ioFix,jdbcType=VARCHAR}, 
      #{isOld,jdbcType=VARCHAR}, #{freePageClock,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select POOL_ID, LRU_POSITION, SPACE, PAGE_NUMBER, PAGE_TYPE, FLUSH_TYPE, FIX_COUNT, 
    IS_HASHED, NEWEST_MODIFICATION, OLDEST_MODIFICATION, ACCESS_TIME, TABLE_NAME, INDEX_NAME, 
    NUMBER_RECORDS, DATA_SIZE, COMPRESSED_SIZE, COMPRESSED, IO_FIX, IS_OLD, FREE_PAGE_CLOCK
    from INNODB_BUFFER_PAGE_LRU
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="HOST" jdbcType="CHAR" property="host" />
    <id column="USER" jdbcType="CHAR" property="user" />
    <id column="ROLE" jdbcType="CHAR" property="role" />
    <result column="ENABLED" jdbcType="CHAR" property="enabled" />
    <result column="HISTORY" jdbcType="CHAR" property="history" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from setup_actors
    where HOST = #{host,jdbcType=CHAR}
      and USER = #{user,jdbcType=CHAR}
      and ROLE = #{role,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into setup_actors (HOST, USER, ROLE, ENABLED, 
      HISTORY)
    values (#{host,jdbcType=CHAR}, #{user,jdbcType=CHAR}, #{role,jdbcType=CHAR}, #{enabled,jdbcType=CHAR}, 
      #{history,jdbcType=CHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update setup_actors
    set ENABLED = #{enabled,jdbcType=CHAR},
      HISTORY = #{history,jdbcType=CHAR}
    where HOST = #{host,jdbcType=CHAR}
      and USER = #{user,jdbcType=CHAR}
      and ROLE = #{role,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select HOST, USER, ROLE, ENABLED, HISTORY
    from setup_actors
    where HOST = #{host,jdbcType=CHAR}
      and USER = #{user,jdbcType=CHAR}
      and ROLE = #{role,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select HOST, USER, ROLE, ENABLED, HISTORY
    from setup_actors
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="lid" jdbcType="BIGINT" property="lid" />
    <result column="username" jdbcType="VARCHAR" property="username" />
    <result column="operation" jdbcType="VARCHAR" property="operation" />
    <result column="method" jdbcType="VARCHAR" property="method" />
    <result column="ip" jdbcType="VARCHAR" property="ip" />
    <result column="browser" jdbcType="VARCHAR" property="browser" />
    <result column="type" jdbcType="VARCHAR" property="type" />
    <result column="version" jdbcType="VARCHAR" property="version" />
    <result column="createdate" jdbcType="TIMESTAMP" property="createdate" />
    <result column="params" jdbcType="LONGVARCHAR" property="params" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from syslog
    where lid = #{lid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into syslog (lid, username, operation, 
      method, ip, browser, 
      type, version, createdate, 
      params)
    values (#{lid,jdbcType=BIGINT}, #{username,jdbcType=VARCHAR}, #{operation,jdbcType=VARCHAR}, 
      #{method,jdbcType=VARCHAR}, #{ip,jdbcType=VARCHAR}, #{browser,jdbcType=VARCHAR}, 
      #{type,jdbcType=VARCHAR}, #{version,jdbcType=VARCHAR}, #{createdate,jdbcType=TIMESTAMP}, 
      #{params,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update syslog
    set username = #{username,jdbcType=VARCHAR},
      operation = #{operation,jdbcType=VARCHAR},
      method = #{method,jdbcType=VARCHAR},
      ip = #{ip,jdbcType=VARCHAR},
      browser = #{browser,jdbcType=VARCHAR},
      type = #{type,jdbcType=VARCHAR},
      version = #{version,jdbcType=VARCHAR},
      createdate = #{createdate,jdbcType=TIMESTAMP},
      params = #{params,jdbcType=LONGVARCHAR}
    where lid = #{lid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select lid, username, operation, method, ip, browser, type, version, createdate, 
    params
    from syslog
    where lid = #{lid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select lid, username, operation, method, ip, browser, type, version, createdate, 
    params
    from syslog
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="ID" jdbcType="VARCHAR" property="id" />
    <result column="FOR_COL_NAME" jdbcType="VARCHAR" property="forColName" />
    <result column="REF_COL_NAME" jdbcType="VARCHAR" property="refColName" />
    <result column="POS" jdbcType="INTEGER" property="pos" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.String">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into INNODB_FOREIGN_COLS (FOR_COL_NAME, REF_COL_NAME, POS
      )
    values (#{forColName,jdbcType=VARCHAR}, #{refColName,jdbcType=VARCHAR}, #{pos,jdbcType=INTEGER}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select ID, FOR_COL_NAME, REF_COL_NAME, POS
    from INNODB_FOREIGN_COLS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="NAME" jdbcType="VARCHAR" property="name" />
    <result column="ENABLED" jdbcType="CHAR" property="enabled" />
    <result column="TIMED" jdbcType="CHAR" property="timed" />
    <result column="PROPERTIES" jdbcType="CHAR" property="properties" />
    <result column="VOLATILITY" jdbcType="INTEGER" property="volatility" />
    <result column="DOCUMENTATION" jdbcType="LONGVARCHAR" property="documentation" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from setup_instruments
    where NAME = #{name,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into setup_instruments (NAME, ENABLED, TIMED, 
      PROPERTIES, VOLATILITY, DOCUMENTATION
      )
    values (#{name,jdbcType=VARCHAR}, #{enabled,jdbcType=CHAR}, #{timed,jdbcType=CHAR}, 
      #{properties,jdbcType=CHAR}, #{volatility,jdbcType=INTEGER}, #{documentation,jdbcType=LONGVARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update setup_instruments
    set ENABLED = #{enabled,jdbcType=CHAR},
      TIMED = #{timed,jdbcType=CHAR},
      PROPERTIES = #{properties,jdbcType=CHAR},
      VOLATILITY = #{volatility,jdbcType=INTEGER},
      DOCUMENTATION = #{documentation,jdbcType=LONGVARCHAR}
    where NAME = #{name,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select NAME, ENABLED, TIMED, PROPERTIES, VOLATILITY, DOCUMENTATION
    from setup_instruments
    where NAME = #{name,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select NAME, ENABLED, TIMED, PROPERTIES, VOLATILITY, DOCUMENTATION
    from setup_instruments
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="EVENT_ID" jdbcType="BIGINT" property="eventId" />
    <result column="END_EVENT_ID" jdbcType="BIGINT" property="endEventId" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="SOURCE" jdbcType="VARCHAR" property="source" />
    <result column="TIMER_START" jdbcType="BIGINT" property="timerStart" />
    <result column="TIMER_END" jdbcType="BIGINT" property="timerEnd" />
    <result column="TIMER_WAIT" jdbcType="BIGINT" property="timerWait" />
    <result column="LOCK_TIME" jdbcType="BIGINT" property="lockTime" />
    <result column="DIGEST" jdbcType="VARCHAR" property="digest" />
    <result column="CURRENT_SCHEMA" jdbcType="VARCHAR" property="currentSchema" />
    <result column="OBJECT_TYPE" jdbcType="VARCHAR" property="objectType" />
    <result column="OBJECT_SCHEMA" jdbcType="VARCHAR" property="objectSchema" />
    <result column="OBJECT_NAME" jdbcType="VARCHAR" property="objectName" />
    <result column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="MYSQL_ERRNO" jdbcType="INTEGER" property="mysqlErrno" />
    <result column="RETURNED_SQLSTATE" jdbcType="VARCHAR" property="returnedSqlstate" />
    <result column="MESSAGE_TEXT" jdbcType="VARCHAR" property="messageText" />
    <result column="ERRORS" jdbcType="BIGINT" property="errors" />
    <result column="WARNINGS" jdbcType="BIGINT" property="warnings" />
    <result column="ROWS_AFFECTED" jdbcType="BIGINT" property="rowsAffected" />
    <result column="ROWS_SENT" jdbcType="BIGINT" property="rowsSent" />
    <result column="ROWS_EXAMINED" jdbcType="BIGINT" property="rowsExamined" />
    <result column="CREATED_TMP_DISK_TABLES" jdbcType="BIGINT" property="createdTmpDiskTables" />
    <result column="CREATED_TMP_TABLES" jdbcType="BIGINT" property="createdTmpTables" />
    <result column="SELECT_FULL_JOIN" jdbcType="BIGINT" property="selectFullJoin" />
    <result column="SELECT_FULL_RANGE_JOIN" jdbcType="BIGINT" property="selectFullRangeJoin" />
    <result column="SELECT_RANGE" jdbcType="BIGINT" property="selectRange" />
    <result column="SELECT_RANGE_CHECK" jdbcType="BIGINT" property="selectRangeCheck" />
    <result column="SELECT_SCAN" jdbcType="BIGINT" property="selectScan" />
    <result column="SORT_MERGE_PASSES" jdbcType="BIGINT" property="sortMergePasses" />
    <result column="SORT_RANGE" jdbcType="BIGINT" property="sortRange" />
    <result column="SORT_ROWS" jdbcType="BIGINT" property="sortRows" />
    <result column="SORT_SCAN" jdbcType="BIGINT" property="sortScan" />
    <result column="NO_INDEX_USED" jdbcType="BIGINT" property="noIndexUsed" />
    <result column="NO_GOOD_INDEX_USED" jdbcType="BIGINT" property="noGoodIndexUsed" />
    <result column="NESTING_EVENT_ID" jdbcType="BIGINT" property="nestingEventId" />
    <result column="NESTING_EVENT_TYPE" jdbcType="CHAR" property="nestingEventType" />
    <result column="NESTING_EVENT_LEVEL" jdbcType="INTEGER" property="nestingEventLevel" />
    <result column="STATEMENT_ID" jdbcType="BIGINT" property="statementId" />
    <result column="SQL_TEXT" jdbcType="LONGVARCHAR" property="sqlText" />
    <result column="DIGEST_TEXT" jdbcType="LONGVARCHAR" property="digestText" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from events_statements_current
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_statements_current (THREAD_ID, EVENT_ID, END_EVENT_ID, 
      EVENT_NAME, SOURCE, TIMER_START, 
      TIMER_END, TIMER_WAIT, LOCK_TIME, 
      DIGEST, CURRENT_SCHEMA, OBJECT_TYPE, 
      OBJECT_SCHEMA, OBJECT_NAME, OBJECT_INSTANCE_BEGIN, 
      MYSQL_ERRNO, RETURNED_SQLSTATE, MESSAGE_TEXT, 
      ERRORS, WARNINGS, ROWS_AFFECTED, 
      ROWS_SENT, ROWS_EXAMINED, CREATED_TMP_DISK_TABLES, 
      CREATED_TMP_TABLES, SELECT_FULL_JOIN, SELECT_FULL_RANGE_JOIN, 
      SELECT_RANGE, SELECT_RANGE_CHECK, SELECT_SCAN, 
      SORT_MERGE_PASSES, SORT_RANGE, SORT_ROWS, 
      SORT_SCAN, NO_INDEX_USED, NO_GOOD_INDEX_USED, 
      NESTING_EVENT_ID, NESTING_EVENT_TYPE, NESTING_EVENT_LEVEL, 
      STATEMENT_ID, SQL_TEXT, DIGEST_TEXT
      )
    values (#{threadId,jdbcType=BIGINT}, #{eventId,jdbcType=BIGINT}, #{endEventId,jdbcType=BIGINT}, 
      #{eventName,jdbcType=VARCHAR}, #{source,jdbcType=VARCHAR}, #{timerStart,jdbcType=BIGINT}, 
      #{timerEnd,jdbcType=BIGINT}, #{timerWait,jdbcType=BIGINT}, #{lockTime,jdbcType=BIGINT}, 
      #{digest,jdbcType=VARCHAR}, #{currentSchema,jdbcType=VARCHAR}, #{objectType,jdbcType=VARCHAR}, 
      #{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, #{objectInstanceBegin,jdbcType=BIGINT}, 
      #{mysqlErrno,jdbcType=INTEGER}, #{returnedSqlstate,jdbcType=VARCHAR}, #{messageText,jdbcType=VARCHAR}, 
      #{errors,jdbcType=BIGINT}, #{warnings,jdbcType=BIGINT}, #{rowsAffected,jdbcType=BIGINT}, 
      #{rowsSent,jdbcType=BIGINT}, #{rowsExamined,jdbcType=BIGINT}, #{createdTmpDiskTables,jdbcType=BIGINT}, 
      #{createdTmpTables,jdbcType=BIGINT}, #{selectFullJoin,jdbcType=BIGINT}, #{selectFullRangeJoin,jdbcType=BIGINT}, 
      #{selectRange,jdbcType=BIGINT}, #{selectRangeCheck,jdbcType=BIGINT}, #{selectScan,jdbcType=BIGINT}, 
      #{sortMergePasses,jdbcType=BIGINT}, #{sortRange,jdbcType=BIGINT}, #{sortRows,jdbcType=BIGINT}, 
      #{sortScan,jdbcType=BIGINT}, #{noIndexUsed,jdbcType=BIGINT}, #{noGoodIndexUsed,jdbcType=BIGINT}, 
      #{nestingEventId,jdbcType=BIGINT}, #{nestingEventType,jdbcType=CHAR}, #{nestingEventLevel,jdbcType=INTEGER}, 
      #{statementId,jdbcType=BIGINT}, #{sqlText,jdbcType=LONGVARCHAR}, #{digestText,jdbcType=LONGVARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_statements_current
    set END_EVENT_ID = #{endEventId,jdbcType=BIGINT},
      EVENT_NAME = #{eventName,jdbcType=VARCHAR},
      SOURCE = #{source,jdbcType=VARCHAR},
      TIMER_START = #{timerStart,jdbcType=BIGINT},
      TIMER_END = #{timerEnd,jdbcType=BIGINT},
      TIMER_WAIT = #{timerWait,jdbcType=BIGINT},
      LOCK_TIME = #{lockTime,jdbcType=BIGINT},
      DIGEST = #{digest,jdbcType=VARCHAR},
      CURRENT_SCHEMA = #{currentSchema,jdbcType=VARCHAR},
      OBJECT_TYPE = #{objectType,jdbcType=VARCHAR},
      OBJECT_SCHEMA = #{objectSchema,jdbcType=VARCHAR},
      OBJECT_NAME = #{objectName,jdbcType=VARCHAR},
      OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT},
      MYSQL_ERRNO = #{mysqlErrno,jdbcType=INTEGER},
      RETURNED_SQLSTATE = #{returnedSqlstate,jdbcType=VARCHAR},
      MESSAGE_TEXT = #{messageText,jdbcType=VARCHAR},
      ERRORS = #{errors,jdbcType=BIGINT},
      WARNINGS = #{warnings,jdbcType=BIGINT},
      ROWS_AFFECTED = #{rowsAffected,jdbcType=BIGINT},
      ROWS_SENT = #{rowsSent,jdbcType=BIGINT},
      ROWS_EXAMINED = #{rowsExamined,jdbcType=BIGINT},
      CREATED_TMP_DISK_TABLES = #{createdTmpDiskTables,jdbcType=BIGINT},
      CREATED_TMP_TABLES = #{createdTmpTables,jdbcType=BIGINT},
      SELECT_FULL_JOIN = #{selectFullJoin,jdbcType=BIGINT},
      SELECT_FULL_RANGE_JOIN = #{selectFullRangeJoin,jdbcType=BIGINT},
      SELECT_RANGE = #{selectRange,jdbcType=BIGINT},
      SELECT_RANGE_CHECK = #{selectRangeCheck,jdbcType=BIGINT},
      SELECT_SCAN = #{selectScan,jdbcType=BIGINT},
      SORT_MERGE_PASSES = #{sortMergePasses,jdbcType=BIGINT},
      SORT_RANGE = #{sortRange,jdbcType=BIGINT},
      SORT_ROWS = #{sortRows,jdbcType=BIGINT},
      SORT_SCAN = #{sortScan,jdbcType=BIGINT},
      NO_INDEX_USED = #{noIndexUsed,jdbcType=BIGINT},
      NO_GOOD_INDEX_USED = #{noGoodIndexUsed,jdbcType=BIGINT},
      NESTING_EVENT_ID = #{nestingEventId,jdbcType=BIGINT},
      NESTING_EVENT_TYPE = #{nestingEventType,jdbcType=CHAR},
      NESTING_EVENT_LEVEL = #{nestingEventLevel,jdbcType=INTEGER},
      STATEMENT_ID = #{statementId,jdbcType=BIGINT},
      SQL_TEXT = #{sqlText,jdbcType=LONGVARCHAR},
      DIGEST_TEXT = #{digestText,jdbcType=LONGVARCHAR}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, SOURCE, TIMER_START, TIMER_END, 
    TIMER_WAIT, LOCK_TIME, DIGEST, CURRENT_SCHEMA, OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, 
    OBJECT_INSTANCE_BEGIN, MYSQL_ERRNO, RETURNED_SQLSTATE, MESSAGE_TEXT, ERRORS, WARNINGS, 
    ROWS_AFFECTED, ROWS_SENT, ROWS_EXAMINED, CREATED_TMP_DISK_TABLES, CREATED_TMP_TABLES, 
    SELECT_FULL_JOIN, SELECT_FULL_RANGE_JOIN, SELECT_RANGE, SELECT_RANGE_CHECK, SELECT_SCAN, 
    SORT_MERGE_PASSES, SORT_RANGE, SORT_ROWS, SORT_SCAN, NO_INDEX_USED, NO_GOOD_INDEX_USED, 
    NESTING_EVENT_ID, NESTING_EVENT_TYPE, NESTING_EVENT_LEVEL, STATEMENT_ID, SQL_TEXT, 
    DIGEST_TEXT
    from events_statements_current
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, SOURCE, TIMER_START, TIMER_END, 
    TIMER_WAIT, LOCK_TIME, DIGEST, CURRENT_SCHEMA, OBJECT_TYPE, OBJECT_SCHEMA, OBJECT_NAME, 
    OBJECT_INSTANCE_BEGIN, MYSQL_ERRNO, RETURNED_SQLSTATE, MESSAGE_TEXT, ERRORS, WARNINGS, 
    ROWS_AFFECTED, ROWS_SENT, ROWS_EXAMINED, CREATED_TMP_DISK_TABLES, CREATED_TMP_TABLES, 
    SELECT_FULL_JOIN, SELECT_FULL_RANGE_JOIN, SELECT_RANGE, SELECT_RANGE_CHECK, SELECT_SCAN, 
    SORT_MERGE_PASSES, SORT_RANGE, SORT_ROWS, SORT_SCAN, NO_INDEX_USED, NO_GOOD_INDEX_USED, 
    NESTING_EVENT_ID, NESTING_EVENT_TYPE, NESTING_EVENT_LEVEL, STATEMENT_ID, SQL_TEXT, 
    DIGEST_TEXT
    from events_statements_current
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="QUERY" jdbcType="VARCHAR" property="query" />
    <result column="TRACE" jdbcType="VARCHAR" property="trace" />
    <result column="MISSING_BYTES_BEYOND_MAX_MEM_SIZE" jdbcType="INTEGER" property="missingBytesBeyondMaxMemSize" />
    <result column="INSUFFICIENT_PRIVILEGES" jdbcType="BIT" property="insufficientPrivileges" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into OPTIMIZER_TRACE (QUERY, TRACE, MISSING_BYTES_BEYOND_MAX_MEM_SIZE, 
      INSUFFICIENT_PRIVILEGES)
    values (#{query,jdbcType=VARCHAR}, #{trace,jdbcType=VARCHAR}, #{missingBytesBeyondMaxMemSize,jdbcType=INTEGER}, 
      #{insufficientPrivileges,jdbcType=BIT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select QUERY, TRACE, MISSING_BYTES_BEYOND_MAX_MEM_SIZE, INSUFFICIENT_PRIVILEGES
    from OPTIMIZER_TRACE
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="exec_count" jdbcType="BIGINT" property="execCount" />
    <result column="sort_merge_passes" jdbcType="BIGINT" property="sortMergePasses" />
    <result column="avg_sort_merges" jdbcType="DECIMAL" property="avgSortMerges" />
    <result column="sorts_using_scans" jdbcType="BIGINT" property="sortsUsingScans" />
    <result column="sort_using_range" jdbcType="BIGINT" property="sortUsingRange" />
    <result column="rows_sorted" jdbcType="BIGINT" property="rowsSorted" />
    <result column="avg_rows_sorted" jdbcType="DECIMAL" property="avgRowsSorted" />
    <result column="first_seen" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="last_seen" jdbcType="TIMESTAMP" property="lastSeen" />
    <result column="digest" jdbcType="VARCHAR" property="digest" />
    <result column="query" jdbcType="LONGVARCHAR" property="query" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into statements_with_sorting (db, exec_count, sort_merge_passes, 
      avg_sort_merges, sorts_using_scans, sort_using_range, 
      rows_sorted, avg_rows_sorted, first_seen, 
      last_seen, digest, query, 
      total_latency)
    values (#{db,jdbcType=VARCHAR}, #{execCount,jdbcType=BIGINT}, #{sortMergePasses,jdbcType=BIGINT}, 
      #{avgSortMerges,jdbcType=DECIMAL}, #{sortsUsingScans,jdbcType=BIGINT}, #{sortUsingRange,jdbcType=BIGINT}, 
      #{rowsSorted,jdbcType=BIGINT}, #{avgRowsSorted,jdbcType=DECIMAL}, #{firstSeen,jdbcType=TIMESTAMP}, 
      #{lastSeen,jdbcType=TIMESTAMP}, #{digest,jdbcType=VARCHAR}, #{query,jdbcType=LONGVARCHAR}, 
      #{totalLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select db, exec_count, sort_merge_passes, avg_sort_merges, sorts_using_scans, sort_using_range, 
    rows_sorted, avg_rows_sorted, first_seen, last_seen, digest, query, total_latency
    from statements_with_sorting
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="id" jdbcType="BIGINT" property="id" />
    <result column="pid" jdbcType="BIGINT" property="pid" />
    <result column="name" jdbcType="VARCHAR" property="name" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from t_products_type
    where id = #{id,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Long">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into t_products_type (pid, name)
    values (#{pid,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update t_products_type
    set pid = #{pid,jdbcType=BIGINT},
      name = #{name,jdbcType=VARCHAR}
    where id = #{id,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select id, pid, name
    from t_products_type
    where id = #{id,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select id, pid, name
    from t_products_type
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="EVENT_ID" jdbcType="BIGINT" property="eventId" />
    <result column="END_EVENT_ID" jdbcType="BIGINT" property="endEventId" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="SOURCE" jdbcType="VARCHAR" property="source" />
    <result column="TIMER_START" jdbcType="BIGINT" property="timerStart" />
    <result column="TIMER_END" jdbcType="BIGINT" property="timerEnd" />
    <result column="TIMER_WAIT" jdbcType="BIGINT" property="timerWait" />
    <result column="SPINS" jdbcType="INTEGER" property="spins" />
    <result column="OBJECT_SCHEMA" jdbcType="VARCHAR" property="objectSchema" />
    <result column="OBJECT_NAME" jdbcType="VARCHAR" property="objectName" />
    <result column="INDEX_NAME" jdbcType="VARCHAR" property="indexName" />
    <result column="OBJECT_TYPE" jdbcType="VARCHAR" property="objectType" />
    <result column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="NESTING_EVENT_ID" jdbcType="BIGINT" property="nestingEventId" />
    <result column="NESTING_EVENT_TYPE" jdbcType="CHAR" property="nestingEventType" />
    <result column="OPERATION" jdbcType="VARCHAR" property="operation" />
    <result column="NUMBER_OF_BYTES" jdbcType="BIGINT" property="numberOfBytes" />
    <result column="FLAGS" jdbcType="INTEGER" property="flags" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from events_waits_current
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_waits_current (THREAD_ID, EVENT_ID, END_EVENT_ID, 
      EVENT_NAME, SOURCE, TIMER_START, 
      TIMER_END, TIMER_WAIT, SPINS, 
      OBJECT_SCHEMA, OBJECT_NAME, INDEX_NAME, 
      OBJECT_TYPE, OBJECT_INSTANCE_BEGIN, NESTING_EVENT_ID, 
      NESTING_EVENT_TYPE, OPERATION, NUMBER_OF_BYTES, 
      FLAGS)
    values (#{threadId,jdbcType=BIGINT}, #{eventId,jdbcType=BIGINT}, #{endEventId,jdbcType=BIGINT}, 
      #{eventName,jdbcType=VARCHAR}, #{source,jdbcType=VARCHAR}, #{timerStart,jdbcType=BIGINT}, 
      #{timerEnd,jdbcType=BIGINT}, #{timerWait,jdbcType=BIGINT}, #{spins,jdbcType=INTEGER}, 
      #{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, #{indexName,jdbcType=VARCHAR}, 
      #{objectType,jdbcType=VARCHAR}, #{objectInstanceBegin,jdbcType=BIGINT}, #{nestingEventId,jdbcType=BIGINT}, 
      #{nestingEventType,jdbcType=CHAR}, #{operation,jdbcType=VARCHAR}, #{numberOfBytes,jdbcType=BIGINT}, 
      #{flags,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_waits_current
    set END_EVENT_ID = #{endEventId,jdbcType=BIGINT},
      EVENT_NAME = #{eventName,jdbcType=VARCHAR},
      SOURCE = #{source,jdbcType=VARCHAR},
      TIMER_START = #{timerStart,jdbcType=BIGINT},
      TIMER_END = #{timerEnd,jdbcType=BIGINT},
      TIMER_WAIT = #{timerWait,jdbcType=BIGINT},
      SPINS = #{spins,jdbcType=INTEGER},
      OBJECT_SCHEMA = #{objectSchema,jdbcType=VARCHAR},
      OBJECT_NAME = #{objectName,jdbcType=VARCHAR},
      INDEX_NAME = #{indexName,jdbcType=VARCHAR},
      OBJECT_TYPE = #{objectType,jdbcType=VARCHAR},
      OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT},
      NESTING_EVENT_ID = #{nestingEventId,jdbcType=BIGINT},
      NESTING_EVENT_TYPE = #{nestingEventType,jdbcType=CHAR},
      OPERATION = #{operation,jdbcType=VARCHAR},
      NUMBER_OF_BYTES = #{numberOfBytes,jdbcType=BIGINT},
      FLAGS = #{flags,jdbcType=INTEGER}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, SOURCE, TIMER_START, TIMER_END, 
    TIMER_WAIT, SPINS, OBJECT_SCHEMA, OBJECT_NAME, INDEX_NAME, OBJECT_TYPE, OBJECT_INSTANCE_BEGIN, 
    NESTING_EVENT_ID, NESTING_EVENT_TYPE, OPERATION, NUMBER_OF_BYTES, FLAGS
    from events_waits_current
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, SOURCE, TIMER_START, TIMER_END, 
    TIMER_WAIT, SPINS, OBJECT_SCHEMA, OBJECT_NAME, INDEX_NAME, OBJECT_TYPE, OBJECT_INSTANCE_BEGIN, 
    NESTING_EVENT_ID, NESTING_EVENT_TYPE, OPERATION, NUMBER_OF_BYTES, FLAGS
    from events_waits_current
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="COUNT_READ_WRITE" jdbcType="BIGINT" property="countReadWrite" />
    <result column="SUM_TIMER_READ_WRITE" jdbcType="BIGINT" property="sumTimerReadWrite" />
    <result column="MIN_TIMER_READ_WRITE" jdbcType="BIGINT" property="minTimerReadWrite" />
    <result column="AVG_TIMER_READ_WRITE" jdbcType="BIGINT" property="avgTimerReadWrite" />
    <result column="MAX_TIMER_READ_WRITE" jdbcType="BIGINT" property="maxTimerReadWrite" />
    <result column="COUNT_READ_ONLY" jdbcType="BIGINT" property="countReadOnly" />
    <result column="SUM_TIMER_READ_ONLY" jdbcType="BIGINT" property="sumTimerReadOnly" />
    <result column="MIN_TIMER_READ_ONLY" jdbcType="BIGINT" property="minTimerReadOnly" />
    <result column="AVG_TIMER_READ_ONLY" jdbcType="BIGINT" property="avgTimerReadOnly" />
    <result column="MAX_TIMER_READ_ONLY" jdbcType="BIGINT" property="maxTimerReadOnly" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from events_transactions_summary_global_by_event_name
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_transactions_summary_global_by_event_name (EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, 
      MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, 
      COUNT_READ_WRITE, SUM_TIMER_READ_WRITE, MIN_TIMER_READ_WRITE, 
      AVG_TIMER_READ_WRITE, MAX_TIMER_READ_WRITE, COUNT_READ_ONLY, 
      SUM_TIMER_READ_ONLY, MIN_TIMER_READ_ONLY, AVG_TIMER_READ_ONLY, 
      MAX_TIMER_READ_ONLY)
    values (#{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, 
      #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT}, 
      #{countReadWrite,jdbcType=BIGINT}, #{sumTimerReadWrite,jdbcType=BIGINT}, #{minTimerReadWrite,jdbcType=BIGINT}, 
      #{avgTimerReadWrite,jdbcType=BIGINT}, #{maxTimerReadWrite,jdbcType=BIGINT}, #{countReadOnly,jdbcType=BIGINT}, 
      #{sumTimerReadOnly,jdbcType=BIGINT}, #{minTimerReadOnly,jdbcType=BIGINT}, #{avgTimerReadOnly,jdbcType=BIGINT}, 
      #{maxTimerReadOnly,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_transactions_summary_global_by_event_name
    set COUNT_STAR = #{countStar,jdbcType=BIGINT},
      SUM_TIMER_WAIT = #{sumTimerWait,jdbcType=BIGINT},
      MIN_TIMER_WAIT = #{minTimerWait,jdbcType=BIGINT},
      AVG_TIMER_WAIT = #{avgTimerWait,jdbcType=BIGINT},
      MAX_TIMER_WAIT = #{maxTimerWait,jdbcType=BIGINT},
      COUNT_READ_WRITE = #{countReadWrite,jdbcType=BIGINT},
      SUM_TIMER_READ_WRITE = #{sumTimerReadWrite,jdbcType=BIGINT},
      MIN_TIMER_READ_WRITE = #{minTimerReadWrite,jdbcType=BIGINT},
      AVG_TIMER_READ_WRITE = #{avgTimerReadWrite,jdbcType=BIGINT},
      MAX_TIMER_READ_WRITE = #{maxTimerReadWrite,jdbcType=BIGINT},
      COUNT_READ_ONLY = #{countReadOnly,jdbcType=BIGINT},
      SUM_TIMER_READ_ONLY = #{sumTimerReadOnly,jdbcType=BIGINT},
      MIN_TIMER_READ_ONLY = #{minTimerReadOnly,jdbcType=BIGINT},
      AVG_TIMER_READ_ONLY = #{avgTimerReadOnly,jdbcType=BIGINT},
      MAX_TIMER_READ_ONLY = #{maxTimerReadOnly,jdbcType=BIGINT}
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, 
    COUNT_READ_WRITE, SUM_TIMER_READ_WRITE, MIN_TIMER_READ_WRITE, AVG_TIMER_READ_WRITE, 
    MAX_TIMER_READ_WRITE, COUNT_READ_ONLY, SUM_TIMER_READ_ONLY, MIN_TIMER_READ_ONLY, 
    AVG_TIMER_READ_ONLY, MAX_TIMER_READ_ONLY
    from events_transactions_summary_global_by_event_name
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, 
    COUNT_READ_WRITE, SUM_TIMER_READ_WRITE, MIN_TIMER_READ_WRITE, AVG_TIMER_READ_WRITE, 
    MAX_TIMER_READ_WRITE, COUNT_READ_ONLY, SUM_TIMER_READ_ONLY, MIN_TIMER_READ_ONLY, 
    AVG_TIMER_READ_ONLY, MAX_TIMER_READ_ONLY
    from events_transactions_summary_global_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <result column="EVENT_ID" jdbcType="BIGINT" property="eventId" />
    <result column="END_EVENT_ID" jdbcType="BIGINT" property="endEventId" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="SOURCE" jdbcType="VARCHAR" property="source" />
    <result column="TIMER_START" jdbcType="BIGINT" property="timerStart" />
    <result column="TIMER_END" jdbcType="BIGINT" property="timerEnd" />
    <result column="TIMER_WAIT" jdbcType="BIGINT" property="timerWait" />
    <result column="SPINS" jdbcType="INTEGER" property="spins" />
    <result column="OBJECT_SCHEMA" jdbcType="VARCHAR" property="objectSchema" />
    <result column="OBJECT_NAME" jdbcType="VARCHAR" property="objectName" />
    <result column="INDEX_NAME" jdbcType="VARCHAR" property="indexName" />
    <result column="OBJECT_TYPE" jdbcType="VARCHAR" property="objectType" />
    <result column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="NESTING_EVENT_ID" jdbcType="BIGINT" property="nestingEventId" />
    <result column="NESTING_EVENT_TYPE" jdbcType="CHAR" property="nestingEventType" />
    <result column="OPERATION" jdbcType="VARCHAR" property="operation" />
    <result column="NUMBER_OF_BYTES" jdbcType="BIGINT" property="numberOfBytes" />
    <result column="FLAGS" jdbcType="INTEGER" property="flags" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_waits_history_long (THREAD_ID, EVENT_ID, END_EVENT_ID, 
      EVENT_NAME, SOURCE, TIMER_START, 
      TIMER_END, TIMER_WAIT, SPINS, 
      OBJECT_SCHEMA, OBJECT_NAME, INDEX_NAME, 
      OBJECT_TYPE, OBJECT_INSTANCE_BEGIN, NESTING_EVENT_ID, 
      NESTING_EVENT_TYPE, OPERATION, NUMBER_OF_BYTES, 
      FLAGS)
    values (#{threadId,jdbcType=BIGINT}, #{eventId,jdbcType=BIGINT}, #{endEventId,jdbcType=BIGINT}, 
      #{eventName,jdbcType=VARCHAR}, #{source,jdbcType=VARCHAR}, #{timerStart,jdbcType=BIGINT}, 
      #{timerEnd,jdbcType=BIGINT}, #{timerWait,jdbcType=BIGINT}, #{spins,jdbcType=INTEGER}, 
      #{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, #{indexName,jdbcType=VARCHAR}, 
      #{objectType,jdbcType=VARCHAR}, #{objectInstanceBegin,jdbcType=BIGINT}, #{nestingEventId,jdbcType=BIGINT}, 
      #{nestingEventType,jdbcType=CHAR}, #{operation,jdbcType=VARCHAR}, #{numberOfBytes,jdbcType=BIGINT}, 
      #{flags,jdbcType=INTEGER})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, SOURCE, TIMER_START, TIMER_END, 
    TIMER_WAIT, SPINS, OBJECT_SCHEMA, OBJECT_NAME, INDEX_NAME, OBJECT_TYPE, OBJECT_INSTANCE_BEGIN, 
    NESTING_EVENT_ID, NESTING_EVENT_TYPE, OPERATION, NUMBER_OF_BYTES, FLAGS
    from events_waits_history_long
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="COLLATION_NAME" jdbcType="VARCHAR" property="collationName" />
    <result column="CHARACTER_SET_NAME" jdbcType="VARCHAR" property="characterSetName" />
    <result column="ID" jdbcType="BIGINT" property="id" />
    <result column="IS_DEFAULT" jdbcType="VARCHAR" property="isDefault" />
    <result column="IS_COMPILED" jdbcType="VARCHAR" property="isCompiled" />
    <result column="SORTLEN" jdbcType="INTEGER" property="sortlen" />
    <result column="PAD_ATTRIBUTE" jdbcType="CHAR" property="padAttribute" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Long">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into COLLATIONS (COLLATION_NAME, CHARACTER_SET_NAME, 
      IS_DEFAULT, IS_COMPILED, SORTLEN, 
      PAD_ATTRIBUTE)
    values (#{collationName,jdbcType=VARCHAR}, #{characterSetName,jdbcType=VARCHAR}, 
      #{isDefault,jdbcType=VARCHAR}, #{isCompiled,jdbcType=VARCHAR}, #{sortlen,jdbcType=INTEGER}, 
      #{padAttribute,jdbcType=CHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select COLLATION_NAME, CHARACTER_SET_NAME, ID, IS_DEFAULT, IS_COMPILED, SORTLEN, 
    PAD_ATTRIBUTE
    from COLLATIONS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="help_keyword_id" jdbcType="INTEGER" property="helpKeywordId" />
    <id column="help_topic_id" jdbcType="INTEGER" property="helpTopicId" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from help_relation
    where help_keyword_id = #{helpKeywordId,jdbcType=INTEGER}
      and help_topic_id = #{helpTopicId,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into help_relation (help_keyword_id, help_topic_id)
    values (#{helpKeywordId,jdbcType=INTEGER}, #{helpTopicId,jdbcType=INTEGER})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select help_keyword_id, help_topic_id
    from help_relation
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="uid" jdbcType="INTEGER" property="uid" />
    <result column="uname" jdbcType="VARCHAR" property="uname" />
    <result column="upsw" jdbcType="VARCHAR" property="upsw" />
    <result column="urealname" jdbcType="VARCHAR" property="urealname" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from userinfo
    where uid = #{uid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into userinfo (uid, uname, upsw, 
      urealname)
    values (#{uid,jdbcType=INTEGER}, #{uname,jdbcType=VARCHAR}, #{upsw,jdbcType=VARCHAR}, 
      #{urealname,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update userinfo
    set uname = #{uname,jdbcType=VARCHAR},
      upsw = #{upsw,jdbcType=VARCHAR},
      urealname = #{urealname,jdbcType=VARCHAR}
    where uid = #{uid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select uid, uname, upsw, urealname
    from userinfo
    where uid = #{uid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select uid, uname, upsw, urealname
    from userinfo
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="sid" jdbcType="INTEGER" property="sid" />
    <result column="sname" jdbcType="VARCHAR" property="sname" />
    <result column="sremark" jdbcType="VARCHAR" property="sremark" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from fsort
    where sid = #{sid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into fsort (sid, sname, sremark
      )
    values (#{sid,jdbcType=INTEGER}, #{sname,jdbcType=VARCHAR}, #{sremark,jdbcType=VARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update fsort
    set sname = #{sname,jdbcType=VARCHAR},
      sremark = #{sremark,jdbcType=VARCHAR}
    where sid = #{sid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select sid, sname, sremark
    from fsort
    where sid = #{sid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select sid, sname, sremark
    from fsort
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="utid" jdbcType="INTEGER" property="utid" />
    <result column="uid" jdbcType="VARCHAR" property="uid" />
    <result column="password" jdbcType="VARCHAR" property="password" />
    <result column="tel" jdbcType="VARCHAR" property="tel" />
    <result column="name" jdbcType="VARCHAR" property="name" />
    <result column="address" jdbcType="VARCHAR" property="address" />
    <result column="addrName" jdbcType="VARCHAR" property="addrname" />
    <result column="create_time" jdbcType="TIMESTAMP" property="createTime" />
    <result column="update_time" jdbcType="TIMESTAMP" property="updateTime" />
    <result column="version" jdbcType="INTEGER" property="version" />
    <result column="deleted" jdbcType="INTEGER" property="deleted" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into users (utid, uid, password, 
      tel, name, address, 
      addrName, create_time, update_time, 
      version, deleted)
    values (#{utid,jdbcType=INTEGER}, #{uid,jdbcType=VARCHAR}, #{password,jdbcType=VARCHAR}, 
      #{tel,jdbcType=VARCHAR}, #{name,jdbcType=VARCHAR}, #{address,jdbcType=VARCHAR}, 
      #{addrname,jdbcType=VARCHAR}, #{createTime,jdbcType=TIMESTAMP}, #{updateTime,jdbcType=TIMESTAMP}, 
      #{version,jdbcType=INTEGER}, #{deleted,jdbcType=INTEGER})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select utid, uid, password, tel, name, address, addrName, create_time, update_time, 
    version, deleted
    from users
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="event" jdbcType="VARCHAR" property="event" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="avg_latency" jdbcType="BIGINT" property="avgLatency" />
    <result column="max_latency" jdbcType="BIGINT" property="maxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$waits_by_user_by_latency (user, event, total, 
      total_latency, avg_latency, max_latency
      )
    values (#{user,jdbcType=VARCHAR}, #{event,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{totalLatency,jdbcType=BIGINT}, #{avgLatency,jdbcType=BIGINT}, #{maxLatency,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, event, total, total_latency, avg_latency, max_latency
    from x$waits_by_user_by_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="GRANTEE" jdbcType="VARCHAR" property="grantee" />
    <result column="TABLE_CATALOG" jdbcType="VARCHAR" property="tableCatalog" />
    <result column="TABLE_SCHEMA" jdbcType="VARCHAR" property="tableSchema" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
    <result column="COLUMN_NAME" jdbcType="VARCHAR" property="columnName" />
    <result column="PRIVILEGE_TYPE" jdbcType="VARCHAR" property="privilegeType" />
    <result column="IS_GRANTABLE" jdbcType="VARCHAR" property="isGrantable" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into COLUMN_PRIVILEGES (GRANTEE, TABLE_CATALOG, TABLE_SCHEMA, 
      TABLE_NAME, COLUMN_NAME, PRIVILEGE_TYPE, 
      IS_GRANTABLE)
    values (#{grantee,jdbcType=VARCHAR}, #{tableCatalog,jdbcType=VARCHAR}, #{tableSchema,jdbcType=VARCHAR}, 
      #{tableName,jdbcType=VARCHAR}, #{columnName,jdbcType=VARCHAR}, #{privilegeType,jdbcType=VARCHAR}, 
      #{isGrantable,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select GRANTEE, TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, PRIVILEGE_TYPE, 
    IS_GRANTABLE
    from COLUMN_PRIVILEGES
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="exec_count" jdbcType="BIGINT" property="execCount" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="memory_tmp_tables" jdbcType="BIGINT" property="memoryTmpTables" />
    <result column="disk_tmp_tables" jdbcType="BIGINT" property="diskTmpTables" />
    <result column="avg_tmp_tables_per_query" jdbcType="DECIMAL" property="avgTmpTablesPerQuery" />
    <result column="tmp_tables_to_disk_pct" jdbcType="DECIMAL" property="tmpTablesToDiskPct" />
    <result column="first_seen" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="last_seen" jdbcType="TIMESTAMP" property="lastSeen" />
    <result column="digest" jdbcType="VARCHAR" property="digest" />
    <result column="query" jdbcType="LONGVARCHAR" property="query" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$statements_with_temp_tables (db, exec_count, total_latency, 
      memory_tmp_tables, disk_tmp_tables, avg_tmp_tables_per_query, 
      tmp_tables_to_disk_pct, first_seen, last_seen, 
      digest, query)
    values (#{db,jdbcType=VARCHAR}, #{execCount,jdbcType=BIGINT}, #{totalLatency,jdbcType=BIGINT}, 
      #{memoryTmpTables,jdbcType=BIGINT}, #{diskTmpTables,jdbcType=BIGINT}, #{avgTmpTablesPerQuery,jdbcType=DECIMAL}, 
      #{tmpTablesToDiskPct,jdbcType=DECIMAL}, #{firstSeen,jdbcType=TIMESTAMP}, #{lastSeen,jdbcType=TIMESTAMP}, 
      #{digest,jdbcType=VARCHAR}, #{query,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select db, exec_count, total_latency, memory_tmp_tables, disk_tmp_tables, avg_tmp_tables_per_query, 
    tmp_tables_to_disk_pct, first_seen, last_seen, digest, query
    from x$statements_with_temp_tables
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_waits_summary_by_user_by_event_name (USER, EVENT_NAME, COUNT_STAR, 
      SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
      MAX_TIMER_WAIT)
    values (#{user,jdbcType=CHAR}, #{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, 
      #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, 
      #{maxTimerWait,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT
    from events_waits_summary_by_user_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from events_stages_summary_by_thread_by_event_name
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_stages_summary_by_thread_by_event_name (THREAD_ID, EVENT_NAME, COUNT_STAR, 
      SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
      MAX_TIMER_WAIT)
    values (#{threadId,jdbcType=BIGINT}, #{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, 
      #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, 
      #{maxTimerWait,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_stages_summary_by_thread_by_event_name
    set COUNT_STAR = #{countStar,jdbcType=BIGINT},
      SUM_TIMER_WAIT = #{sumTimerWait,jdbcType=BIGINT},
      MIN_TIMER_WAIT = #{minTimerWait,jdbcType=BIGINT},
      AVG_TIMER_WAIT = #{avgTimerWait,jdbcType=BIGINT},
      MAX_TIMER_WAIT = #{maxTimerWait,jdbcType=BIGINT}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT
    from events_stages_summary_by_thread_by_event_name
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT
    from events_stages_summary_by_thread_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="tid" jdbcType="BIGINT" property="tid" />
    <result column="title" jdbcType="VARCHAR" property="title" />
    <result column="fromto" jdbcType="VARCHAR" property="fromto" />
    <result column="starttime" jdbcType="TIMESTAMP" property="starttime" />
    <result column="endtime" jdbcType="TIMESTAMP" property="endtime" />
    <result column="uid" jdbcType="BIGINT" property="uid" />
    <result column="status" jdbcType="INTEGER" property="status" />
    <result column="task" jdbcType="LONGVARCHAR" property="task" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from tasks
    where tid = #{tid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into tasks (tid, title, fromto, 
      starttime, endtime, uid, 
      status, task)
    values (#{tid,jdbcType=BIGINT}, #{title,jdbcType=VARCHAR}, #{fromto,jdbcType=VARCHAR}, 
      #{starttime,jdbcType=TIMESTAMP}, #{endtime,jdbcType=TIMESTAMP}, #{uid,jdbcType=BIGINT}, 
      #{status,jdbcType=INTEGER}, #{task,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update tasks
    set title = #{title,jdbcType=VARCHAR},
      fromto = #{fromto,jdbcType=VARCHAR},
      starttime = #{starttime,jdbcType=TIMESTAMP},
      endtime = #{endtime,jdbcType=TIMESTAMP},
      uid = #{uid,jdbcType=BIGINT},
      status = #{status,jdbcType=INTEGER},
      task = #{task,jdbcType=LONGVARCHAR}
    where tid = #{tid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select tid, title, fromto, starttime, endtime, uid, status, task
    from tasks
    where tid = #{tid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select tid, title, fromto, starttime, endtime, uid, status, task
    from tasks
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Name" jdbcType="CHAR" property="name" />
    <result column="Time_zone_id" jdbcType="INTEGER" property="timeZoneId" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from time_zone_name
    where Name = #{name,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into time_zone_name (Name, Time_zone_id)
    values (#{name,jdbcType=CHAR}, #{timeZoneId,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update time_zone_name
    set Time_zone_id = #{timeZoneId,jdbcType=INTEGER}
    where Name = #{name,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select Name, Time_zone_id
    from time_zone_name
    where Name = #{name,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Name, Time_zone_id
    from time_zone_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="object_type" jdbcType="CHAR" property="objectType" />
    <result column="count" jdbcType="BIGINT" property="count" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into schema_object_overview (db, object_type, count
      )
    values (#{db,jdbcType=VARCHAR}, #{objectType,jdbcType=CHAR}, #{count,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select db, object_type, count
    from schema_object_overview
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="CHANNEL_NAME" jdbcType="CHAR" property="channelName" />
    <result column="VIEW_ID" jdbcType="CHAR" property="viewId" />
    <result column="MEMBER_ID" jdbcType="CHAR" property="memberId" />
    <result column="COUNT_TRANSACTIONS_IN_QUEUE" jdbcType="BIGINT" property="countTransactionsInQueue" />
    <result column="COUNT_TRANSACTIONS_CHECKED" jdbcType="BIGINT" property="countTransactionsChecked" />
    <result column="COUNT_CONFLICTS_DETECTED" jdbcType="BIGINT" property="countConflictsDetected" />
    <result column="COUNT_TRANSACTIONS_ROWS_VALIDATING" jdbcType="BIGINT" property="countTransactionsRowsValidating" />
    <result column="COUNT_TRANSACTIONS_REMOTE_IN_APPLIER_QUEUE" jdbcType="BIGINT" property="countTransactionsRemoteInApplierQueue" />
    <result column="COUNT_TRANSACTIONS_REMOTE_APPLIED" jdbcType="BIGINT" property="countTransactionsRemoteApplied" />
    <result column="COUNT_TRANSACTIONS_LOCAL_PROPOSED" jdbcType="BIGINT" property="countTransactionsLocalProposed" />
    <result column="COUNT_TRANSACTIONS_LOCAL_ROLLBACK" jdbcType="BIGINT" property="countTransactionsLocalRollback" />
    <result column="TRANSACTIONS_COMMITTED_ALL_MEMBERS" jdbcType="LONGVARCHAR" property="transactionsCommittedAllMembers" />
    <result column="LAST_CONFLICT_FREE_TRANSACTION" jdbcType="LONGVARCHAR" property="lastConflictFreeTransaction" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into replication_group_member_stats (CHANNEL_NAME, VIEW_ID, MEMBER_ID, 
      COUNT_TRANSACTIONS_IN_QUEUE, COUNT_TRANSACTIONS_CHECKED, 
      COUNT_CONFLICTS_DETECTED, COUNT_TRANSACTIONS_ROWS_VALIDATING, 
      COUNT_TRANSACTIONS_REMOTE_IN_APPLIER_QUEUE, COUNT_TRANSACTIONS_REMOTE_APPLIED, 
      COUNT_TRANSACTIONS_LOCAL_PROPOSED, COUNT_TRANSACTIONS_LOCAL_ROLLBACK, 
      TRANSACTIONS_COMMITTED_ALL_MEMBERS, LAST_CONFLICT_FREE_TRANSACTION
      )
    values (#{channelName,jdbcType=CHAR}, #{viewId,jdbcType=CHAR}, #{memberId,jdbcType=CHAR}, 
      #{countTransactionsInQueue,jdbcType=BIGINT}, #{countTransactionsChecked,jdbcType=BIGINT}, 
      #{countConflictsDetected,jdbcType=BIGINT}, #{countTransactionsRowsValidating,jdbcType=BIGINT}, 
      #{countTransactionsRemoteInApplierQueue,jdbcType=BIGINT}, #{countTransactionsRemoteApplied,jdbcType=BIGINT}, 
      #{countTransactionsLocalProposed,jdbcType=BIGINT}, #{countTransactionsLocalRollback,jdbcType=BIGINT}, 
      #{transactionsCommittedAllMembers,jdbcType=LONGVARCHAR}, #{lastConflictFreeTransaction,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select CHANNEL_NAME, VIEW_ID, MEMBER_ID, COUNT_TRANSACTIONS_IN_QUEUE, COUNT_TRANSACTIONS_CHECKED, 
    COUNT_CONFLICTS_DETECTED, COUNT_TRANSACTIONS_ROWS_VALIDATING, COUNT_TRANSACTIONS_REMOTE_IN_APPLIER_QUEUE, 
    COUNT_TRANSACTIONS_REMOTE_APPLIED, COUNT_TRANSACTIONS_LOCAL_PROPOSED, COUNT_TRANSACTIONS_LOCAL_ROLLBACK, 
    TRANSACTIONS_COMMITTED_ALL_MEMBERS, LAST_CONFLICT_FREE_TRANSACTION
    from replication_group_member_stats
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="tid" jdbcType="BIGINT" property="tid" />
    <result column="t_title" jdbcType="VARCHAR" property="tTitle" />
    <result column="t_author_id" jdbcType="BIGINT" property="tAuthorId" />
    <result column="t_createtime" jdbcType="TIMESTAMP" property="tCreatetime" />
    <result column="t_modified" jdbcType="TIMESTAMP" property="tModified" />
    <result column="t_flag" jdbcType="BIGINT" property="tFlag" />
    <result column="t_content" jdbcType="LONGVARCHAR" property="tContent" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from article
    where tid = #{tid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into article (tid, t_title, t_author_id, 
      t_createtime, t_modified, t_flag, 
      t_content)
    values (#{tid,jdbcType=BIGINT}, #{tTitle,jdbcType=VARCHAR}, #{tAuthorId,jdbcType=BIGINT}, 
      #{tCreatetime,jdbcType=TIMESTAMP}, #{tModified,jdbcType=TIMESTAMP}, #{tFlag,jdbcType=BIGINT}, 
      #{tContent,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update article
    set t_title = #{tTitle,jdbcType=VARCHAR},
      t_author_id = #{tAuthorId,jdbcType=BIGINT},
      t_createtime = #{tCreatetime,jdbcType=TIMESTAMP},
      t_modified = #{tModified,jdbcType=TIMESTAMP},
      t_flag = #{tFlag,jdbcType=BIGINT},
      t_content = #{tContent,jdbcType=LONGVARCHAR}
    where tid = #{tid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select tid, t_title, t_author_id, t_createtime, t_modified, t_flag, t_content
    from article
    where tid = #{tid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select tid, t_title, t_author_id, t_createtime, t_modified, t_flag, t_content
    from article
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="VARIABLE_NAME" jdbcType="VARCHAR" property="variableName" />
    <result column="VARIABLE_VALUE" jdbcType="VARCHAR" property="variableValue" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from status_by_thread
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into status_by_thread (THREAD_ID, VARIABLE_NAME, VARIABLE_VALUE
      )
    values (#{threadId,jdbcType=BIGINT}, #{variableName,jdbcType=VARCHAR}, #{variableValue,jdbcType=VARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update status_by_thread
    set VARIABLE_VALUE = #{variableValue,jdbcType=VARCHAR}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, VARIABLE_NAME, VARIABLE_VALUE
    from status_by_thread
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, VARIABLE_NAME, VARIABLE_VALUE
    from status_by_thread
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="avg_us" jdbcType="DECIMAL" property="avgUs" />
    <result column="percentile" jdbcType="DECIMAL" property="percentile" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$ps_digest_95th_percentile_by_avg_us (avg_us, percentile)
    values (#{avgUs,jdbcType=DECIMAL}, #{percentile,jdbcType=DECIMAL})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select avg_us, percentile
    from x$ps_digest_95th_percentile_by_avg_us
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="question_id" jdbcType="INTEGER" property="questionId" />
    <result column="question_answer" jdbcType="VARCHAR" property="questionAnswer" />
    <result column="question_sub" jdbcType="INTEGER" property="questionSub" />
    <result column="question_text" jdbcType="LONGVARCHAR" property="questionText" />
    <result column="answer_a" jdbcType="LONGVARCHAR" property="answerA" />
    <result column="answer_b" jdbcType="LONGVARCHAR" property="answerB" />
    <result column="answer_c" jdbcType="LONGVARCHAR" property="answerC" />
    <result column="answer_d" jdbcType="LONGVARCHAR" property="answerD" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into t_question (question_id, question_answer, question_sub, 
      question_text, answer_a, answer_b, 
      answer_c, answer_d)
    values (#{questionId,jdbcType=INTEGER}, #{questionAnswer,jdbcType=VARCHAR}, #{questionSub,jdbcType=INTEGER}, 
      #{questionText,jdbcType=LONGVARCHAR}, #{answerA,jdbcType=LONGVARCHAR}, #{answerB,jdbcType=LONGVARCHAR}, 
      #{answerC,jdbcType=LONGVARCHAR}, #{answerD,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select question_id, question_answer, question_sub, question_text, answer_a, answer_b, 
    answer_c, answer_d
    from t_question
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="COUNT_READ" jdbcType="BIGINT" property="countRead" />
    <result column="SUM_TIMER_READ" jdbcType="BIGINT" property="sumTimerRead" />
    <result column="MIN_TIMER_READ" jdbcType="BIGINT" property="minTimerRead" />
    <result column="AVG_TIMER_READ" jdbcType="BIGINT" property="avgTimerRead" />
    <result column="MAX_TIMER_READ" jdbcType="BIGINT" property="maxTimerRead" />
    <result column="SUM_NUMBER_OF_BYTES_READ" jdbcType="BIGINT" property="sumNumberOfBytesRead" />
    <result column="COUNT_WRITE" jdbcType="BIGINT" property="countWrite" />
    <result column="SUM_TIMER_WRITE" jdbcType="BIGINT" property="sumTimerWrite" />
    <result column="MIN_TIMER_WRITE" jdbcType="BIGINT" property="minTimerWrite" />
    <result column="AVG_TIMER_WRITE" jdbcType="BIGINT" property="avgTimerWrite" />
    <result column="MAX_TIMER_WRITE" jdbcType="BIGINT" property="maxTimerWrite" />
    <result column="SUM_NUMBER_OF_BYTES_WRITE" jdbcType="BIGINT" property="sumNumberOfBytesWrite" />
    <result column="COUNT_MISC" jdbcType="BIGINT" property="countMisc" />
    <result column="SUM_TIMER_MISC" jdbcType="BIGINT" property="sumTimerMisc" />
    <result column="MIN_TIMER_MISC" jdbcType="BIGINT" property="minTimerMisc" />
    <result column="AVG_TIMER_MISC" jdbcType="BIGINT" property="avgTimerMisc" />
    <result column="MAX_TIMER_MISC" jdbcType="BIGINT" property="maxTimerMisc" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from socket_summary_by_instance
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into socket_summary_by_instance (OBJECT_INSTANCE_BEGIN, EVENT_NAME, COUNT_STAR, 
      SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
      MAX_TIMER_WAIT, COUNT_READ, SUM_TIMER_READ, 
      MIN_TIMER_READ, AVG_TIMER_READ, MAX_TIMER_READ, 
      SUM_NUMBER_OF_BYTES_READ, COUNT_WRITE, SUM_TIMER_WRITE, 
      MIN_TIMER_WRITE, AVG_TIMER_WRITE, MAX_TIMER_WRITE, 
      SUM_NUMBER_OF_BYTES_WRITE, COUNT_MISC, SUM_TIMER_MISC, 
      MIN_TIMER_MISC, AVG_TIMER_MISC, MAX_TIMER_MISC
      )
    values (#{objectInstanceBegin,jdbcType=BIGINT}, #{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, 
      #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, 
      #{maxTimerWait,jdbcType=BIGINT}, #{countRead,jdbcType=BIGINT}, #{sumTimerRead,jdbcType=BIGINT}, 
      #{minTimerRead,jdbcType=BIGINT}, #{avgTimerRead,jdbcType=BIGINT}, #{maxTimerRead,jdbcType=BIGINT}, 
      #{sumNumberOfBytesRead,jdbcType=BIGINT}, #{countWrite,jdbcType=BIGINT}, #{sumTimerWrite,jdbcType=BIGINT}, 
      #{minTimerWrite,jdbcType=BIGINT}, #{avgTimerWrite,jdbcType=BIGINT}, #{maxTimerWrite,jdbcType=BIGINT}, 
      #{sumNumberOfBytesWrite,jdbcType=BIGINT}, #{countMisc,jdbcType=BIGINT}, #{sumTimerMisc,jdbcType=BIGINT}, 
      #{minTimerMisc,jdbcType=BIGINT}, #{avgTimerMisc,jdbcType=BIGINT}, #{maxTimerMisc,jdbcType=BIGINT}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update socket_summary_by_instance
    set EVENT_NAME = #{eventName,jdbcType=VARCHAR},
      COUNT_STAR = #{countStar,jdbcType=BIGINT},
      SUM_TIMER_WAIT = #{sumTimerWait,jdbcType=BIGINT},
      MIN_TIMER_WAIT = #{minTimerWait,jdbcType=BIGINT},
      AVG_TIMER_WAIT = #{avgTimerWait,jdbcType=BIGINT},
      MAX_TIMER_WAIT = #{maxTimerWait,jdbcType=BIGINT},
      COUNT_READ = #{countRead,jdbcType=BIGINT},
      SUM_TIMER_READ = #{sumTimerRead,jdbcType=BIGINT},
      MIN_TIMER_READ = #{minTimerRead,jdbcType=BIGINT},
      AVG_TIMER_READ = #{avgTimerRead,jdbcType=BIGINT},
      MAX_TIMER_READ = #{maxTimerRead,jdbcType=BIGINT},
      SUM_NUMBER_OF_BYTES_READ = #{sumNumberOfBytesRead,jdbcType=BIGINT},
      COUNT_WRITE = #{countWrite,jdbcType=BIGINT},
      SUM_TIMER_WRITE = #{sumTimerWrite,jdbcType=BIGINT},
      MIN_TIMER_WRITE = #{minTimerWrite,jdbcType=BIGINT},
      AVG_TIMER_WRITE = #{avgTimerWrite,jdbcType=BIGINT},
      MAX_TIMER_WRITE = #{maxTimerWrite,jdbcType=BIGINT},
      SUM_NUMBER_OF_BYTES_WRITE = #{sumNumberOfBytesWrite,jdbcType=BIGINT},
      COUNT_MISC = #{countMisc,jdbcType=BIGINT},
      SUM_TIMER_MISC = #{sumTimerMisc,jdbcType=BIGINT},
      MIN_TIMER_MISC = #{minTimerMisc,jdbcType=BIGINT},
      AVG_TIMER_MISC = #{avgTimerMisc,jdbcType=BIGINT},
      MAX_TIMER_MISC = #{maxTimerMisc,jdbcType=BIGINT}
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
    AVG_TIMER_WAIT, MAX_TIMER_WAIT, COUNT_READ, SUM_TIMER_READ, MIN_TIMER_READ, AVG_TIMER_READ, 
    MAX_TIMER_READ, SUM_NUMBER_OF_BYTES_READ, COUNT_WRITE, SUM_TIMER_WRITE, MIN_TIMER_WRITE, 
    AVG_TIMER_WRITE, MAX_TIMER_WRITE, SUM_NUMBER_OF_BYTES_WRITE, COUNT_MISC, SUM_TIMER_MISC, 
    MIN_TIMER_MISC, AVG_TIMER_MISC, MAX_TIMER_MISC
    from socket_summary_by_instance
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
    AVG_TIMER_WAIT, MAX_TIMER_WAIT, COUNT_READ, SUM_TIMER_READ, MIN_TIMER_READ, AVG_TIMER_READ, 
    MAX_TIMER_READ, SUM_NUMBER_OF_BYTES_READ, COUNT_WRITE, SUM_TIMER_WRITE, MIN_TIMER_WRITE, 
    AVG_TIMER_WRITE, MAX_TIMER_WRITE, SUM_NUMBER_OF_BYTES_WRITE, COUNT_MISC, SUM_TIMER_MISC, 
    MIN_TIMER_MISC, AVG_TIMER_MISC, MAX_TIMER_MISC
    from socket_summary_by_instance
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="CURRENT_CONNECTIONS" jdbcType="BIGINT" property="currentConnections" />
    <result column="TOTAL_CONNECTIONS" jdbcType="BIGINT" property="totalConnections" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into accounts (USER, HOST, CURRENT_CONNECTIONS, 
      TOTAL_CONNECTIONS)
    values (#{user,jdbcType=CHAR}, #{host,jdbcType=CHAR}, #{currentConnections,jdbcType=BIGINT}, 
      #{totalConnections,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, HOST, CURRENT_CONNECTIONS, TOTAL_CONNECTIONS
    from accounts
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="table_schema" jdbcType="VARCHAR" property="tableSchema" />
    <result column="table_name" jdbcType="VARCHAR" property="tableName" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="rows_fetched" jdbcType="BIGINT" property="rowsFetched" />
    <result column="fetch_latency" jdbcType="BIGINT" property="fetchLatency" />
    <result column="rows_inserted" jdbcType="BIGINT" property="rowsInserted" />
    <result column="insert_latency" jdbcType="BIGINT" property="insertLatency" />
    <result column="rows_updated" jdbcType="BIGINT" property="rowsUpdated" />
    <result column="update_latency" jdbcType="BIGINT" property="updateLatency" />
    <result column="rows_deleted" jdbcType="BIGINT" property="rowsDeleted" />
    <result column="delete_latency" jdbcType="BIGINT" property="deleteLatency" />
    <result column="io_read_requests" jdbcType="DECIMAL" property="ioReadRequests" />
    <result column="io_read" jdbcType="DECIMAL" property="ioRead" />
    <result column="io_read_latency" jdbcType="DECIMAL" property="ioReadLatency" />
    <result column="io_write_requests" jdbcType="DECIMAL" property="ioWriteRequests" />
    <result column="io_write" jdbcType="DECIMAL" property="ioWrite" />
    <result column="io_write_latency" jdbcType="DECIMAL" property="ioWriteLatency" />
    <result column="io_misc_requests" jdbcType="DECIMAL" property="ioMiscRequests" />
    <result column="io_misc_latency" jdbcType="DECIMAL" property="ioMiscLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$schema_table_statistics (table_schema, table_name, total_latency, 
      rows_fetched, fetch_latency, rows_inserted, 
      insert_latency, rows_updated, update_latency, 
      rows_deleted, delete_latency, io_read_requests, 
      io_read, io_read_latency, io_write_requests, 
      io_write, io_write_latency, io_misc_requests, 
      io_misc_latency)
    values (#{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, #{totalLatency,jdbcType=BIGINT}, 
      #{rowsFetched,jdbcType=BIGINT}, #{fetchLatency,jdbcType=BIGINT}, #{rowsInserted,jdbcType=BIGINT}, 
      #{insertLatency,jdbcType=BIGINT}, #{rowsUpdated,jdbcType=BIGINT}, #{updateLatency,jdbcType=BIGINT}, 
      #{rowsDeleted,jdbcType=BIGINT}, #{deleteLatency,jdbcType=BIGINT}, #{ioReadRequests,jdbcType=DECIMAL}, 
      #{ioRead,jdbcType=DECIMAL}, #{ioReadLatency,jdbcType=DECIMAL}, #{ioWriteRequests,jdbcType=DECIMAL}, 
      #{ioWrite,jdbcType=DECIMAL}, #{ioWriteLatency,jdbcType=DECIMAL}, #{ioMiscRequests,jdbcType=DECIMAL}, 
      #{ioMiscLatency,jdbcType=DECIMAL})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select table_schema, table_name, total_latency, rows_fetched, fetch_latency, rows_inserted, 
    insert_latency, rows_updated, update_latency, rows_deleted, delete_latency, io_read_requests, 
    io_read, io_read_latency, io_write_requests, io_write, io_write_latency, io_misc_requests, 
    io_misc_latency
    from x$schema_table_statistics
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="file" jdbcType="VARCHAR" property="file" />
    <result column="count_read" jdbcType="BIGINT" property="countRead" />
    <result column="total_read" jdbcType="BIGINT" property="totalRead" />
    <result column="avg_read" jdbcType="DECIMAL" property="avgRead" />
    <result column="count_write" jdbcType="BIGINT" property="countWrite" />
    <result column="total_written" jdbcType="BIGINT" property="totalWritten" />
    <result column="avg_write" jdbcType="DECIMAL" property="avgWrite" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="write_pct" jdbcType="DECIMAL" property="writePct" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$io_global_by_file_by_bytes (file, count_read, total_read, 
      avg_read, count_write, total_written, 
      avg_write, total, write_pct
      )
    values (#{file,jdbcType=VARCHAR}, #{countRead,jdbcType=BIGINT}, #{totalRead,jdbcType=BIGINT}, 
      #{avgRead,jdbcType=DECIMAL}, #{countWrite,jdbcType=BIGINT}, #{totalWritten,jdbcType=BIGINT}, 
      #{avgWrite,jdbcType=DECIMAL}, #{total,jdbcType=BIGINT}, #{writePct,jdbcType=DECIMAL}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select file, count_read, total_read, avg_read, count_write, total_written, avg_write, 
    total, write_pct
    from x$io_global_by_file_by_bytes
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="event_time" jdbcType="TIMESTAMP" property="eventTime" />
    <result column="thread_id" jdbcType="BIGINT" property="threadId" />
    <result column="server_id" jdbcType="INTEGER" property="serverId" />
    <result column="command_type" jdbcType="VARCHAR" property="commandType" />
    <result column="user_host" jdbcType="LONGVARCHAR" property="userHost" />
    <result column="argument" jdbcType="LONGVARBINARY" property="argument" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into general_log (event_time, thread_id, server_id, 
      command_type, user_host, argument
      )
    values (#{eventTime,jdbcType=TIMESTAMP}, #{threadId,jdbcType=BIGINT}, #{serverId,jdbcType=INTEGER}, 
      #{commandType,jdbcType=VARCHAR}, #{userHost,jdbcType=LONGVARCHAR}, #{argument,jdbcType=LONGVARBINARY}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select event_time, thread_id, server_id, command_type, user_host, argument
    from general_log
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="current_count_used" jdbcType="DECIMAL" property="currentCountUsed" />
    <result column="current_allocated" jdbcType="LONGVARCHAR" property="currentAllocated" />
    <result column="current_avg_alloc" jdbcType="LONGVARCHAR" property="currentAvgAlloc" />
    <result column="current_max_alloc" jdbcType="LONGVARCHAR" property="currentMaxAlloc" />
    <result column="total_allocated" jdbcType="LONGVARCHAR" property="totalAllocated" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into memory_by_host_by_current_bytes (host, current_count_used, current_allocated, 
      current_avg_alloc, current_max_alloc, 
      total_allocated)
    values (#{host,jdbcType=VARCHAR}, #{currentCountUsed,jdbcType=DECIMAL}, #{currentAllocated,jdbcType=LONGVARCHAR}, 
      #{currentAvgAlloc,jdbcType=LONGVARCHAR}, #{currentMaxAlloc,jdbcType=LONGVARCHAR}, 
      #{totalAllocated,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, current_count_used, current_allocated, current_avg_alloc, current_max_alloc, 
    total_allocated
    from memory_by_host_by_current_bytes
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="UNIT_NAME" jdbcType="VARCHAR" property="unitName" />
    <result column="UNIT_TYPE" jdbcType="VARCHAR" property="unitType" />
    <result column="CONVERSION_FACTOR" jdbcType="DOUBLE" property="conversionFactor" />
    <result column="DESCRIPTION" jdbcType="VARCHAR" property="description" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into ST_UNITS_OF_MEASURE (UNIT_NAME, UNIT_TYPE, CONVERSION_FACTOR, 
      DESCRIPTION)
    values (#{unitName,jdbcType=VARCHAR}, #{unitType,jdbcType=VARCHAR}, #{conversionFactor,jdbcType=DOUBLE}, 
      #{description,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select UNIT_NAME, UNIT_TYPE, CONVERSION_FACTOR, DESCRIPTION
    from ST_UNITS_OF_MEASURE
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="VARIABLE_NAME" jdbcType="VARCHAR" property="variableName" />
    <result column="VARIABLE_VALUE" jdbcType="VARCHAR" property="variableValue" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from session_status
    where VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into session_status (VARIABLE_NAME, VARIABLE_VALUE)
    values (#{variableName,jdbcType=VARCHAR}, #{variableValue,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update session_status
    set VARIABLE_VALUE = #{variableValue,jdbcType=VARCHAR}
    where VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select VARIABLE_NAME, VARIABLE_VALUE
    from session_status
    where VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select VARIABLE_NAME, VARIABLE_VALUE
    from session_status
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="name" jdbcType="VARCHAR" property="name" />
    <result column="dl" jdbcType="VARCHAR" property="dl" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from plugin
    where name = #{name,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into plugin (name, dl)
    values (#{name,jdbcType=VARCHAR}, #{dl,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update plugin
    set dl = #{dl,jdbcType=VARCHAR}
    where name = #{name,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select name, dl
    from plugin
    where name = #{name,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select name, dl
    from plugin
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="uid" jdbcType="VARCHAR" property="uid" />
    <result column="uname" jdbcType="VARCHAR" property="uname" />
    <result column="pwd" jdbcType="VARCHAR" property="pwd" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from user_login
    where uid = #{uid,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into user_login (uid, uname, pwd
      )
    values (#{uid,jdbcType=VARCHAR}, #{uname,jdbcType=VARCHAR}, #{pwd,jdbcType=VARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update user_login
    set uname = #{uname,jdbcType=VARCHAR},
      pwd = #{pwd,jdbcType=VARCHAR}
    where uid = #{uid,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select uid, uname, pwd
    from user_login
    where uid = #{uid,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select uid, uname, pwd
    from user_login
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="eid" jdbcType="INTEGER" property="eid" />
    <result column="ename" jdbcType="VARCHAR" property="ename" />
    <result column="esex" jdbcType="INTEGER" property="esex" />
    <result column="egw" jdbcType="VARCHAR" property="egw" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from emp
    where eid = #{eid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into emp (eid, ename, esex, 
      egw)
    values (#{eid,jdbcType=INTEGER}, #{ename,jdbcType=VARCHAR}, #{esex,jdbcType=INTEGER}, 
      #{egw,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update emp
    set ename = #{ename,jdbcType=VARCHAR},
      esex = #{esex,jdbcType=INTEGER},
      egw = #{egw,jdbcType=VARCHAR}
    where eid = #{eid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select eid, ename, esex, egw
    from emp
    where eid = #{eid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select eid, ename, esex, egw
    from emp
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="file" jdbcType="VARCHAR" property="file" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="count_read" jdbcType="BIGINT" property="countRead" />
    <result column="count_write" jdbcType="BIGINT" property="countWrite" />
    <result column="count_misc" jdbcType="BIGINT" property="countMisc" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="read_latency" jdbcType="LONGVARCHAR" property="readLatency" />
    <result column="write_latency" jdbcType="LONGVARCHAR" property="writeLatency" />
    <result column="misc_latency" jdbcType="LONGVARCHAR" property="miscLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into io_global_by_file_by_latency (file, total, count_read, 
      count_write, count_misc, total_latency, 
      read_latency, write_latency, misc_latency
      )
    values (#{file,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, #{countRead,jdbcType=BIGINT}, 
      #{countWrite,jdbcType=BIGINT}, #{countMisc,jdbcType=BIGINT}, #{totalLatency,jdbcType=LONGVARCHAR}, 
      #{readLatency,jdbcType=LONGVARCHAR}, #{writeLatency,jdbcType=LONGVARCHAR}, #{miscLatency,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select file, total, count_read, count_write, count_misc, total_latency, read_latency, 
    write_latency, misc_latency
    from io_global_by_file_by_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Host" jdbcType="CHAR" property="host" />
    <id column="Db" jdbcType="CHAR" property="db" />
    <id column="User" jdbcType="CHAR" property="user" />
    <id column="Table_name" jdbcType="CHAR" property="tableName" />
    <id column="Column_name" jdbcType="CHAR" property="columnName" />
    <result column="Timestamp" jdbcType="TIMESTAMP" property="timestamp" />
    <result column="Column_priv" jdbcType="CHAR" property="columnPriv" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from columns_priv
    where Host = #{host,jdbcType=CHAR}
      and Db = #{db,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
      and Table_name = #{tableName,jdbcType=CHAR}
      and Column_name = #{columnName,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into columns_priv (Host, Db, User, Table_name, 
      Column_name, Timestamp, Column_priv
      )
    values (#{host,jdbcType=CHAR}, #{db,jdbcType=CHAR}, #{user,jdbcType=CHAR}, #{tableName,jdbcType=CHAR}, 
      #{columnName,jdbcType=CHAR}, #{timestamp,jdbcType=TIMESTAMP}, #{columnPriv,jdbcType=CHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update columns_priv
    set Timestamp = #{timestamp,jdbcType=TIMESTAMP},
      Column_priv = #{columnPriv,jdbcType=CHAR}
    where Host = #{host,jdbcType=CHAR}
      and Db = #{db,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
      and Table_name = #{tableName,jdbcType=CHAR}
      and Column_name = #{columnName,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select Host, Db, User, Table_name, Column_name, Timestamp, Column_priv
    from columns_priv
    where Host = #{host,jdbcType=CHAR}
      and Db = #{db,jdbcType=CHAR}
      and User = #{user,jdbcType=CHAR}
      and Table_name = #{tableName,jdbcType=CHAR}
      and Column_name = #{columnName,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Host, Db, User, Table_name, Column_name, Timestamp, Column_priv
    from columns_priv
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="name" jdbcType="VARCHAR" property="name" />
    <result column="value" jdbcType="VARCHAR" property="value" />
    <result column="description" jdbcType="VARCHAR" property="description" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from t_options
    where name = #{name,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into t_options (name, value, description
      )
    values (#{name,jdbcType=VARCHAR}, #{value,jdbcType=VARCHAR}, #{description,jdbcType=VARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update t_options
    set value = #{value,jdbcType=VARCHAR},
      description = #{description,jdbcType=VARCHAR}
    where name = #{name,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select name, value, description
    from t_options
    where name = #{name,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select name, value, description
    from t_options
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="NAME" jdbcType="VARCHAR" property="name" />
    <result column="POS" jdbcType="BIGINT" property="pos" />
    <result column="INDEX_ID" jdbcType="VARBINARY" property="indexId" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_FIELDS (NAME, POS, INDEX_ID
      )
    values (#{name,jdbcType=VARCHAR}, #{pos,jdbcType=BIGINT}, #{indexId,jdbcType=VARBINARY}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select NAME, POS, INDEX_ID
    from INNODB_FIELDS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="VARIABLE_NAME" jdbcType="VARCHAR" property="variableName" />
    <result column="VARIABLE_VALUE" jdbcType="VARCHAR" property="variableValue" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from persisted_variables
    where VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into persisted_variables (VARIABLE_NAME, VARIABLE_VALUE)
    values (#{variableName,jdbcType=VARCHAR}, #{variableValue,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update persisted_variables
    set VARIABLE_VALUE = #{variableValue,jdbcType=VARCHAR}
    where VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select VARIABLE_NAME, VARIABLE_VALUE
    from persisted_variables
    where VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select VARIABLE_NAME, VARIABLE_VALUE
    from persisted_variables
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="RESOURCE_GROUP_NAME" jdbcType="VARCHAR" property="resourceGroupName" />
    <result column="RESOURCE_GROUP_TYPE" jdbcType="CHAR" property="resourceGroupType" />
    <result column="RESOURCE_GROUP_ENABLED" jdbcType="BIT" property="resourceGroupEnabled" />
    <result column="THREAD_PRIORITY" jdbcType="INTEGER" property="threadPriority" />
    <result column="VCPU_IDS" jdbcType="LONGVARBINARY" property="vcpuIds" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into RESOURCE_GROUPS (RESOURCE_GROUP_NAME, RESOURCE_GROUP_TYPE, 
      RESOURCE_GROUP_ENABLED, THREAD_PRIORITY, VCPU_IDS
      )
    values (#{resourceGroupName,jdbcType=VARCHAR}, #{resourceGroupType,jdbcType=CHAR}, 
      #{resourceGroupEnabled,jdbcType=BIT}, #{threadPriority,jdbcType=INTEGER}, #{vcpuIds,jdbcType=LONGVARBINARY}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select RESOURCE_GROUP_NAME, RESOURCE_GROUP_TYPE, RESOURCE_GROUP_ENABLED, THREAD_PRIORITY, 
    VCPU_IDS
    from RESOURCE_GROUPS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="object_schema" jdbcType="VARCHAR" property="objectSchema" />
    <result column="object_name" jdbcType="VARCHAR" property="objectName" />
    <result column="rows_full_scanned" jdbcType="BIGINT" property="rowsFullScanned" />
    <result column="latency" jdbcType="LONGVARCHAR" property="latency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into schema_tables_with_full_table_scans (object_schema, object_name, rows_full_scanned, 
      latency)
    values (#{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, #{rowsFullScanned,jdbcType=BIGINT}, 
      #{latency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select object_schema, object_name, rows_full_scanned, latency
    from schema_tables_with_full_table_scans
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Server_name" jdbcType="CHAR" property="serverName" />
    <result column="Host" jdbcType="CHAR" property="host" />
    <result column="Db" jdbcType="CHAR" property="db" />
    <result column="Username" jdbcType="CHAR" property="username" />
    <result column="Password" jdbcType="CHAR" property="password" />
    <result column="Port" jdbcType="INTEGER" property="port" />
    <result column="Socket" jdbcType="CHAR" property="socket" />
    <result column="Wrapper" jdbcType="CHAR" property="wrapper" />
    <result column="Owner" jdbcType="CHAR" property="owner" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from servers
    where Server_name = #{serverName,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into servers (Server_name, Host, Db, 
      Username, Password, Port, 
      Socket, Wrapper, Owner)
    values (#{serverName,jdbcType=CHAR}, #{host,jdbcType=CHAR}, #{db,jdbcType=CHAR}, 
      #{username,jdbcType=CHAR}, #{password,jdbcType=CHAR}, #{port,jdbcType=INTEGER}, 
      #{socket,jdbcType=CHAR}, #{wrapper,jdbcType=CHAR}, #{owner,jdbcType=CHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update servers
    set Host = #{host,jdbcType=CHAR},
      Db = #{db,jdbcType=CHAR},
      Username = #{username,jdbcType=CHAR},
      Password = #{password,jdbcType=CHAR},
      Port = #{port,jdbcType=INTEGER},
      Socket = #{socket,jdbcType=CHAR},
      Wrapper = #{wrapper,jdbcType=CHAR},
      Owner = #{owner,jdbcType=CHAR}
    where Server_name = #{serverName,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select Server_name, Host, Db, Username, Password, Port, Socket, Wrapper, Owner
    from servers
    where Server_name = #{serverName,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Server_name, Host, Db, Username, Password, Port, Socket, Wrapper, Owner
    from servers
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="VARIABLE_NAME" jdbcType="VARCHAR" property="variableName" />
    <result column="VARIABLE_VALUE" jdbcType="VARCHAR" property="variableValue" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from session_variables
    where VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into session_variables (VARIABLE_NAME, VARIABLE_VALUE)
    values (#{variableName,jdbcType=VARCHAR}, #{variableValue,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update session_variables
    set VARIABLE_VALUE = #{variableValue,jdbcType=VARCHAR}
    where VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select VARIABLE_NAME, VARIABLE_VALUE
    from session_variables
    where VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select VARIABLE_NAME, VARIABLE_VALUE
    from session_variables
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="WORD" jdbcType="VARCHAR" property="word" />
    <result column="FIRST_DOC_ID" jdbcType="BIGINT" property="firstDocId" />
    <result column="LAST_DOC_ID" jdbcType="BIGINT" property="lastDocId" />
    <result column="DOC_COUNT" jdbcType="BIGINT" property="docCount" />
    <result column="DOC_ID" jdbcType="BIGINT" property="docId" />
    <result column="POSITION" jdbcType="BIGINT" property="position" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_FT_INDEX_TABLE (WORD, FIRST_DOC_ID, LAST_DOC_ID, 
      DOC_COUNT, DOC_ID, POSITION
      )
    values (#{word,jdbcType=VARCHAR}, #{firstDocId,jdbcType=BIGINT}, #{lastDocId,jdbcType=BIGINT}, 
      #{docCount,jdbcType=BIGINT}, #{docId,jdbcType=BIGINT}, #{position,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select WORD, FIRST_DOC_ID, LAST_DOC_ID, DOC_COUNT, DOC_ID, POSITION
    from INNODB_FT_INDEX_TABLE
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="value" jdbcType="VARCHAR" property="value" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_FT_DEFAULT_STOPWORD (value)
    values (#{value,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select value
    from INNODB_FT_DEFAULT_STOPWORD
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="id" jdbcType="INTEGER" property="id" />
    <result column="task_key" jdbcType="VARCHAR" property="taskKey" />
    <result column="task_desc" jdbcType="VARCHAR" property="taskDesc" />
    <result column="task_cron" jdbcType="VARCHAR" property="taskCron" />
    <result column="init_start_flag" jdbcType="INTEGER" property="initStartFlag" />
    <result column="create_time" jdbcType="TIMESTAMP" property="createTime" />
    <result column="update_time" jdbcType="TIMESTAMP" property="updateTime" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from scheduled_task
    where id = #{id,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into scheduled_task (task_key, task_desc, task_cron, 
      init_start_flag, create_time, update_time
      )
    values (#{taskKey,jdbcType=VARCHAR}, #{taskDesc,jdbcType=VARCHAR}, #{taskCron,jdbcType=VARCHAR}, 
      #{initStartFlag,jdbcType=INTEGER}, #{createTime,jdbcType=TIMESTAMP}, #{updateTime,jdbcType=TIMESTAMP}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update scheduled_task
    set task_key = #{taskKey,jdbcType=VARCHAR},
      task_desc = #{taskDesc,jdbcType=VARCHAR},
      task_cron = #{taskCron,jdbcType=VARCHAR},
      init_start_flag = #{initStartFlag,jdbcType=INTEGER},
      create_time = #{createTime,jdbcType=TIMESTAMP},
      update_time = #{updateTime,jdbcType=TIMESTAMP}
    where id = #{id,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select id, task_key, task_desc, task_cron, init_start_flag, create_time, update_time
    from scheduled_task
    where id = #{id,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select id, task_key, task_desc, task_cron, init_start_flag, create_time, update_time
    from scheduled_task
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="event_name" jdbcType="VARCHAR" property="eventName" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="min_latency" jdbcType="BIGINT" property="minLatency" />
    <result column="avg_latency" jdbcType="BIGINT" property="avgLatency" />
    <result column="max_latency" jdbcType="BIGINT" property="maxLatency" />
    <result column="count_read" jdbcType="BIGINT" property="countRead" />
    <result column="total_read" jdbcType="BIGINT" property="totalRead" />
    <result column="avg_read" jdbcType="DECIMAL" property="avgRead" />
    <result column="count_write" jdbcType="BIGINT" property="countWrite" />
    <result column="total_written" jdbcType="BIGINT" property="totalWritten" />
    <result column="avg_written" jdbcType="DECIMAL" property="avgWritten" />
    <result column="total_requested" jdbcType="BIGINT" property="totalRequested" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$io_global_by_wait_by_bytes (event_name, total, total_latency, 
      min_latency, avg_latency, max_latency, 
      count_read, total_read, avg_read, 
      count_write, total_written, avg_written, 
      total_requested)
    values (#{eventName,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, #{totalLatency,jdbcType=BIGINT}, 
      #{minLatency,jdbcType=BIGINT}, #{avgLatency,jdbcType=BIGINT}, #{maxLatency,jdbcType=BIGINT}, 
      #{countRead,jdbcType=BIGINT}, #{totalRead,jdbcType=BIGINT}, #{avgRead,jdbcType=DECIMAL}, 
      #{countWrite,jdbcType=BIGINT}, #{totalWritten,jdbcType=BIGINT}, #{avgWritten,jdbcType=DECIMAL}, 
      #{totalRequested,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select event_name, total, total_latency, min_latency, avg_latency, max_latency, count_read, 
    total_read, avg_read, count_write, total_written, avg_written, total_requested
    from x$io_global_by_wait_by_bytes
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="QUERY_ID" jdbcType="INTEGER" property="queryId" />
    <result column="SEQ" jdbcType="INTEGER" property="seq" />
    <result column="STATE" jdbcType="VARCHAR" property="state" />
    <result column="DURATION" jdbcType="DECIMAL" property="duration" />
    <result column="CPU_USER" jdbcType="DECIMAL" property="cpuUser" />
    <result column="CPU_SYSTEM" jdbcType="DECIMAL" property="cpuSystem" />
    <result column="CONTEXT_VOLUNTARY" jdbcType="INTEGER" property="contextVoluntary" />
    <result column="CONTEXT_INVOLUNTARY" jdbcType="INTEGER" property="contextInvoluntary" />
    <result column="BLOCK_OPS_IN" jdbcType="INTEGER" property="blockOpsIn" />
    <result column="BLOCK_OPS_OUT" jdbcType="INTEGER" property="blockOpsOut" />
    <result column="MESSAGES_SENT" jdbcType="INTEGER" property="messagesSent" />
    <result column="MESSAGES_RECEIVED" jdbcType="INTEGER" property="messagesReceived" />
    <result column="PAGE_FAULTS_MAJOR" jdbcType="INTEGER" property="pageFaultsMajor" />
    <result column="PAGE_FAULTS_MINOR" jdbcType="INTEGER" property="pageFaultsMinor" />
    <result column="SWAPS" jdbcType="INTEGER" property="swaps" />
    <result column="SOURCE_FUNCTION" jdbcType="VARCHAR" property="sourceFunction" />
    <result column="SOURCE_FILE" jdbcType="VARCHAR" property="sourceFile" />
    <result column="SOURCE_LINE" jdbcType="INTEGER" property="sourceLine" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into PROFILING (QUERY_ID, SEQ, STATE, 
      DURATION, CPU_USER, CPU_SYSTEM, 
      CONTEXT_VOLUNTARY, CONTEXT_INVOLUNTARY, BLOCK_OPS_IN, 
      BLOCK_OPS_OUT, MESSAGES_SENT, MESSAGES_RECEIVED, 
      PAGE_FAULTS_MAJOR, PAGE_FAULTS_MINOR, SWAPS, 
      SOURCE_FUNCTION, SOURCE_FILE, SOURCE_LINE
      )
    values (#{queryId,jdbcType=INTEGER}, #{seq,jdbcType=INTEGER}, #{state,jdbcType=VARCHAR}, 
      #{duration,jdbcType=DECIMAL}, #{cpuUser,jdbcType=DECIMAL}, #{cpuSystem,jdbcType=DECIMAL}, 
      #{contextVoluntary,jdbcType=INTEGER}, #{contextInvoluntary,jdbcType=INTEGER}, #{blockOpsIn,jdbcType=INTEGER}, 
      #{blockOpsOut,jdbcType=INTEGER}, #{messagesSent,jdbcType=INTEGER}, #{messagesReceived,jdbcType=INTEGER}, 
      #{pageFaultsMajor,jdbcType=INTEGER}, #{pageFaultsMinor,jdbcType=INTEGER}, #{swaps,jdbcType=INTEGER}, 
      #{sourceFunction,jdbcType=VARCHAR}, #{sourceFile,jdbcType=VARCHAR}, #{sourceLine,jdbcType=INTEGER}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select QUERY_ID, SEQ, STATE, DURATION, CPU_USER, CPU_SYSTEM, CONTEXT_VOLUNTARY, CONTEXT_INVOLUNTARY, 
    BLOCK_OPS_IN, BLOCK_OPS_OUT, MESSAGES_SENT, MESSAGES_RECEIVED, PAGE_FAULTS_MAJOR, 
    PAGE_FAULTS_MINOR, SWAPS, SOURCE_FUNCTION, SOURCE_FILE, SOURCE_LINE
    from PROFILING
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="current_count_used" jdbcType="DECIMAL" property="currentCountUsed" />
    <result column="current_allocated" jdbcType="LONGVARCHAR" property="currentAllocated" />
    <result column="current_avg_alloc" jdbcType="LONGVARCHAR" property="currentAvgAlloc" />
    <result column="current_max_alloc" jdbcType="LONGVARCHAR" property="currentMaxAlloc" />
    <result column="total_allocated" jdbcType="LONGVARCHAR" property="totalAllocated" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into memory_by_user_by_current_bytes (user, current_count_used, current_allocated, 
      current_avg_alloc, current_max_alloc, 
      total_allocated)
    values (#{user,jdbcType=VARCHAR}, #{currentCountUsed,jdbcType=DECIMAL}, #{currentAllocated,jdbcType=LONGVARCHAR}, 
      #{currentAvgAlloc,jdbcType=LONGVARCHAR}, #{currentMaxAlloc,jdbcType=LONGVARCHAR}, 
      #{totalAllocated,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, current_count_used, current_allocated, current_avg_alloc, current_max_alloc, 
    total_allocated
    from memory_by_user_by_current_bytes
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="POOL_ID" jdbcType="BIGINT" property="poolId" />
    <result column="BLOCK_ID" jdbcType="BIGINT" property="blockId" />
    <result column="SPACE" jdbcType="BIGINT" property="space" />
    <result column="PAGE_NUMBER" jdbcType="BIGINT" property="pageNumber" />
    <result column="PAGE_TYPE" jdbcType="VARCHAR" property="pageType" />
    <result column="FLUSH_TYPE" jdbcType="BIGINT" property="flushType" />
    <result column="FIX_COUNT" jdbcType="BIGINT" property="fixCount" />
    <result column="IS_HASHED" jdbcType="VARCHAR" property="isHashed" />
    <result column="NEWEST_MODIFICATION" jdbcType="BIGINT" property="newestModification" />
    <result column="OLDEST_MODIFICATION" jdbcType="BIGINT" property="oldestModification" />
    <result column="ACCESS_TIME" jdbcType="BIGINT" property="accessTime" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
    <result column="INDEX_NAME" jdbcType="VARCHAR" property="indexName" />
    <result column="NUMBER_RECORDS" jdbcType="BIGINT" property="numberRecords" />
    <result column="DATA_SIZE" jdbcType="BIGINT" property="dataSize" />
    <result column="COMPRESSED_SIZE" jdbcType="BIGINT" property="compressedSize" />
    <result column="PAGE_STATE" jdbcType="VARCHAR" property="pageState" />
    <result column="IO_FIX" jdbcType="VARCHAR" property="ioFix" />
    <result column="IS_OLD" jdbcType="VARCHAR" property="isOld" />
    <result column="FREE_PAGE_CLOCK" jdbcType="BIGINT" property="freePageClock" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_BUFFER_PAGE (POOL_ID, BLOCK_ID, SPACE, 
      PAGE_NUMBER, PAGE_TYPE, FLUSH_TYPE, 
      FIX_COUNT, IS_HASHED, NEWEST_MODIFICATION, 
      OLDEST_MODIFICATION, ACCESS_TIME, TABLE_NAME, 
      INDEX_NAME, NUMBER_RECORDS, DATA_SIZE, 
      COMPRESSED_SIZE, PAGE_STATE, IO_FIX, 
      IS_OLD, FREE_PAGE_CLOCK)
    values (#{poolId,jdbcType=BIGINT}, #{blockId,jdbcType=BIGINT}, #{space,jdbcType=BIGINT}, 
      #{pageNumber,jdbcType=BIGINT}, #{pageType,jdbcType=VARCHAR}, #{flushType,jdbcType=BIGINT}, 
      #{fixCount,jdbcType=BIGINT}, #{isHashed,jdbcType=VARCHAR}, #{newestModification,jdbcType=BIGINT}, 
      #{oldestModification,jdbcType=BIGINT}, #{accessTime,jdbcType=BIGINT}, #{tableName,jdbcType=VARCHAR}, 
      #{indexName,jdbcType=VARCHAR}, #{numberRecords,jdbcType=BIGINT}, #{dataSize,jdbcType=BIGINT}, 
      #{compressedSize,jdbcType=BIGINT}, #{pageState,jdbcType=VARCHAR}, #{ioFix,jdbcType=VARCHAR}, 
      #{isOld,jdbcType=VARCHAR}, #{freePageClock,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select POOL_ID, BLOCK_ID, SPACE, PAGE_NUMBER, PAGE_TYPE, FLUSH_TYPE, FIX_COUNT, IS_HASHED, 
    NEWEST_MODIFICATION, OLDEST_MODIFICATION, ACCESS_TIME, TABLE_NAME, INDEX_NAME, NUMBER_RECORDS, 
    DATA_SIZE, COMPRESSED_SIZE, PAGE_STATE, IO_FIX, IS_OLD, FREE_PAGE_CLOCK
    from INNODB_BUFFER_PAGE
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="coid" jdbcType="INTEGER" property="coid" />
    <result column="cid" jdbcType="INTEGER" property="cid" />
    <result column="created" jdbcType="INTEGER" property="created" />
    <result column="author" jdbcType="VARCHAR" property="author" />
    <result column="authorId" jdbcType="INTEGER" property="authorid" />
    <result column="ownerId" jdbcType="INTEGER" property="ownerid" />
    <result column="mail" jdbcType="VARCHAR" property="mail" />
    <result column="url" jdbcType="VARCHAR" property="url" />
    <result column="ip" jdbcType="VARCHAR" property="ip" />
    <result column="agent" jdbcType="VARCHAR" property="agent" />
    <result column="type" jdbcType="VARCHAR" property="type" />
    <result column="status" jdbcType="VARCHAR" property="status" />
    <result column="parent" jdbcType="INTEGER" property="parent" />
    <result column="content" jdbcType="LONGVARCHAR" property="content" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from t_comments
    where coid = #{coid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into t_comments (coid, cid, created, 
      author, authorId, ownerId, 
      mail, url, ip, agent, 
      type, status, parent, 
      content)
    values (#{coid,jdbcType=INTEGER}, #{cid,jdbcType=INTEGER}, #{created,jdbcType=INTEGER}, 
      #{author,jdbcType=VARCHAR}, #{authorid,jdbcType=INTEGER}, #{ownerid,jdbcType=INTEGER}, 
      #{mail,jdbcType=VARCHAR}, #{url,jdbcType=VARCHAR}, #{ip,jdbcType=VARCHAR}, #{agent,jdbcType=VARCHAR}, 
      #{type,jdbcType=VARCHAR}, #{status,jdbcType=VARCHAR}, #{parent,jdbcType=INTEGER}, 
      #{content,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update t_comments
    set cid = #{cid,jdbcType=INTEGER},
      created = #{created,jdbcType=INTEGER},
      author = #{author,jdbcType=VARCHAR},
      authorId = #{authorid,jdbcType=INTEGER},
      ownerId = #{ownerid,jdbcType=INTEGER},
      mail = #{mail,jdbcType=VARCHAR},
      url = #{url,jdbcType=VARCHAR},
      ip = #{ip,jdbcType=VARCHAR},
      agent = #{agent,jdbcType=VARCHAR},
      type = #{type,jdbcType=VARCHAR},
      status = #{status,jdbcType=VARCHAR},
      parent = #{parent,jdbcType=INTEGER},
      content = #{content,jdbcType=LONGVARCHAR}
    where coid = #{coid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select coid, cid, created, author, authorId, ownerId, mail, url, ip, agent, type, 
    status, parent, content
    from t_comments
    where coid = #{coid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select coid, cid, created, author, authorId, ownerId, mail, url, ip, agent, type, 
    status, parent, content
    from t_comments
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_ALLOC" jdbcType="BIGINT" property="countAlloc" />
    <result column="COUNT_FREE" jdbcType="BIGINT" property="countFree" />
    <result column="SUM_NUMBER_OF_BYTES_ALLOC" jdbcType="BIGINT" property="sumNumberOfBytesAlloc" />
    <result column="SUM_NUMBER_OF_BYTES_FREE" jdbcType="BIGINT" property="sumNumberOfBytesFree" />
    <result column="LOW_COUNT_USED" jdbcType="BIGINT" property="lowCountUsed" />
    <result column="CURRENT_COUNT_USED" jdbcType="BIGINT" property="currentCountUsed" />
    <result column="HIGH_COUNT_USED" jdbcType="BIGINT" property="highCountUsed" />
    <result column="LOW_NUMBER_OF_BYTES_USED" jdbcType="BIGINT" property="lowNumberOfBytesUsed" />
    <result column="CURRENT_NUMBER_OF_BYTES_USED" jdbcType="BIGINT" property="currentNumberOfBytesUsed" />
    <result column="HIGH_NUMBER_OF_BYTES_USED" jdbcType="BIGINT" property="highNumberOfBytesUsed" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from memory_summary_by_thread_by_event_name
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into memory_summary_by_thread_by_event_name (THREAD_ID, EVENT_NAME, COUNT_ALLOC, 
      COUNT_FREE, SUM_NUMBER_OF_BYTES_ALLOC, SUM_NUMBER_OF_BYTES_FREE, 
      LOW_COUNT_USED, CURRENT_COUNT_USED, HIGH_COUNT_USED, 
      LOW_NUMBER_OF_BYTES_USED, CURRENT_NUMBER_OF_BYTES_USED, 
      HIGH_NUMBER_OF_BYTES_USED)
    values (#{threadId,jdbcType=BIGINT}, #{eventName,jdbcType=VARCHAR}, #{countAlloc,jdbcType=BIGINT}, 
      #{countFree,jdbcType=BIGINT}, #{sumNumberOfBytesAlloc,jdbcType=BIGINT}, #{sumNumberOfBytesFree,jdbcType=BIGINT}, 
      #{lowCountUsed,jdbcType=BIGINT}, #{currentCountUsed,jdbcType=BIGINT}, #{highCountUsed,jdbcType=BIGINT}, 
      #{lowNumberOfBytesUsed,jdbcType=BIGINT}, #{currentNumberOfBytesUsed,jdbcType=BIGINT}, 
      #{highNumberOfBytesUsed,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update memory_summary_by_thread_by_event_name
    set COUNT_ALLOC = #{countAlloc,jdbcType=BIGINT},
      COUNT_FREE = #{countFree,jdbcType=BIGINT},
      SUM_NUMBER_OF_BYTES_ALLOC = #{sumNumberOfBytesAlloc,jdbcType=BIGINT},
      SUM_NUMBER_OF_BYTES_FREE = #{sumNumberOfBytesFree,jdbcType=BIGINT},
      LOW_COUNT_USED = #{lowCountUsed,jdbcType=BIGINT},
      CURRENT_COUNT_USED = #{currentCountUsed,jdbcType=BIGINT},
      HIGH_COUNT_USED = #{highCountUsed,jdbcType=BIGINT},
      LOW_NUMBER_OF_BYTES_USED = #{lowNumberOfBytesUsed,jdbcType=BIGINT},
      CURRENT_NUMBER_OF_BYTES_USED = #{currentNumberOfBytesUsed,jdbcType=BIGINT},
      HIGH_NUMBER_OF_BYTES_USED = #{highNumberOfBytesUsed,jdbcType=BIGINT}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_NAME, COUNT_ALLOC, COUNT_FREE, SUM_NUMBER_OF_BYTES_ALLOC, 
    SUM_NUMBER_OF_BYTES_FREE, LOW_COUNT_USED, CURRENT_COUNT_USED, HIGH_COUNT_USED, LOW_NUMBER_OF_BYTES_USED, 
    CURRENT_NUMBER_OF_BYTES_USED, HIGH_NUMBER_OF_BYTES_USED
    from memory_summary_by_thread_by_event_name
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_NAME, COUNT_ALLOC, COUNT_FREE, SUM_NUMBER_OF_BYTES_ALLOC, 
    SUM_NUMBER_OF_BYTES_FREE, LOW_COUNT_USED, CURRENT_COUNT_USED, HIGH_COUNT_USED, LOW_NUMBER_OF_BYTES_USED, 
    CURRENT_NUMBER_OF_BYTES_USED, HIGH_NUMBER_OF_BYTES_USED
    from memory_summary_by_thread_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="SERVER_UUID" jdbcType="CHAR" property="serverUuid" />
    <result column="LOCAL" jdbcType="LONGVARCHAR" property="local" />
    <result column="REPLICATION" jdbcType="LONGVARCHAR" property="replication" />
    <result column="STORAGE_ENGINES" jdbcType="LONGVARCHAR" property="storageEngines" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into log_status (SERVER_UUID, LOCAL, REPLICATION, 
      STORAGE_ENGINES)
    values (#{serverUuid,jdbcType=CHAR}, #{local,jdbcType=LONGVARCHAR}, #{replication,jdbcType=LONGVARCHAR}, 
      #{storageEngines,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select SERVER_UUID, LOCAL, REPLICATION, STORAGE_ENGINES
    from log_status
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="thd_id" jdbcType="BIGINT" property="thdId" />
    <result column="conn_id" jdbcType="BIGINT" property="connId" />
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="command" jdbcType="VARCHAR" property="command" />
    <result column="state" jdbcType="VARCHAR" property="state" />
    <result column="time" jdbcType="BIGINT" property="time" />
    <result column="progress" jdbcType="DECIMAL" property="progress" />
    <result column="rows_examined" jdbcType="BIGINT" property="rowsExamined" />
    <result column="rows_sent" jdbcType="BIGINT" property="rowsSent" />
    <result column="rows_affected" jdbcType="BIGINT" property="rowsAffected" />
    <result column="tmp_tables" jdbcType="BIGINT" property="tmpTables" />
    <result column="tmp_disk_tables" jdbcType="BIGINT" property="tmpDiskTables" />
    <result column="full_scan" jdbcType="VARCHAR" property="fullScan" />
    <result column="last_wait" jdbcType="VARCHAR" property="lastWait" />
    <result column="source" jdbcType="VARCHAR" property="source" />
    <result column="trx_state" jdbcType="CHAR" property="trxState" />
    <result column="trx_autocommit" jdbcType="CHAR" property="trxAutocommit" />
    <result column="pid" jdbcType="VARCHAR" property="pid" />
    <result column="program_name" jdbcType="VARCHAR" property="programName" />
    <result column="current_statement" jdbcType="LONGVARCHAR" property="currentStatement" />
    <result column="statement_latency" jdbcType="LONGVARCHAR" property="statementLatency" />
    <result column="lock_latency" jdbcType="LONGVARCHAR" property="lockLatency" />
    <result column="last_statement" jdbcType="LONGVARCHAR" property="lastStatement" />
    <result column="last_statement_latency" jdbcType="LONGVARCHAR" property="lastStatementLatency" />
    <result column="current_memory" jdbcType="LONGVARCHAR" property="currentMemory" />
    <result column="last_wait_latency" jdbcType="LONGVARCHAR" property="lastWaitLatency" />
    <result column="trx_latency" jdbcType="LONGVARCHAR" property="trxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into session (thd_id, conn_id, user, 
      db, command, state, 
      time, progress, rows_examined, 
      rows_sent, rows_affected, tmp_tables, 
      tmp_disk_tables, full_scan, last_wait, 
      source, trx_state, trx_autocommit, 
      pid, program_name, current_statement, 
      statement_latency, lock_latency, 
      last_statement, last_statement_latency, 
      current_memory, last_wait_latency, 
      trx_latency)
    values (#{thdId,jdbcType=BIGINT}, #{connId,jdbcType=BIGINT}, #{user,jdbcType=VARCHAR}, 
      #{db,jdbcType=VARCHAR}, #{command,jdbcType=VARCHAR}, #{state,jdbcType=VARCHAR}, 
      #{time,jdbcType=BIGINT}, #{progress,jdbcType=DECIMAL}, #{rowsExamined,jdbcType=BIGINT}, 
      #{rowsSent,jdbcType=BIGINT}, #{rowsAffected,jdbcType=BIGINT}, #{tmpTables,jdbcType=BIGINT}, 
      #{tmpDiskTables,jdbcType=BIGINT}, #{fullScan,jdbcType=VARCHAR}, #{lastWait,jdbcType=VARCHAR}, 
      #{source,jdbcType=VARCHAR}, #{trxState,jdbcType=CHAR}, #{trxAutocommit,jdbcType=CHAR}, 
      #{pid,jdbcType=VARCHAR}, #{programName,jdbcType=VARCHAR}, #{currentStatement,jdbcType=LONGVARCHAR}, 
      #{statementLatency,jdbcType=LONGVARCHAR}, #{lockLatency,jdbcType=LONGVARCHAR}, 
      #{lastStatement,jdbcType=LONGVARCHAR}, #{lastStatementLatency,jdbcType=LONGVARCHAR}, 
      #{currentMemory,jdbcType=LONGVARCHAR}, #{lastWaitLatency,jdbcType=LONGVARCHAR}, 
      #{trxLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select thd_id, conn_id, user, db, command, state, time, progress, rows_examined, 
    rows_sent, rows_affected, tmp_tables, tmp_disk_tables, full_scan, last_wait, source, 
    trx_state, trx_autocommit, pid, program_name, current_statement, statement_latency, 
    lock_latency, last_statement, last_statement_latency, current_memory, last_wait_latency, 
    trx_latency
    from session
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="COUNT_READ_WRITE" jdbcType="BIGINT" property="countReadWrite" />
    <result column="SUM_TIMER_READ_WRITE" jdbcType="BIGINT" property="sumTimerReadWrite" />
    <result column="MIN_TIMER_READ_WRITE" jdbcType="BIGINT" property="minTimerReadWrite" />
    <result column="AVG_TIMER_READ_WRITE" jdbcType="BIGINT" property="avgTimerReadWrite" />
    <result column="MAX_TIMER_READ_WRITE" jdbcType="BIGINT" property="maxTimerReadWrite" />
    <result column="COUNT_READ_ONLY" jdbcType="BIGINT" property="countReadOnly" />
    <result column="SUM_TIMER_READ_ONLY" jdbcType="BIGINT" property="sumTimerReadOnly" />
    <result column="MIN_TIMER_READ_ONLY" jdbcType="BIGINT" property="minTimerReadOnly" />
    <result column="AVG_TIMER_READ_ONLY" jdbcType="BIGINT" property="avgTimerReadOnly" />
    <result column="MAX_TIMER_READ_ONLY" jdbcType="BIGINT" property="maxTimerReadOnly" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_transactions_summary_by_host_by_event_name (HOST, EVENT_NAME, COUNT_STAR, 
      SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
      MAX_TIMER_WAIT, COUNT_READ_WRITE, SUM_TIMER_READ_WRITE, 
      MIN_TIMER_READ_WRITE, AVG_TIMER_READ_WRITE, MAX_TIMER_READ_WRITE, 
      COUNT_READ_ONLY, SUM_TIMER_READ_ONLY, MIN_TIMER_READ_ONLY, 
      AVG_TIMER_READ_ONLY, MAX_TIMER_READ_ONLY)
    values (#{host,jdbcType=CHAR}, #{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, 
      #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, 
      #{maxTimerWait,jdbcType=BIGINT}, #{countReadWrite,jdbcType=BIGINT}, #{sumTimerReadWrite,jdbcType=BIGINT}, 
      #{minTimerReadWrite,jdbcType=BIGINT}, #{avgTimerReadWrite,jdbcType=BIGINT}, #{maxTimerReadWrite,jdbcType=BIGINT}, 
      #{countReadOnly,jdbcType=BIGINT}, #{sumTimerReadOnly,jdbcType=BIGINT}, #{minTimerReadOnly,jdbcType=BIGINT}, 
      #{avgTimerReadOnly,jdbcType=BIGINT}, #{maxTimerReadOnly,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select HOST, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT, COUNT_READ_WRITE, SUM_TIMER_READ_WRITE, MIN_TIMER_READ_WRITE, AVG_TIMER_READ_WRITE, 
    MAX_TIMER_READ_WRITE, COUNT_READ_ONLY, SUM_TIMER_READ_ONLY, MIN_TIMER_READ_ONLY, 
    AVG_TIMER_READ_ONLY, MAX_TIMER_READ_ONLY
    from events_transactions_summary_by_host_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="object_schema" jdbcType="VARCHAR" property="objectSchema" />
    <result column="object_name" jdbcType="VARCHAR" property="objectName" />
    <result column="waiting_thread_id" jdbcType="BIGINT" property="waitingThreadId" />
    <result column="waiting_pid" jdbcType="BIGINT" property="waitingPid" />
    <result column="waiting_lock_type" jdbcType="VARCHAR" property="waitingLockType" />
    <result column="waiting_lock_duration" jdbcType="VARCHAR" property="waitingLockDuration" />
    <result column="waiting_query_secs" jdbcType="BIGINT" property="waitingQuerySecs" />
    <result column="waiting_query_rows_affected" jdbcType="BIGINT" property="waitingQueryRowsAffected" />
    <result column="waiting_query_rows_examined" jdbcType="BIGINT" property="waitingQueryRowsExamined" />
    <result column="blocking_thread_id" jdbcType="BIGINT" property="blockingThreadId" />
    <result column="blocking_pid" jdbcType="BIGINT" property="blockingPid" />
    <result column="blocking_lock_type" jdbcType="VARCHAR" property="blockingLockType" />
    <result column="blocking_lock_duration" jdbcType="VARCHAR" property="blockingLockDuration" />
    <result column="sql_kill_blocking_query" jdbcType="VARCHAR" property="sqlKillBlockingQuery" />
    <result column="sql_kill_blocking_connection" jdbcType="VARCHAR" property="sqlKillBlockingConnection" />
    <result column="waiting_account" jdbcType="LONGVARCHAR" property="waitingAccount" />
    <result column="waiting_query" jdbcType="LONGVARCHAR" property="waitingQuery" />
    <result column="blocking_account" jdbcType="LONGVARCHAR" property="blockingAccount" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into schema_table_lock_waits (object_schema, object_name, waiting_thread_id, 
      waiting_pid, waiting_lock_type, waiting_lock_duration, 
      waiting_query_secs, waiting_query_rows_affected, 
      waiting_query_rows_examined, blocking_thread_id, 
      blocking_pid, blocking_lock_type, blocking_lock_duration, 
      sql_kill_blocking_query, sql_kill_blocking_connection, 
      waiting_account, waiting_query, blocking_account
      )
    values (#{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, #{waitingThreadId,jdbcType=BIGINT}, 
      #{waitingPid,jdbcType=BIGINT}, #{waitingLockType,jdbcType=VARCHAR}, #{waitingLockDuration,jdbcType=VARCHAR}, 
      #{waitingQuerySecs,jdbcType=BIGINT}, #{waitingQueryRowsAffected,jdbcType=BIGINT}, 
      #{waitingQueryRowsExamined,jdbcType=BIGINT}, #{blockingThreadId,jdbcType=BIGINT}, 
      #{blockingPid,jdbcType=BIGINT}, #{blockingLockType,jdbcType=VARCHAR}, #{blockingLockDuration,jdbcType=VARCHAR}, 
      #{sqlKillBlockingQuery,jdbcType=VARCHAR}, #{sqlKillBlockingConnection,jdbcType=VARCHAR}, 
      #{waitingAccount,jdbcType=LONGVARCHAR}, #{waitingQuery,jdbcType=LONGVARCHAR}, #{blockingAccount,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select object_schema, object_name, waiting_thread_id, waiting_pid, waiting_lock_type, 
    waiting_lock_duration, waiting_query_secs, waiting_query_rows_affected, waiting_query_rows_examined, 
    blocking_thread_id, blocking_pid, blocking_lock_type, blocking_lock_duration, sql_kill_blocking_query, 
    sql_kill_blocking_connection, waiting_account, waiting_query, blocking_account
    from schema_table_lock_waits
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="help_topic_id" jdbcType="INTEGER" property="helpTopicId" />
    <result column="name" jdbcType="CHAR" property="name" />
    <result column="help_category_id" jdbcType="SMALLINT" property="helpCategoryId" />
    <result column="description" jdbcType="LONGVARCHAR" property="description" />
    <result column="example" jdbcType="LONGVARCHAR" property="example" />
    <result column="url" jdbcType="LONGVARCHAR" property="url" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from help_topic
    where help_topic_id = #{helpTopicId,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into help_topic (help_topic_id, name, help_category_id, 
      description, example, url
      )
    values (#{helpTopicId,jdbcType=INTEGER}, #{name,jdbcType=CHAR}, #{helpCategoryId,jdbcType=SMALLINT}, 
      #{description,jdbcType=LONGVARCHAR}, #{example,jdbcType=LONGVARCHAR}, #{url,jdbcType=LONGVARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update help_topic
    set name = #{name,jdbcType=CHAR},
      help_category_id = #{helpCategoryId,jdbcType=SMALLINT},
      description = #{description,jdbcType=LONGVARCHAR},
      example = #{example,jdbcType=LONGVARCHAR},
      url = #{url,jdbcType=LONGVARCHAR}
    where help_topic_id = #{helpTopicId,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select help_topic_id, name, help_category_id, description, example, url
    from help_topic
    where help_topic_id = #{helpTopicId,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select help_topic_id, name, help_category_id, description, example, url
    from help_topic
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="D_id" jdbcType="INTEGER" property="dId" />
    <result column="D_name" jdbcType="VARCHAR" property="dName" />
    <result column="D_Manager" jdbcType="VARCHAR" property="dManager" />
    <result column="D_Remars" jdbcType="VARCHAR" property="dRemars" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from oasys_dept
    where D_id = #{dId,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into oasys_dept (D_id, D_name, D_Manager, 
      D_Remars)
    values (#{dId,jdbcType=INTEGER}, #{dName,jdbcType=VARCHAR}, #{dManager,jdbcType=VARCHAR}, 
      #{dRemars,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update oasys_dept
    set D_name = #{dName,jdbcType=VARCHAR},
      D_Manager = #{dManager,jdbcType=VARCHAR},
      D_Remars = #{dRemars,jdbcType=VARCHAR}
    where D_id = #{dId,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select D_id, D_name, D_Manager, D_Remars
    from oasys_dept
    where D_id = #{dId,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select D_id, D_name, D_Manager, D_Remars
    from oasys_dept
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="bid" jdbcType="BIGINT" property="bid" />
    <result column="title" jdbcType="VARCHAR" property="title" />
    <result column="mark" jdbcType="VARCHAR" property="mark" />
    <result column="image" jdbcType="VARCHAR" property="image" />
    <result column="creates" jdbcType="TIMESTAMP" property="creates" />
    <result column="uid" jdbcType="BIGINT" property="uid" />
    <result column="gid" jdbcType="BIGINT" property="gid" />
    <result column="lid" jdbcType="BIGINT" property="lid" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from problogtitle
    where bid = #{bid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into problogtitle (bid, title, mark, 
      image, creates, uid, 
      gid, lid)
    values (#{bid,jdbcType=BIGINT}, #{title,jdbcType=VARCHAR}, #{mark,jdbcType=VARCHAR}, 
      #{image,jdbcType=VARCHAR}, #{creates,jdbcType=TIMESTAMP}, #{uid,jdbcType=BIGINT}, 
      #{gid,jdbcType=BIGINT}, #{lid,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update problogtitle
    set title = #{title,jdbcType=VARCHAR},
      mark = #{mark,jdbcType=VARCHAR},
      image = #{image,jdbcType=VARCHAR},
      creates = #{creates,jdbcType=TIMESTAMP},
      uid = #{uid,jdbcType=BIGINT},
      gid = #{gid,jdbcType=BIGINT},
      lid = #{lid,jdbcType=BIGINT}
    where bid = #{bid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select bid, title, mark, image, creates, uid, gid, lid
    from problogtitle
    where bid = #{bid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select bid, title, mark, image, creates, uid, gid, lid
    from problogtitle
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="event_name" jdbcType="VARCHAR" property="eventName" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="avg_latency" jdbcType="LONGVARCHAR" property="avgLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into user_summary_by_stages (user, event_name, total, 
      total_latency, avg_latency)
    values (#{user,jdbcType=VARCHAR}, #{eventName,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{totalLatency,jdbcType=LONGVARCHAR}, #{avgLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, event_name, total, total_latency, avg_latency
    from user_summary_by_stages
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="FILTER_NAME" jdbcType="CHAR" property="filterName" />
    <result column="CONFIGURED_BY" jdbcType="CHAR" property="configuredBy" />
    <result column="ACTIVE_SINCE" jdbcType="TIMESTAMP" property="activeSince" />
    <result column="FILTER_RULE" jdbcType="LONGVARCHAR" property="filterRule" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into replication_applier_global_filters (FILTER_NAME, CONFIGURED_BY, ACTIVE_SINCE, 
      FILTER_RULE)
    values (#{filterName,jdbcType=CHAR}, #{configuredBy,jdbcType=CHAR}, #{activeSince,jdbcType=TIMESTAMP}, 
      #{filterRule,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select FILTER_NAME, CONFIGURED_BY, ACTIVE_SINCE, FILTER_RULE
    from replication_applier_global_filters
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="fid" jdbcType="INTEGER" property="fid" />
    <result column="sid" jdbcType="INTEGER" property="sid" />
    <result column="fname" jdbcType="VARCHAR" property="fname" />
    <result column="fauto" jdbcType="VARCHAR" property="fauto" />
    <result column="ontime" jdbcType="VARCHAR" property="ontime" />
    <result column="fremark" jdbcType="VARCHAR" property="fremark" />
    <result column="fflag" jdbcType="INTEGER" property="fflag" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from fiml
    where fid = #{fid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into fiml (fid, sid, fname, 
      fauto, ontime, fremark, 
      fflag)
    values (#{fid,jdbcType=INTEGER}, #{sid,jdbcType=INTEGER}, #{fname,jdbcType=VARCHAR}, 
      #{fauto,jdbcType=VARCHAR}, #{ontime,jdbcType=VARCHAR}, #{fremark,jdbcType=VARCHAR}, 
      #{fflag,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update fiml
    set sid = #{sid,jdbcType=INTEGER},
      fname = #{fname,jdbcType=VARCHAR},
      fauto = #{fauto,jdbcType=VARCHAR},
      ontime = #{ontime,jdbcType=VARCHAR},
      fremark = #{fremark,jdbcType=VARCHAR},
      fflag = #{fflag,jdbcType=INTEGER}
    where fid = #{fid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select fid, sid, fname, fauto, ontime, fremark, fflag
    from fiml
    where fid = #{fid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select fid, sid, fname, fauto, ontime, fremark, fflag
    from fiml
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="E_id" jdbcType="INTEGER" property="eId" />
    <result column="E_name" jdbcType="VARCHAR" property="eName" />
    <result column="E_Sex" jdbcType="VARCHAR" property="eSex" />
    <result column="E_Dept" jdbcType="INTEGER" property="eDept" />
    <result column="E_Position" jdbcType="VARCHAR" property="ePosition" />
    <result column="E_Email" jdbcType="VARCHAR" property="eEmail" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from oasys_employee
    where E_id = #{eId,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into oasys_employee (E_id, E_name, E_Sex, 
      E_Dept, E_Position, E_Email
      )
    values (#{eId,jdbcType=INTEGER}, #{eName,jdbcType=VARCHAR}, #{eSex,jdbcType=VARCHAR}, 
      #{eDept,jdbcType=INTEGER}, #{ePosition,jdbcType=VARCHAR}, #{eEmail,jdbcType=VARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update oasys_employee
    set E_name = #{eName,jdbcType=VARCHAR},
      E_Sex = #{eSex,jdbcType=VARCHAR},
      E_Dept = #{eDept,jdbcType=INTEGER},
      E_Position = #{ePosition,jdbcType=VARCHAR},
      E_Email = #{eEmail,jdbcType=VARCHAR}
    where E_id = #{eId,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select E_id, E_name, E_Sex, E_Dept, E_Position, E_Email
    from oasys_employee
    where E_id = #{eId,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select E_id, E_name, E_Sex, E_Dept, E_Position, E_Email
    from oasys_employee
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="table_schema" jdbcType="VARCHAR" property="tableSchema" />
    <result column="table_name" jdbcType="VARCHAR" property="tableName" />
    <result column="redundant_index_name" jdbcType="VARCHAR" property="redundantIndexName" />
    <result column="redundant_index_non_unique" jdbcType="INTEGER" property="redundantIndexNonUnique" />
    <result column="dominant_index_name" jdbcType="VARCHAR" property="dominantIndexName" />
    <result column="dominant_index_non_unique" jdbcType="INTEGER" property="dominantIndexNonUnique" />
    <result column="subpart_exists" jdbcType="INTEGER" property="subpartExists" />
    <result column="sql_drop_index" jdbcType="VARCHAR" property="sqlDropIndex" />
    <result column="redundant_index_columns" jdbcType="LONGVARCHAR" property="redundantIndexColumns" />
    <result column="dominant_index_columns" jdbcType="LONGVARCHAR" property="dominantIndexColumns" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into schema_redundant_indexes (table_schema, table_name, redundant_index_name, 
      redundant_index_non_unique, dominant_index_name, 
      dominant_index_non_unique, subpart_exists, 
      sql_drop_index, redundant_index_columns, 
      dominant_index_columns)
    values (#{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, #{redundantIndexName,jdbcType=VARCHAR}, 
      #{redundantIndexNonUnique,jdbcType=INTEGER}, #{dominantIndexName,jdbcType=VARCHAR}, 
      #{dominantIndexNonUnique,jdbcType=INTEGER}, #{subpartExists,jdbcType=INTEGER}, 
      #{sqlDropIndex,jdbcType=VARCHAR}, #{redundantIndexColumns,jdbcType=LONGVARCHAR}, 
      #{dominantIndexColumns,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select table_schema, table_name, redundant_index_name, redundant_index_non_unique, 
    dominant_index_name, dominant_index_non_unique, subpart_exists, sql_drop_index, redundant_index_columns, 
    dominant_index_columns
    from schema_redundant_indexes
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="DOC_ID" jdbcType="BIGINT" property="docId" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_FT_BEING_DELETED (DOC_ID)
    values (#{docId,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select DOC_ID
    from INNODB_FT_BEING_DELETED
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="event_name" jdbcType="VARCHAR" property="eventName" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="count_read" jdbcType="BIGINT" property="countRead" />
    <result column="count_write" jdbcType="BIGINT" property="countWrite" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="avg_latency" jdbcType="LONGVARCHAR" property="avgLatency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
    <result column="read_latency" jdbcType="LONGVARCHAR" property="readLatency" />
    <result column="write_latency" jdbcType="LONGVARCHAR" property="writeLatency" />
    <result column="misc_latency" jdbcType="LONGVARCHAR" property="miscLatency" />
    <result column="total_read" jdbcType="LONGVARCHAR" property="totalRead" />
    <result column="avg_read" jdbcType="LONGVARCHAR" property="avgRead" />
    <result column="total_written" jdbcType="LONGVARCHAR" property="totalWritten" />
    <result column="avg_written" jdbcType="LONGVARCHAR" property="avgWritten" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into io_global_by_wait_by_latency (event_name, total, count_read, 
      count_write, total_latency, avg_latency, 
      max_latency, read_latency, write_latency, 
      misc_latency, total_read, avg_read, 
      total_written, avg_written)
    values (#{eventName,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, #{countRead,jdbcType=BIGINT}, 
      #{countWrite,jdbcType=BIGINT}, #{totalLatency,jdbcType=LONGVARCHAR}, #{avgLatency,jdbcType=LONGVARCHAR}, 
      #{maxLatency,jdbcType=LONGVARCHAR}, #{readLatency,jdbcType=LONGVARCHAR}, #{writeLatency,jdbcType=LONGVARCHAR}, 
      #{miscLatency,jdbcType=LONGVARCHAR}, #{totalRead,jdbcType=LONGVARCHAR}, #{avgRead,jdbcType=LONGVARCHAR}, 
      #{totalWritten,jdbcType=LONGVARCHAR}, #{avgWritten,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select event_name, total, count_read, count_write, total_latency, avg_latency, max_latency, 
    read_latency, write_latency, misc_latency, total_read, avg_read, total_written, avg_written
    from io_global_by_wait_by_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_waits_summary_by_account_by_event_name (USER, HOST, EVENT_NAME, 
      COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, 
      AVG_TIMER_WAIT, MAX_TIMER_WAIT)
    values (#{user,jdbcType=CHAR}, #{host,jdbcType=CHAR}, #{eventName,jdbcType=VARCHAR}, 
      #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, 
      #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, HOST, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT
    from events_waits_summary_by_account_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="event_name" jdbcType="VARCHAR" property="eventName" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="avg_latency" jdbcType="BIGINT" property="avgLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$user_summary_by_stages (user, event_name, total, 
      total_latency, avg_latency)
    values (#{user,jdbcType=VARCHAR}, #{eventName,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{totalLatency,jdbcType=BIGINT}, #{avgLatency,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, event_name, total, total_latency, avg_latency
    from x$user_summary_by_stages
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="TABLE_CATALOG" jdbcType="VARCHAR" property="tableCatalog" />
    <result column="TABLE_SCHEMA" jdbcType="VARCHAR" property="tableSchema" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
    <result column="COLUMN_NAME" jdbcType="VARCHAR" property="columnName" />
    <result column="ORDINAL_POSITION" jdbcType="INTEGER" property="ordinalPosition" />
    <result column="IS_NULLABLE" jdbcType="VARCHAR" property="isNullable" />
    <result column="CHARACTER_MAXIMUM_LENGTH" jdbcType="BIGINT" property="characterMaximumLength" />
    <result column="CHARACTER_OCTET_LENGTH" jdbcType="BIGINT" property="characterOctetLength" />
    <result column="NUMERIC_PRECISION" jdbcType="BIGINT" property="numericPrecision" />
    <result column="NUMERIC_SCALE" jdbcType="BIGINT" property="numericScale" />
    <result column="DATETIME_PRECISION" jdbcType="INTEGER" property="datetimePrecision" />
    <result column="CHARACTER_SET_NAME" jdbcType="VARCHAR" property="characterSetName" />
    <result column="COLLATION_NAME" jdbcType="VARCHAR" property="collationName" />
    <result column="COLUMN_KEY" jdbcType="CHAR" property="columnKey" />
    <result column="EXTRA" jdbcType="VARCHAR" property="extra" />
    <result column="PRIVILEGES" jdbcType="VARCHAR" property="privileges" />
    <result column="SRS_ID" jdbcType="INTEGER" property="srsId" />
    <result column="COLUMN_DEFAULT" jdbcType="LONGVARCHAR" property="columnDefault" />
    <result column="DATA_TYPE" jdbcType="LONGVARCHAR" property="dataType" />
    <result column="COLUMN_TYPE" jdbcType="LONGVARCHAR" property="columnType" />
    <result column="COLUMN_COMMENT" jdbcType="LONGVARCHAR" property="columnComment" />
    <result column="GENERATION_EXPRESSION" jdbcType="LONGVARCHAR" property="generationExpression" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into COLUMNS (TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, 
      COLUMN_NAME, ORDINAL_POSITION, IS_NULLABLE, 
      CHARACTER_MAXIMUM_LENGTH, CHARACTER_OCTET_LENGTH, 
      NUMERIC_PRECISION, NUMERIC_SCALE, DATETIME_PRECISION, 
      CHARACTER_SET_NAME, COLLATION_NAME, COLUMN_KEY, 
      EXTRA, PRIVILEGES, SRS_ID, 
      COLUMN_DEFAULT, DATA_TYPE, COLUMN_TYPE, 
      COLUMN_COMMENT, GENERATION_EXPRESSION
      )
    values (#{tableCatalog,jdbcType=VARCHAR}, #{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, 
      #{columnName,jdbcType=VARCHAR}, #{ordinalPosition,jdbcType=INTEGER}, #{isNullable,jdbcType=VARCHAR}, 
      #{characterMaximumLength,jdbcType=BIGINT}, #{characterOctetLength,jdbcType=BIGINT}, 
      #{numericPrecision,jdbcType=BIGINT}, #{numericScale,jdbcType=BIGINT}, #{datetimePrecision,jdbcType=INTEGER}, 
      #{characterSetName,jdbcType=VARCHAR}, #{collationName,jdbcType=VARCHAR}, #{columnKey,jdbcType=CHAR}, 
      #{extra,jdbcType=VARCHAR}, #{privileges,jdbcType=VARCHAR}, #{srsId,jdbcType=INTEGER}, 
      #{columnDefault,jdbcType=LONGVARCHAR}, #{dataType,jdbcType=LONGVARCHAR}, #{columnType,jdbcType=LONGVARCHAR}, 
      #{columnComment,jdbcType=LONGVARCHAR}, #{generationExpression,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, ORDINAL_POSITION, IS_NULLABLE, 
    CHARACTER_MAXIMUM_LENGTH, CHARACTER_OCTET_LENGTH, NUMERIC_PRECISION, NUMERIC_SCALE, 
    DATETIME_PRECISION, CHARACTER_SET_NAME, COLLATION_NAME, COLUMN_KEY, EXTRA, PRIVILEGES, 
    SRS_ID, COLUMN_DEFAULT, DATA_TYPE, COLUMN_TYPE, COLUMN_COMMENT, GENERATION_EXPRESSION
    from COLUMNS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="SUM_LOCK_TIME" jdbcType="BIGINT" property="sumLockTime" />
    <result column="SUM_ERRORS" jdbcType="BIGINT" property="sumErrors" />
    <result column="SUM_WARNINGS" jdbcType="BIGINT" property="sumWarnings" />
    <result column="SUM_ROWS_AFFECTED" jdbcType="BIGINT" property="sumRowsAffected" />
    <result column="SUM_ROWS_SENT" jdbcType="BIGINT" property="sumRowsSent" />
    <result column="SUM_ROWS_EXAMINED" jdbcType="BIGINT" property="sumRowsExamined" />
    <result column="SUM_CREATED_TMP_DISK_TABLES" jdbcType="BIGINT" property="sumCreatedTmpDiskTables" />
    <result column="SUM_CREATED_TMP_TABLES" jdbcType="BIGINT" property="sumCreatedTmpTables" />
    <result column="SUM_SELECT_FULL_JOIN" jdbcType="BIGINT" property="sumSelectFullJoin" />
    <result column="SUM_SELECT_FULL_RANGE_JOIN" jdbcType="BIGINT" property="sumSelectFullRangeJoin" />
    <result column="SUM_SELECT_RANGE" jdbcType="BIGINT" property="sumSelectRange" />
    <result column="SUM_SELECT_RANGE_CHECK" jdbcType="BIGINT" property="sumSelectRangeCheck" />
    <result column="SUM_SELECT_SCAN" jdbcType="BIGINT" property="sumSelectScan" />
    <result column="SUM_SORT_MERGE_PASSES" jdbcType="BIGINT" property="sumSortMergePasses" />
    <result column="SUM_SORT_RANGE" jdbcType="BIGINT" property="sumSortRange" />
    <result column="SUM_SORT_ROWS" jdbcType="BIGINT" property="sumSortRows" />
    <result column="SUM_SORT_SCAN" jdbcType="BIGINT" property="sumSortScan" />
    <result column="SUM_NO_INDEX_USED" jdbcType="BIGINT" property="sumNoIndexUsed" />
    <result column="SUM_NO_GOOD_INDEX_USED" jdbcType="BIGINT" property="sumNoGoodIndexUsed" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_statements_summary_by_user_by_event_name (USER, EVENT_NAME, COUNT_STAR, 
      SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
      MAX_TIMER_WAIT, SUM_LOCK_TIME, SUM_ERRORS, 
      SUM_WARNINGS, SUM_ROWS_AFFECTED, SUM_ROWS_SENT, 
      SUM_ROWS_EXAMINED, SUM_CREATED_TMP_DISK_TABLES, 
      SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, SUM_SELECT_FULL_RANGE_JOIN, 
      SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, 
      SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, 
      SUM_SORT_SCAN, SUM_NO_INDEX_USED, SUM_NO_GOOD_INDEX_USED
      )
    values (#{user,jdbcType=CHAR}, #{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, 
      #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, 
      #{maxTimerWait,jdbcType=BIGINT}, #{sumLockTime,jdbcType=BIGINT}, #{sumErrors,jdbcType=BIGINT}, 
      #{sumWarnings,jdbcType=BIGINT}, #{sumRowsAffected,jdbcType=BIGINT}, #{sumRowsSent,jdbcType=BIGINT}, 
      #{sumRowsExamined,jdbcType=BIGINT}, #{sumCreatedTmpDiskTables,jdbcType=BIGINT}, 
      #{sumCreatedTmpTables,jdbcType=BIGINT}, #{sumSelectFullJoin,jdbcType=BIGINT}, #{sumSelectFullRangeJoin,jdbcType=BIGINT}, 
      #{sumSelectRange,jdbcType=BIGINT}, #{sumSelectRangeCheck,jdbcType=BIGINT}, #{sumSelectScan,jdbcType=BIGINT}, 
      #{sumSortMergePasses,jdbcType=BIGINT}, #{sumSortRange,jdbcType=BIGINT}, #{sumSortRows,jdbcType=BIGINT}, 
      #{sumSortScan,jdbcType=BIGINT}, #{sumNoIndexUsed,jdbcType=BIGINT}, #{sumNoGoodIndexUsed,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT, SUM_LOCK_TIME, SUM_ERRORS, SUM_WARNINGS, SUM_ROWS_AFFECTED, SUM_ROWS_SENT, 
    SUM_ROWS_EXAMINED, SUM_CREATED_TMP_DISK_TABLES, SUM_CREATED_TMP_TABLES, SUM_SELECT_FULL_JOIN, 
    SUM_SELECT_FULL_RANGE_JOIN, SUM_SELECT_RANGE, SUM_SELECT_RANGE_CHECK, SUM_SELECT_SCAN, 
    SUM_SORT_MERGE_PASSES, SUM_SORT_RANGE, SUM_SORT_ROWS, SUM_SORT_SCAN, SUM_NO_INDEX_USED, 
    SUM_NO_GOOD_INDEX_USED
    from events_statements_summary_by_user_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="ERROR_NUMBER" jdbcType="INTEGER" property="errorNumber" />
    <result column="ERROR_NAME" jdbcType="VARCHAR" property="errorName" />
    <result column="SQL_STATE" jdbcType="VARCHAR" property="sqlState" />
    <result column="SUM_ERROR_RAISED" jdbcType="BIGINT" property="sumErrorRaised" />
    <result column="SUM_ERROR_HANDLED" jdbcType="BIGINT" property="sumErrorHandled" />
    <result column="FIRST_SEEN" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="LAST_SEEN" jdbcType="TIMESTAMP" property="lastSeen" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_errors_summary_global_by_error (ERROR_NUMBER, ERROR_NAME, SQL_STATE, 
      SUM_ERROR_RAISED, SUM_ERROR_HANDLED, FIRST_SEEN, 
      LAST_SEEN)
    values (#{errorNumber,jdbcType=INTEGER}, #{errorName,jdbcType=VARCHAR}, #{sqlState,jdbcType=VARCHAR}, 
      #{sumErrorRaised,jdbcType=BIGINT}, #{sumErrorHandled,jdbcType=BIGINT}, #{firstSeen,jdbcType=TIMESTAMP}, 
      #{lastSeen,jdbcType=TIMESTAMP})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select ERROR_NUMBER, ERROR_NAME, SQL_STATE, SUM_ERROR_RAISED, SUM_ERROR_HANDLED, 
    FIRST_SEEN, LAST_SEEN
    from events_errors_summary_global_by_error
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_stages_summary_by_host_by_event_name (HOST, EVENT_NAME, COUNT_STAR, 
      SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
      MAX_TIMER_WAIT)
    values (#{host,jdbcType=CHAR}, #{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, 
      #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, 
      #{maxTimerWait,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select HOST, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT
    from events_stages_summary_by_host_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="total_allocated" jdbcType="DECIMAL" property="totalAllocated" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$memory_global_total (total_allocated)
    values (#{totalAllocated,jdbcType=DECIMAL})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select total_allocated
    from x$memory_global_total
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="table_schema" jdbcType="VARCHAR" property="tableSchema" />
    <result column="table_name" jdbcType="VARCHAR" property="tableName" />
    <result column="rows_fetched" jdbcType="BIGINT" property="rowsFetched" />
    <result column="rows_inserted" jdbcType="BIGINT" property="rowsInserted" />
    <result column="rows_updated" jdbcType="BIGINT" property="rowsUpdated" />
    <result column="rows_deleted" jdbcType="BIGINT" property="rowsDeleted" />
    <result column="io_read_requests" jdbcType="DECIMAL" property="ioReadRequests" />
    <result column="io_write_requests" jdbcType="DECIMAL" property="ioWriteRequests" />
    <result column="io_misc_requests" jdbcType="DECIMAL" property="ioMiscRequests" />
    <result column="innodb_buffer_pages" jdbcType="BIGINT" property="innodbBufferPages" />
    <result column="innodb_buffer_pages_hashed" jdbcType="BIGINT" property="innodbBufferPagesHashed" />
    <result column="innodb_buffer_pages_old" jdbcType="BIGINT" property="innodbBufferPagesOld" />
    <result column="innodb_buffer_rows_cached" jdbcType="DECIMAL" property="innodbBufferRowsCached" />
    <result column="fetch_latency" jdbcType="LONGVARCHAR" property="fetchLatency" />
    <result column="insert_latency" jdbcType="LONGVARCHAR" property="insertLatency" />
    <result column="update_latency" jdbcType="LONGVARCHAR" property="updateLatency" />
    <result column="delete_latency" jdbcType="LONGVARCHAR" property="deleteLatency" />
    <result column="io_read" jdbcType="LONGVARCHAR" property="ioRead" />
    <result column="io_read_latency" jdbcType="LONGVARCHAR" property="ioReadLatency" />
    <result column="io_write" jdbcType="LONGVARCHAR" property="ioWrite" />
    <result column="io_write_latency" jdbcType="LONGVARCHAR" property="ioWriteLatency" />
    <result column="io_misc_latency" jdbcType="LONGVARCHAR" property="ioMiscLatency" />
    <result column="innodb_buffer_allocated" jdbcType="LONGVARCHAR" property="innodbBufferAllocated" />
    <result column="innodb_buffer_data" jdbcType="LONGVARCHAR" property="innodbBufferData" />
    <result column="innodb_buffer_free" jdbcType="LONGVARCHAR" property="innodbBufferFree" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into schema_table_statistics_with_buffer (table_schema, table_name, rows_fetched, 
      rows_inserted, rows_updated, rows_deleted, 
      io_read_requests, io_write_requests, io_misc_requests, 
      innodb_buffer_pages, innodb_buffer_pages_hashed, 
      innodb_buffer_pages_old, innodb_buffer_rows_cached, 
      fetch_latency, insert_latency, update_latency, 
      delete_latency, io_read, io_read_latency, 
      io_write, io_write_latency, io_misc_latency, 
      innodb_buffer_allocated, innodb_buffer_data, 
      innodb_buffer_free)
    values (#{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, #{rowsFetched,jdbcType=BIGINT}, 
      #{rowsInserted,jdbcType=BIGINT}, #{rowsUpdated,jdbcType=BIGINT}, #{rowsDeleted,jdbcType=BIGINT}, 
      #{ioReadRequests,jdbcType=DECIMAL}, #{ioWriteRequests,jdbcType=DECIMAL}, #{ioMiscRequests,jdbcType=DECIMAL}, 
      #{innodbBufferPages,jdbcType=BIGINT}, #{innodbBufferPagesHashed,jdbcType=BIGINT}, 
      #{innodbBufferPagesOld,jdbcType=BIGINT}, #{innodbBufferRowsCached,jdbcType=DECIMAL}, 
      #{fetchLatency,jdbcType=LONGVARCHAR}, #{insertLatency,jdbcType=LONGVARCHAR}, #{updateLatency,jdbcType=LONGVARCHAR}, 
      #{deleteLatency,jdbcType=LONGVARCHAR}, #{ioRead,jdbcType=LONGVARCHAR}, #{ioReadLatency,jdbcType=LONGVARCHAR}, 
      #{ioWrite,jdbcType=LONGVARCHAR}, #{ioWriteLatency,jdbcType=LONGVARCHAR}, #{ioMiscLatency,jdbcType=LONGVARCHAR}, 
      #{innodbBufferAllocated,jdbcType=LONGVARCHAR}, #{innodbBufferData,jdbcType=LONGVARCHAR}, 
      #{innodbBufferFree,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select table_schema, table_name, rows_fetched, rows_inserted, rows_updated, rows_deleted, 
    io_read_requests, io_write_requests, io_misc_requests, innodb_buffer_pages, innodb_buffer_pages_hashed, 
    innodb_buffer_pages_old, innodb_buffer_rows_cached, fetch_latency, insert_latency, 
    update_latency, delete_latency, io_read, io_read_latency, io_write, io_write_latency, 
    io_misc_latency, innodb_buffer_allocated, innodb_buffer_data, innodb_buffer_free
    from schema_table_statistics_with_buffer
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="jid" jdbcType="BIGINT" property="jid" />
    <result column="sub" jdbcType="VARCHAR" property="sub" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from subjects
    where jid = #{jid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into subjects (jid, sub)
    values (#{jid,jdbcType=BIGINT}, #{sub,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update subjects
    set sub = #{sub,jdbcType=VARCHAR}
    where jid = #{jid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select jid, sub
    from subjects
    where jid = #{jid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select jid, sub
    from subjects
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="WORD" jdbcType="VARCHAR" property="word" />
    <result column="FIRST_DOC_ID" jdbcType="BIGINT" property="firstDocId" />
    <result column="LAST_DOC_ID" jdbcType="BIGINT" property="lastDocId" />
    <result column="DOC_COUNT" jdbcType="BIGINT" property="docCount" />
    <result column="DOC_ID" jdbcType="BIGINT" property="docId" />
    <result column="POSITION" jdbcType="BIGINT" property="position" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_FT_INDEX_CACHE (WORD, FIRST_DOC_ID, LAST_DOC_ID, 
      DOC_COUNT, DOC_ID, POSITION
      )
    values (#{word,jdbcType=VARCHAR}, #{firstDocId,jdbcType=BIGINT}, #{lastDocId,jdbcType=BIGINT}, 
      #{docCount,jdbcType=BIGINT}, #{docId,jdbcType=BIGINT}, #{position,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select WORD, FIRST_DOC_ID, LAST_DOC_ID, DOC_COUNT, DOC_ID, POSITION
    from INNODB_FT_INDEX_CACHE
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="exec_count" jdbcType="BIGINT" property="execCount" />
    <result column="total_latency" jdbcType="BIGINT" property="totalLatency" />
    <result column="sort_merge_passes" jdbcType="BIGINT" property="sortMergePasses" />
    <result column="avg_sort_merges" jdbcType="DECIMAL" property="avgSortMerges" />
    <result column="sorts_using_scans" jdbcType="BIGINT" property="sortsUsingScans" />
    <result column="sort_using_range" jdbcType="BIGINT" property="sortUsingRange" />
    <result column="rows_sorted" jdbcType="BIGINT" property="rowsSorted" />
    <result column="avg_rows_sorted" jdbcType="DECIMAL" property="avgRowsSorted" />
    <result column="first_seen" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="last_seen" jdbcType="TIMESTAMP" property="lastSeen" />
    <result column="digest" jdbcType="VARCHAR" property="digest" />
    <result column="query" jdbcType="LONGVARCHAR" property="query" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$statements_with_sorting (db, exec_count, total_latency, 
      sort_merge_passes, avg_sort_merges, sorts_using_scans, 
      sort_using_range, rows_sorted, avg_rows_sorted, 
      first_seen, last_seen, digest, 
      query)
    values (#{db,jdbcType=VARCHAR}, #{execCount,jdbcType=BIGINT}, #{totalLatency,jdbcType=BIGINT}, 
      #{sortMergePasses,jdbcType=BIGINT}, #{avgSortMerges,jdbcType=DECIMAL}, #{sortsUsingScans,jdbcType=BIGINT}, 
      #{sortUsingRange,jdbcType=BIGINT}, #{rowsSorted,jdbcType=BIGINT}, #{avgRowsSorted,jdbcType=DECIMAL}, 
      #{firstSeen,jdbcType=TIMESTAMP}, #{lastSeen,jdbcType=TIMESTAMP}, #{digest,jdbcType=VARCHAR}, 
      #{query,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select db, exec_count, total_latency, sort_merge_passes, avg_sort_merges, sorts_using_scans, 
    sort_using_range, rows_sorted, avg_rows_sorted, first_seen, last_seen, digest, query
    from x$statements_with_sorting
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="NAME" jdbcType="VARCHAR" property="name" />
    <result column="LOCKED_BY_THREAD_ID" jdbcType="BIGINT" property="lockedByThreadId" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from mutex_instances
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into mutex_instances (OBJECT_INSTANCE_BEGIN, NAME, LOCKED_BY_THREAD_ID
      )
    values (#{objectInstanceBegin,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{lockedByThreadId,jdbcType=BIGINT}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update mutex_instances
    set NAME = #{name,jdbcType=VARCHAR},
      LOCKED_BY_THREAD_ID = #{lockedByThreadId,jdbcType=BIGINT}
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, NAME, LOCKED_BY_THREAD_ID
    from mutex_instances
    where OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select OBJECT_INSTANCE_BEGIN, NAME, LOCKED_BY_THREAD_ID
    from mutex_instances
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="NAME" jdbcType="VARCHAR" property="name" />
    <result column="ENABLED" jdbcType="CHAR" property="enabled" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from setup_consumers
    where NAME = #{name,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into setup_consumers (NAME, ENABLED)
    values (#{name,jdbcType=VARCHAR}, #{enabled,jdbcType=CHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update setup_consumers
    set ENABLED = #{enabled,jdbcType=CHAR}
    where NAME = #{name,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select NAME, ENABLED
    from setup_consumers
    where NAME = #{name,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select NAME, ENABLED
    from setup_consumers
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="VARIABLE_NAME" jdbcType="VARCHAR" property="variableName" />
    <result column="VARIABLE_VALUE" jdbcType="LONGVARBINARY" property="variableValue" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from user_variables_by_thread
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into user_variables_by_thread (THREAD_ID, VARIABLE_NAME, VARIABLE_VALUE
      )
    values (#{threadId,jdbcType=BIGINT}, #{variableName,jdbcType=VARCHAR}, #{variableValue,jdbcType=LONGVARBINARY}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update user_variables_by_thread
    set VARIABLE_VALUE = #{variableValue,jdbcType=LONGVARBINARY}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, VARIABLE_NAME, VARIABLE_VALUE
    from user_variables_by_thread
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, VARIABLE_NAME, VARIABLE_VALUE
    from user_variables_by_thread
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Transition_time" jdbcType="BIGINT" property="transitionTime" />
    <result column="Correction" jdbcType="INTEGER" property="correction" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from time_zone_leap_second
    where Transition_time = #{transitionTime,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into time_zone_leap_second (Transition_time, Correction)
    values (#{transitionTime,jdbcType=BIGINT}, #{correction,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update time_zone_leap_second
    set Correction = #{correction,jdbcType=INTEGER}
    where Transition_time = #{transitionTime,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select Transition_time, Correction
    from time_zone_leap_second
    where Transition_time = #{transitionTime,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Transition_time, Correction
    from time_zone_leap_second
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="gid" jdbcType="BIGINT" property="gid" />
    <result column="name" jdbcType="VARCHAR" property="name" />
    <result column="crateTime" jdbcType="VARCHAR" property="cratetime" />
    <result column="auth" jdbcType="VARCHAR" property="auth" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from groupclass
    where gid = #{gid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into groupclass (gid, name, crateTime, 
      auth)
    values (#{gid,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{cratetime,jdbcType=VARCHAR}, 
      #{auth,jdbcType=VARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update groupclass
    set name = #{name,jdbcType=VARCHAR},
      crateTime = #{cratetime,jdbcType=VARCHAR},
      auth = #{auth,jdbcType=VARCHAR}
    where gid = #{gid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select gid, name, crateTime, auth
    from groupclass
    where gid = #{gid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select gid, name, crateTime, auth
    from groupclass
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="CONSTRAINT_CATALOG" jdbcType="VARCHAR" property="constraintCatalog" />
    <result column="CONSTRAINT_SCHEMA" jdbcType="VARCHAR" property="constraintSchema" />
    <result column="CONSTRAINT_NAME" jdbcType="VARCHAR" property="constraintName" />
    <result column="TABLE_SCHEMA" jdbcType="VARCHAR" property="tableSchema" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
    <result column="CONSTRAINT_TYPE" jdbcType="VARCHAR" property="constraintType" />
    <result column="ENFORCED" jdbcType="VARCHAR" property="enforced" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into TABLE_CONSTRAINTS (CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA, 
      CONSTRAINT_NAME, TABLE_SCHEMA, TABLE_NAME, 
      CONSTRAINT_TYPE, ENFORCED)
    values (#{constraintCatalog,jdbcType=VARCHAR}, #{constraintSchema,jdbcType=VARCHAR}, 
      #{constraintName,jdbcType=VARCHAR}, #{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, 
      #{constraintType,jdbcType=VARCHAR}, #{enforced,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select CONSTRAINT_CATALOG, CONSTRAINT_SCHEMA, CONSTRAINT_NAME, TABLE_SCHEMA, TABLE_NAME, 
    CONSTRAINT_TYPE, ENFORCED
    from TABLE_CONSTRAINTS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="name" jdbcType="CHAR" property="name" />
    <result column="ret" jdbcType="BIT" property="ret" />
    <result column="dl" jdbcType="CHAR" property="dl" />
    <result column="type" jdbcType="CHAR" property="type" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from func
    where name = #{name,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into func (name, ret, dl, type
      )
    values (#{name,jdbcType=CHAR}, #{ret,jdbcType=BIT}, #{dl,jdbcType=CHAR}, #{type,jdbcType=CHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update func
    set ret = #{ret,jdbcType=BIT},
      dl = #{dl,jdbcType=CHAR},
      type = #{type,jdbcType=CHAR}
    where name = #{name,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select name, ret, dl, type
    from func
    where name = #{name,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select name, ret, dl, type
    from func
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="ENGINE" jdbcType="VARCHAR" property="engine" />
    <result column="REQUESTING_ENGINE_LOCK_ID" jdbcType="VARCHAR" property="requestingEngineLockId" />
    <result column="REQUESTING_ENGINE_TRANSACTION_ID" jdbcType="BIGINT" property="requestingEngineTransactionId" />
    <result column="REQUESTING_THREAD_ID" jdbcType="BIGINT" property="requestingThreadId" />
    <result column="REQUESTING_EVENT_ID" jdbcType="BIGINT" property="requestingEventId" />
    <result column="REQUESTING_OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="requestingObjectInstanceBegin" />
    <result column="BLOCKING_ENGINE_LOCK_ID" jdbcType="VARCHAR" property="blockingEngineLockId" />
    <result column="BLOCKING_ENGINE_TRANSACTION_ID" jdbcType="BIGINT" property="blockingEngineTransactionId" />
    <result column="BLOCKING_THREAD_ID" jdbcType="BIGINT" property="blockingThreadId" />
    <result column="BLOCKING_EVENT_ID" jdbcType="BIGINT" property="blockingEventId" />
    <result column="BLOCKING_OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="blockingObjectInstanceBegin" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into data_lock_waits (ENGINE, REQUESTING_ENGINE_LOCK_ID, REQUESTING_ENGINE_TRANSACTION_ID, 
      REQUESTING_THREAD_ID, REQUESTING_EVENT_ID, REQUESTING_OBJECT_INSTANCE_BEGIN, 
      BLOCKING_ENGINE_LOCK_ID, BLOCKING_ENGINE_TRANSACTION_ID, 
      BLOCKING_THREAD_ID, BLOCKING_EVENT_ID, BLOCKING_OBJECT_INSTANCE_BEGIN
      )
    values (#{engine,jdbcType=VARCHAR}, #{requestingEngineLockId,jdbcType=VARCHAR}, #{requestingEngineTransactionId,jdbcType=BIGINT}, 
      #{requestingThreadId,jdbcType=BIGINT}, #{requestingEventId,jdbcType=BIGINT}, #{requestingObjectInstanceBegin,jdbcType=BIGINT}, 
      #{blockingEngineLockId,jdbcType=VARCHAR}, #{blockingEngineTransactionId,jdbcType=BIGINT}, 
      #{blockingThreadId,jdbcType=BIGINT}, #{blockingEventId,jdbcType=BIGINT}, #{blockingObjectInstanceBegin,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select ENGINE, REQUESTING_ENGINE_LOCK_ID, REQUESTING_ENGINE_TRANSACTION_ID, REQUESTING_THREAD_ID, 
    REQUESTING_EVENT_ID, REQUESTING_OBJECT_INSTANCE_BEGIN, BLOCKING_ENGINE_LOCK_ID, BLOCKING_ENGINE_TRANSACTION_ID, 
    BLOCKING_THREAD_ID, BLOCKING_EVENT_ID, BLOCKING_OBJECT_INSTANCE_BEGIN
    from data_lock_waits
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="thread" jdbcType="VARCHAR" property="thread" />
    <result column="file" jdbcType="VARCHAR" property="file" />
    <result column="latency" jdbcType="BIGINT" property="latency" />
    <result column="operation" jdbcType="VARCHAR" property="operation" />
    <result column="requested" jdbcType="BIGINT" property="requested" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$latest_file_io (thread, file, latency, 
      operation, requested)
    values (#{thread,jdbcType=VARCHAR}, #{file,jdbcType=VARCHAR}, #{latency,jdbcType=BIGINT}, 
      #{operation,jdbcType=VARCHAR}, #{requested,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select thread, file, latency, operation, requested
    from x$latest_file_io
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="table_schema" jdbcType="VARCHAR" property="tableSchema" />
    <result column="table_name" jdbcType="VARCHAR" property="tableName" />
    <result column="index_name" jdbcType="VARCHAR" property="indexName" />
    <result column="rows_selected" jdbcType="BIGINT" property="rowsSelected" />
    <result column="rows_inserted" jdbcType="BIGINT" property="rowsInserted" />
    <result column="rows_updated" jdbcType="BIGINT" property="rowsUpdated" />
    <result column="rows_deleted" jdbcType="BIGINT" property="rowsDeleted" />
    <result column="select_latency" jdbcType="LONGVARCHAR" property="selectLatency" />
    <result column="insert_latency" jdbcType="LONGVARCHAR" property="insertLatency" />
    <result column="update_latency" jdbcType="LONGVARCHAR" property="updateLatency" />
    <result column="delete_latency" jdbcType="LONGVARCHAR" property="deleteLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into schema_index_statistics (table_schema, table_name, index_name, 
      rows_selected, rows_inserted, rows_updated, 
      rows_deleted, select_latency, insert_latency, 
      update_latency, delete_latency)
    values (#{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, #{indexName,jdbcType=VARCHAR}, 
      #{rowsSelected,jdbcType=BIGINT}, #{rowsInserted,jdbcType=BIGINT}, #{rowsUpdated,jdbcType=BIGINT}, 
      #{rowsDeleted,jdbcType=BIGINT}, #{selectLatency,jdbcType=LONGVARCHAR}, #{insertLatency,jdbcType=LONGVARCHAR}, 
      #{updateLatency,jdbcType=LONGVARCHAR}, #{deleteLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select table_schema, table_name, index_name, rows_selected, rows_inserted, rows_updated, 
    rows_deleted, select_latency, insert_latency, update_latency, delete_latency
    from schema_index_statistics
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="hid" jdbcType="INTEGER" property="hid" />
    <result column="cid" jdbcType="INTEGER" property="cid" />
    <result column="uid" jdbcType="INTEGER" property="uid" />
    <result column="startTime" jdbcType="TIMESTAMP" property="starttime" />
    <result column="endTime" jdbcType="TIMESTAMP" property="endtime" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from hire
    where hid = #{hid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into hire (hid, cid, uid, 
      startTime, endTime)
    values (#{hid,jdbcType=INTEGER}, #{cid,jdbcType=INTEGER}, #{uid,jdbcType=INTEGER}, 
      #{starttime,jdbcType=TIMESTAMP}, #{endtime,jdbcType=TIMESTAMP})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update hire
    set cid = #{cid,jdbcType=INTEGER},
      uid = #{uid,jdbcType=INTEGER},
      startTime = #{starttime,jdbcType=TIMESTAMP},
      endTime = #{endtime,jdbcType=TIMESTAMP}
    where hid = #{hid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select hid, cid, uid, startTime, endTime
    from hire
    where hid = #{hid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select hid, cid, uid, startTime, endTime
    from hire
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="CURRENT_CONNECTIONS" jdbcType="BIGINT" property="currentConnections" />
    <result column="TOTAL_CONNECTIONS" jdbcType="BIGINT" property="totalConnections" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into hosts (HOST, CURRENT_CONNECTIONS, TOTAL_CONNECTIONS
      )
    values (#{host,jdbcType=CHAR}, #{currentConnections,jdbcType=BIGINT}, #{totalConnections,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select HOST, CURRENT_CONNECTIONS, TOTAL_CONNECTIONS
    from hosts
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="KEY_ID" jdbcType="VARCHAR" property="keyId" />
    <result column="KEY_OWNER" jdbcType="VARCHAR" property="keyOwner" />
    <result column="BACKEND_KEY_ID" jdbcType="VARCHAR" property="backendKeyId" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into keyring_keys (KEY_ID, KEY_OWNER, BACKEND_KEY_ID
      )
    values (#{keyId,jdbcType=VARCHAR}, #{keyOwner,jdbcType=VARCHAR}, #{backendKeyId,jdbcType=VARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select KEY_ID, KEY_OWNER, BACKEND_KEY_ID
    from keyring_keys
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <result column="EVENT_ID" jdbcType="BIGINT" property="eventId" />
    <result column="END_EVENT_ID" jdbcType="BIGINT" property="endEventId" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="SOURCE" jdbcType="VARCHAR" property="source" />
    <result column="TIMER_START" jdbcType="BIGINT" property="timerStart" />
    <result column="TIMER_END" jdbcType="BIGINT" property="timerEnd" />
    <result column="TIMER_WAIT" jdbcType="BIGINT" property="timerWait" />
    <result column="WORK_COMPLETED" jdbcType="BIGINT" property="workCompleted" />
    <result column="WORK_ESTIMATED" jdbcType="BIGINT" property="workEstimated" />
    <result column="NESTING_EVENT_ID" jdbcType="BIGINT" property="nestingEventId" />
    <result column="NESTING_EVENT_TYPE" jdbcType="CHAR" property="nestingEventType" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_stages_history_long (THREAD_ID, EVENT_ID, END_EVENT_ID, 
      EVENT_NAME, SOURCE, TIMER_START, 
      TIMER_END, TIMER_WAIT, WORK_COMPLETED, 
      WORK_ESTIMATED, NESTING_EVENT_ID, NESTING_EVENT_TYPE
      )
    values (#{threadId,jdbcType=BIGINT}, #{eventId,jdbcType=BIGINT}, #{endEventId,jdbcType=BIGINT}, 
      #{eventName,jdbcType=VARCHAR}, #{source,jdbcType=VARCHAR}, #{timerStart,jdbcType=BIGINT}, 
      #{timerEnd,jdbcType=BIGINT}, #{timerWait,jdbcType=BIGINT}, #{workCompleted,jdbcType=BIGINT}, 
      #{workEstimated,jdbcType=BIGINT}, #{nestingEventId,jdbcType=BIGINT}, #{nestingEventType,jdbcType=CHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, SOURCE, TIMER_START, TIMER_END, 
    TIMER_WAIT, WORK_COMPLETED, WORK_ESTIMATED, NESTING_EVENT_ID, NESTING_EVENT_TYPE
    from events_stages_history_long
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_ALLOC" jdbcType="BIGINT" property="countAlloc" />
    <result column="COUNT_FREE" jdbcType="BIGINT" property="countFree" />
    <result column="SUM_NUMBER_OF_BYTES_ALLOC" jdbcType="BIGINT" property="sumNumberOfBytesAlloc" />
    <result column="SUM_NUMBER_OF_BYTES_FREE" jdbcType="BIGINT" property="sumNumberOfBytesFree" />
    <result column="LOW_COUNT_USED" jdbcType="BIGINT" property="lowCountUsed" />
    <result column="CURRENT_COUNT_USED" jdbcType="BIGINT" property="currentCountUsed" />
    <result column="HIGH_COUNT_USED" jdbcType="BIGINT" property="highCountUsed" />
    <result column="LOW_NUMBER_OF_BYTES_USED" jdbcType="BIGINT" property="lowNumberOfBytesUsed" />
    <result column="CURRENT_NUMBER_OF_BYTES_USED" jdbcType="BIGINT" property="currentNumberOfBytesUsed" />
    <result column="HIGH_NUMBER_OF_BYTES_USED" jdbcType="BIGINT" property="highNumberOfBytesUsed" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into memory_summary_by_user_by_event_name (USER, EVENT_NAME, COUNT_ALLOC, 
      COUNT_FREE, SUM_NUMBER_OF_BYTES_ALLOC, SUM_NUMBER_OF_BYTES_FREE, 
      LOW_COUNT_USED, CURRENT_COUNT_USED, HIGH_COUNT_USED, 
      LOW_NUMBER_OF_BYTES_USED, CURRENT_NUMBER_OF_BYTES_USED, 
      HIGH_NUMBER_OF_BYTES_USED)
    values (#{user,jdbcType=CHAR}, #{eventName,jdbcType=VARCHAR}, #{countAlloc,jdbcType=BIGINT}, 
      #{countFree,jdbcType=BIGINT}, #{sumNumberOfBytesAlloc,jdbcType=BIGINT}, #{sumNumberOfBytesFree,jdbcType=BIGINT}, 
      #{lowCountUsed,jdbcType=BIGINT}, #{currentCountUsed,jdbcType=BIGINT}, #{highCountUsed,jdbcType=BIGINT}, 
      #{lowNumberOfBytesUsed,jdbcType=BIGINT}, #{currentNumberOfBytesUsed,jdbcType=BIGINT}, 
      #{highNumberOfBytesUsed,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, EVENT_NAME, COUNT_ALLOC, COUNT_FREE, SUM_NUMBER_OF_BYTES_ALLOC, SUM_NUMBER_OF_BYTES_FREE, 
    LOW_COUNT_USED, CURRENT_COUNT_USED, HIGH_COUNT_USED, LOW_NUMBER_OF_BYTES_USED, CURRENT_NUMBER_OF_BYTES_USED, 
    HIGH_NUMBER_OF_BYTES_USED
    from memory_summary_by_user_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from events_waits_summary_by_thread_by_event_name
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_waits_summary_by_thread_by_event_name (THREAD_ID, EVENT_NAME, COUNT_STAR, 
      SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
      MAX_TIMER_WAIT)
    values (#{threadId,jdbcType=BIGINT}, #{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, 
      #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, 
      #{maxTimerWait,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_waits_summary_by_thread_by_event_name
    set COUNT_STAR = #{countStar,jdbcType=BIGINT},
      SUM_TIMER_WAIT = #{sumTimerWait,jdbcType=BIGINT},
      MIN_TIMER_WAIT = #{minTimerWait,jdbcType=BIGINT},
      AVG_TIMER_WAIT = #{avgTimerWait,jdbcType=BIGINT},
      MAX_TIMER_WAIT = #{maxTimerWait,jdbcType=BIGINT}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT
    from events_waits_summary_by_thread_by_event_name
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT
    from events_waits_summary_by_thread_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="uid" jdbcType="BIGINT" property="uid" />
    <result column="u_name" jdbcType="VARCHAR" property="uName" />
    <result column="u_uid" jdbcType="VARCHAR" property="uUid" />
    <result column="u_emal" jdbcType="VARCHAR" property="uEmal" />
    <result column="u_password" jdbcType="VARCHAR" property="uPassword" />
    <result column="u_birthday" jdbcType="TIMESTAMP" property="uBirthday" />
    <result column="u_createtime" jdbcType="TIMESTAMP" property="uCreatetime" />
    <result column="u_modified" jdbcType="TIMESTAMP" property="uModified" />
    <result column="u_admin" jdbcType="BIGINT" property="uAdmin" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into users (uid, u_name, u_uid, 
      u_emal, u_password, u_birthday, 
      u_createtime, u_modified, u_admin
      )
    values (#{uid,jdbcType=BIGINT}, #{uName,jdbcType=VARCHAR}, #{uUid,jdbcType=VARCHAR}, 
      #{uEmal,jdbcType=VARCHAR}, #{uPassword,jdbcType=VARCHAR}, #{uBirthday,jdbcType=TIMESTAMP}, 
      #{uCreatetime,jdbcType=TIMESTAMP}, #{uModified,jdbcType=TIMESTAMP}, #{uAdmin,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select uid, u_name, u_uid, u_emal, u_password, u_birthday, u_createtime, u_modified, 
    u_admin
    from users
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="uid" jdbcType="BIGINT" property="uid" />
    <result column="name" jdbcType="VARCHAR" property="name" />
    <result column="password" jdbcType="VARCHAR" property="password" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into user (uid, name, password
      )
    values (#{uid,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{password,jdbcType=VARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select uid, name, password
    from user
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="NAME" jdbcType="VARCHAR" property="name" />
    <result column="PATH" jdbcType="VARCHAR" property="path" />
    <result column="SPACE_TYPE" jdbcType="VARCHAR" property="spaceType" />
    <result column="SPACE" jdbcType="VARBINARY" property="space" />
    <result column="FLAG" jdbcType="VARBINARY" property="flag" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_TABLESPACES_BRIEF (NAME, PATH, SPACE_TYPE, 
      SPACE, FLAG)
    values (#{name,jdbcType=VARCHAR}, #{path,jdbcType=VARCHAR}, #{spaceType,jdbcType=VARCHAR}, 
      #{space,jdbcType=VARBINARY}, #{flag,jdbcType=VARBINARY})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select NAME, PATH, SPACE_TYPE, SPACE, FLAG
    from INNODB_TABLESPACES_BRIEF
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="statement" jdbcType="VARCHAR" property="statement" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="rows_sent" jdbcType="BIGINT" property="rowsSent" />
    <result column="rows_examined" jdbcType="BIGINT" property="rowsExamined" />
    <result column="rows_affected" jdbcType="BIGINT" property="rowsAffected" />
    <result column="full_scans" jdbcType="BIGINT" property="fullScans" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
    <result column="lock_latency" jdbcType="LONGVARCHAR" property="lockLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into user_summary_by_statement_type (user, statement, total, 
      rows_sent, rows_examined, rows_affected, 
      full_scans, total_latency, max_latency, 
      lock_latency)
    values (#{user,jdbcType=VARCHAR}, #{statement,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, 
      #{rowsSent,jdbcType=BIGINT}, #{rowsExamined,jdbcType=BIGINT}, #{rowsAffected,jdbcType=BIGINT}, 
      #{fullScans,jdbcType=BIGINT}, #{totalLatency,jdbcType=LONGVARCHAR}, #{maxLatency,jdbcType=LONGVARCHAR}, 
      #{lockLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, statement, total, rows_sent, rows_examined, rows_affected, full_scans, 
    total_latency, max_latency, lock_latency
    from user_summary_by_statement_type
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="SCHEMA_NAME" jdbcType="VARCHAR" property="schemaName" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
    <result column="COLUMN_NAME" jdbcType="VARCHAR" property="columnName" />
    <result column="HISTOGRAM" jdbcType="LONGVARCHAR" property="histogram" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into COLUMN_STATISTICS (SCHEMA_NAME, TABLE_NAME, COLUMN_NAME, 
      HISTOGRAM)
    values (#{schemaName,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, #{columnName,jdbcType=VARCHAR}, 
      #{histogram,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select SCHEMA_NAME, TABLE_NAME, COLUMN_NAME, HISTOGRAM
    from COLUMN_STATISTICS
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="table_schema" jdbcType="VARCHAR" property="tableSchema" />
    <result column="table_name" jdbcType="VARCHAR" property="tableName" />
    <result column="index_name" jdbcType="VARCHAR" property="indexName" />
    <result column="non_unique" jdbcType="INTEGER" property="nonUnique" />
    <result column="subpart_exists" jdbcType="BIGINT" property="subpartExists" />
    <result column="index_columns" jdbcType="LONGVARCHAR" property="indexColumns" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$schema_flattened_keys (table_schema, table_name, index_name, 
      non_unique, subpart_exists, index_columns
      )
    values (#{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, #{indexName,jdbcType=VARCHAR}, 
      #{nonUnique,jdbcType=INTEGER}, #{subpartExists,jdbcType=BIGINT}, #{indexColumns,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select table_schema, table_name, index_name, non_unique, subpart_exists, index_columns
    from x$schema_flattened_keys
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <result column="NAME" jdbcType="VARCHAR" property="name" />
    <result column="TYPE" jdbcType="VARCHAR" property="type" />
    <result column="PROCESSLIST_ID" jdbcType="BIGINT" property="processlistId" />
    <result column="PROCESSLIST_USER" jdbcType="VARCHAR" property="processlistUser" />
    <result column="PROCESSLIST_HOST" jdbcType="VARCHAR" property="processlistHost" />
    <result column="PROCESSLIST_DB" jdbcType="VARCHAR" property="processlistDb" />
    <result column="PROCESSLIST_COMMAND" jdbcType="VARCHAR" property="processlistCommand" />
    <result column="PROCESSLIST_TIME" jdbcType="BIGINT" property="processlistTime" />
    <result column="PROCESSLIST_STATE" jdbcType="VARCHAR" property="processlistState" />
    <result column="PARENT_THREAD_ID" jdbcType="BIGINT" property="parentThreadId" />
    <result column="ROLE" jdbcType="VARCHAR" property="role" />
    <result column="INSTRUMENTED" jdbcType="CHAR" property="instrumented" />
    <result column="HISTORY" jdbcType="CHAR" property="history" />
    <result column="CONNECTION_TYPE" jdbcType="VARCHAR" property="connectionType" />
    <result column="THREAD_OS_ID" jdbcType="BIGINT" property="threadOsId" />
    <result column="RESOURCE_GROUP" jdbcType="VARCHAR" property="resourceGroup" />
    <result column="PROCESSLIST_INFO" jdbcType="LONGVARCHAR" property="processlistInfo" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from threads
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into threads (THREAD_ID, NAME, TYPE, 
      PROCESSLIST_ID, PROCESSLIST_USER, PROCESSLIST_HOST, 
      PROCESSLIST_DB, PROCESSLIST_COMMAND, PROCESSLIST_TIME, 
      PROCESSLIST_STATE, PARENT_THREAD_ID, ROLE, 
      INSTRUMENTED, HISTORY, CONNECTION_TYPE, 
      THREAD_OS_ID, RESOURCE_GROUP, PROCESSLIST_INFO
      )
    values (#{threadId,jdbcType=BIGINT}, #{name,jdbcType=VARCHAR}, #{type,jdbcType=VARCHAR}, 
      #{processlistId,jdbcType=BIGINT}, #{processlistUser,jdbcType=VARCHAR}, #{processlistHost,jdbcType=VARCHAR}, 
      #{processlistDb,jdbcType=VARCHAR}, #{processlistCommand,jdbcType=VARCHAR}, #{processlistTime,jdbcType=BIGINT}, 
      #{processlistState,jdbcType=VARCHAR}, #{parentThreadId,jdbcType=BIGINT}, #{role,jdbcType=VARCHAR}, 
      #{instrumented,jdbcType=CHAR}, #{history,jdbcType=CHAR}, #{connectionType,jdbcType=VARCHAR}, 
      #{threadOsId,jdbcType=BIGINT}, #{resourceGroup,jdbcType=VARCHAR}, #{processlistInfo,jdbcType=LONGVARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update threads
    set NAME = #{name,jdbcType=VARCHAR},
      TYPE = #{type,jdbcType=VARCHAR},
      PROCESSLIST_ID = #{processlistId,jdbcType=BIGINT},
      PROCESSLIST_USER = #{processlistUser,jdbcType=VARCHAR},
      PROCESSLIST_HOST = #{processlistHost,jdbcType=VARCHAR},
      PROCESSLIST_DB = #{processlistDb,jdbcType=VARCHAR},
      PROCESSLIST_COMMAND = #{processlistCommand,jdbcType=VARCHAR},
      PROCESSLIST_TIME = #{processlistTime,jdbcType=BIGINT},
      PROCESSLIST_STATE = #{processlistState,jdbcType=VARCHAR},
      PARENT_THREAD_ID = #{parentThreadId,jdbcType=BIGINT},
      ROLE = #{role,jdbcType=VARCHAR},
      INSTRUMENTED = #{instrumented,jdbcType=CHAR},
      HISTORY = #{history,jdbcType=CHAR},
      CONNECTION_TYPE = #{connectionType,jdbcType=VARCHAR},
      THREAD_OS_ID = #{threadOsId,jdbcType=BIGINT},
      RESOURCE_GROUP = #{resourceGroup,jdbcType=VARCHAR},
      PROCESSLIST_INFO = #{processlistInfo,jdbcType=LONGVARCHAR}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select THREAD_ID, NAME, TYPE, PROCESSLIST_ID, PROCESSLIST_USER, PROCESSLIST_HOST, 
    PROCESSLIST_DB, PROCESSLIST_COMMAND, PROCESSLIST_TIME, PROCESSLIST_STATE, PARENT_THREAD_ID, 
    ROLE, INSTRUMENTED, HISTORY, CONNECTION_TYPE, THREAD_OS_ID, RESOURCE_GROUP, PROCESSLIST_INFO
    from threads
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, NAME, TYPE, PROCESSLIST_ID, PROCESSLIST_USER, PROCESSLIST_HOST, 
    PROCESSLIST_DB, PROCESSLIST_COMMAND, PROCESSLIST_TIME, PROCESSLIST_STATE, PARENT_THREAD_ID, 
    ROLE, INSTRUMENTED, HISTORY, CONNECTION_TYPE, THREAD_OS_ID, RESOURCE_GROUP, PROCESSLIST_INFO
    from threads
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
    <result column="COUNT_READ" jdbcType="BIGINT" property="countRead" />
    <result column="SUM_TIMER_READ" jdbcType="BIGINT" property="sumTimerRead" />
    <result column="MIN_TIMER_READ" jdbcType="BIGINT" property="minTimerRead" />
    <result column="AVG_TIMER_READ" jdbcType="BIGINT" property="avgTimerRead" />
    <result column="MAX_TIMER_READ" jdbcType="BIGINT" property="maxTimerRead" />
    <result column="SUM_NUMBER_OF_BYTES_READ" jdbcType="BIGINT" property="sumNumberOfBytesRead" />
    <result column="COUNT_WRITE" jdbcType="BIGINT" property="countWrite" />
    <result column="SUM_TIMER_WRITE" jdbcType="BIGINT" property="sumTimerWrite" />
    <result column="MIN_TIMER_WRITE" jdbcType="BIGINT" property="minTimerWrite" />
    <result column="AVG_TIMER_WRITE" jdbcType="BIGINT" property="avgTimerWrite" />
    <result column="MAX_TIMER_WRITE" jdbcType="BIGINT" property="maxTimerWrite" />
    <result column="SUM_NUMBER_OF_BYTES_WRITE" jdbcType="BIGINT" property="sumNumberOfBytesWrite" />
    <result column="COUNT_MISC" jdbcType="BIGINT" property="countMisc" />
    <result column="SUM_TIMER_MISC" jdbcType="BIGINT" property="sumTimerMisc" />
    <result column="MIN_TIMER_MISC" jdbcType="BIGINT" property="minTimerMisc" />
    <result column="AVG_TIMER_MISC" jdbcType="BIGINT" property="avgTimerMisc" />
    <result column="MAX_TIMER_MISC" jdbcType="BIGINT" property="maxTimerMisc" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from file_summary_by_event_name
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into file_summary_by_event_name (EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, 
      MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, 
      COUNT_READ, SUM_TIMER_READ, MIN_TIMER_READ, 
      AVG_TIMER_READ, MAX_TIMER_READ, SUM_NUMBER_OF_BYTES_READ, 
      COUNT_WRITE, SUM_TIMER_WRITE, MIN_TIMER_WRITE, 
      AVG_TIMER_WRITE, MAX_TIMER_WRITE, SUM_NUMBER_OF_BYTES_WRITE, 
      COUNT_MISC, SUM_TIMER_MISC, MIN_TIMER_MISC, 
      AVG_TIMER_MISC, MAX_TIMER_MISC)
    values (#{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, #{sumTimerWait,jdbcType=BIGINT}, 
      #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, #{maxTimerWait,jdbcType=BIGINT}, 
      #{countRead,jdbcType=BIGINT}, #{sumTimerRead,jdbcType=BIGINT}, #{minTimerRead,jdbcType=BIGINT}, 
      #{avgTimerRead,jdbcType=BIGINT}, #{maxTimerRead,jdbcType=BIGINT}, #{sumNumberOfBytesRead,jdbcType=BIGINT}, 
      #{countWrite,jdbcType=BIGINT}, #{sumTimerWrite,jdbcType=BIGINT}, #{minTimerWrite,jdbcType=BIGINT}, 
      #{avgTimerWrite,jdbcType=BIGINT}, #{maxTimerWrite,jdbcType=BIGINT}, #{sumNumberOfBytesWrite,jdbcType=BIGINT}, 
      #{countMisc,jdbcType=BIGINT}, #{sumTimerMisc,jdbcType=BIGINT}, #{minTimerMisc,jdbcType=BIGINT}, 
      #{avgTimerMisc,jdbcType=BIGINT}, #{maxTimerMisc,jdbcType=BIGINT})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update file_summary_by_event_name
    set COUNT_STAR = #{countStar,jdbcType=BIGINT},
      SUM_TIMER_WAIT = #{sumTimerWait,jdbcType=BIGINT},
      MIN_TIMER_WAIT = #{minTimerWait,jdbcType=BIGINT},
      AVG_TIMER_WAIT = #{avgTimerWait,jdbcType=BIGINT},
      MAX_TIMER_WAIT = #{maxTimerWait,jdbcType=BIGINT},
      COUNT_READ = #{countRead,jdbcType=BIGINT},
      SUM_TIMER_READ = #{sumTimerRead,jdbcType=BIGINT},
      MIN_TIMER_READ = #{minTimerRead,jdbcType=BIGINT},
      AVG_TIMER_READ = #{avgTimerRead,jdbcType=BIGINT},
      MAX_TIMER_READ = #{maxTimerRead,jdbcType=BIGINT},
      SUM_NUMBER_OF_BYTES_READ = #{sumNumberOfBytesRead,jdbcType=BIGINT},
      COUNT_WRITE = #{countWrite,jdbcType=BIGINT},
      SUM_TIMER_WRITE = #{sumTimerWrite,jdbcType=BIGINT},
      MIN_TIMER_WRITE = #{minTimerWrite,jdbcType=BIGINT},
      AVG_TIMER_WRITE = #{avgTimerWrite,jdbcType=BIGINT},
      MAX_TIMER_WRITE = #{maxTimerWrite,jdbcType=BIGINT},
      SUM_NUMBER_OF_BYTES_WRITE = #{sumNumberOfBytesWrite,jdbcType=BIGINT},
      COUNT_MISC = #{countMisc,jdbcType=BIGINT},
      SUM_TIMER_MISC = #{sumTimerMisc,jdbcType=BIGINT},
      MIN_TIMER_MISC = #{minTimerMisc,jdbcType=BIGINT},
      AVG_TIMER_MISC = #{avgTimerMisc,jdbcType=BIGINT},
      MAX_TIMER_MISC = #{maxTimerMisc,jdbcType=BIGINT}
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, 
    COUNT_READ, SUM_TIMER_READ, MIN_TIMER_READ, AVG_TIMER_READ, MAX_TIMER_READ, SUM_NUMBER_OF_BYTES_READ, 
    COUNT_WRITE, SUM_TIMER_WRITE, MIN_TIMER_WRITE, AVG_TIMER_WRITE, MAX_TIMER_WRITE, 
    SUM_NUMBER_OF_BYTES_WRITE, COUNT_MISC, SUM_TIMER_MISC, MIN_TIMER_MISC, AVG_TIMER_MISC, 
    MAX_TIMER_MISC
    from file_summary_by_event_name
    where EVENT_NAME = #{eventName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, MAX_TIMER_WAIT, 
    COUNT_READ, SUM_TIMER_READ, MIN_TIMER_READ, AVG_TIMER_READ, MAX_TIMER_READ, SUM_NUMBER_OF_BYTES_READ, 
    COUNT_WRITE, SUM_TIMER_WRITE, MIN_TIMER_WRITE, AVG_TIMER_WRITE, MAX_TIMER_WRITE, 
    SUM_NUMBER_OF_BYTES_WRITE, COUNT_MISC, SUM_TIMER_MISC, MIN_TIMER_MISC, AVG_TIMER_MISC, 
    MAX_TIMER_MISC
    from file_summary_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="event_class" jdbcType="VARCHAR" property="eventClass" />
    <result column="total" jdbcType="DECIMAL" property="total" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="min_latency" jdbcType="LONGVARCHAR" property="minLatency" />
    <result column="avg_latency" jdbcType="LONGVARCHAR" property="avgLatency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into wait_classes_global_by_latency (event_class, total, total_latency, 
      min_latency, avg_latency, max_latency
      )
    values (#{eventClass,jdbcType=VARCHAR}, #{total,jdbcType=DECIMAL}, #{totalLatency,jdbcType=LONGVARCHAR}, 
      #{minLatency,jdbcType=LONGVARCHAR}, #{avgLatency,jdbcType=LONGVARCHAR}, #{maxLatency,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select event_class, total, total_latency, min_latency, avg_latency, max_latency
    from wait_classes_global_by_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="exec_count" jdbcType="BIGINT" property="execCount" />
    <result column="memory_tmp_tables" jdbcType="BIGINT" property="memoryTmpTables" />
    <result column="disk_tmp_tables" jdbcType="BIGINT" property="diskTmpTables" />
    <result column="avg_tmp_tables_per_query" jdbcType="DECIMAL" property="avgTmpTablesPerQuery" />
    <result column="tmp_tables_to_disk_pct" jdbcType="DECIMAL" property="tmpTablesToDiskPct" />
    <result column="first_seen" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="last_seen" jdbcType="TIMESTAMP" property="lastSeen" />
    <result column="digest" jdbcType="VARCHAR" property="digest" />
    <result column="query" jdbcType="LONGVARCHAR" property="query" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into statements_with_temp_tables (db, exec_count, memory_tmp_tables, 
      disk_tmp_tables, avg_tmp_tables_per_query, tmp_tables_to_disk_pct, 
      first_seen, last_seen, digest, 
      query, total_latency)
    values (#{db,jdbcType=VARCHAR}, #{execCount,jdbcType=BIGINT}, #{memoryTmpTables,jdbcType=BIGINT}, 
      #{diskTmpTables,jdbcType=BIGINT}, #{avgTmpTablesPerQuery,jdbcType=DECIMAL}, #{tmpTablesToDiskPct,jdbcType=DECIMAL}, 
      #{firstSeen,jdbcType=TIMESTAMP}, #{lastSeen,jdbcType=TIMESTAMP}, #{digest,jdbcType=VARCHAR}, 
      #{query,jdbcType=LONGVARCHAR}, #{totalLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select db, exec_count, memory_tmp_tables, disk_tmp_tables, avg_tmp_tables_per_query, 
    tmp_tables_to_disk_pct, first_seen, last_seen, digest, query, total_latency
    from statements_with_temp_tables
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="cid" jdbcType="BIGINT" property="cid" />
    <result column="tid" jdbcType="BIGINT" property="tid" />
    <result column="uid" jdbcType="BIGINT" property="uid" />
    <result column="c_good" jdbcType="BIGINT" property="cGood" />
    <result column="c_no" jdbcType="BIGINT" property="cNo" />
    <result column="c_createtime" jdbcType="TIMESTAMP" property="cCreatetime" />
    <result column="c_content" jdbcType="LONGVARCHAR" property="cContent" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from comments
    where cid = #{cid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into comments (cid, tid, uid, c_good, 
      c_no, c_createtime, c_content
      )
    values (#{cid,jdbcType=BIGINT}, #{tid,jdbcType=BIGINT}, #{uid,jdbcType=BIGINT}, #{cGood,jdbcType=BIGINT}, 
      #{cNo,jdbcType=BIGINT}, #{cCreatetime,jdbcType=TIMESTAMP}, #{cContent,jdbcType=LONGVARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update comments
    set tid = #{tid,jdbcType=BIGINT},
      uid = #{uid,jdbcType=BIGINT},
      c_good = #{cGood,jdbcType=BIGINT},
      c_no = #{cNo,jdbcType=BIGINT},
      c_createtime = #{cCreatetime,jdbcType=TIMESTAMP},
      c_content = #{cContent,jdbcType=LONGVARCHAR}
    where cid = #{cid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select cid, tid, uid, c_good, c_no, c_createtime, c_content
    from comments
    where cid = #{cid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select cid, tid, uid, c_good, c_no, c_createtime, c_content
    from comments
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="VARIABLE_NAME" jdbcType="VARCHAR" property="variableName" />
    <result column="VARIABLE_VALUE" jdbcType="VARCHAR" property="variableValue" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from variables_by_thread
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into variables_by_thread (THREAD_ID, VARIABLE_NAME, VARIABLE_VALUE
      )
    values (#{threadId,jdbcType=BIGINT}, #{variableName,jdbcType=VARCHAR}, #{variableValue,jdbcType=VARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update variables_by_thread
    set VARIABLE_VALUE = #{variableValue,jdbcType=VARCHAR}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, VARIABLE_NAME, VARIABLE_VALUE
    from variables_by_thread
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and VARIABLE_NAME = #{variableName,jdbcType=VARCHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, VARIABLE_NAME, VARIABLE_VALUE
    from variables_by_thread
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="USER" jdbcType="CHAR" property="user" />
    <id column="HOST" jdbcType="CHAR" property="host" />
    <id column="PRIV" jdbcType="CHAR" property="priv" />
    <result column="WITH_GRANT_OPTION" jdbcType="CHAR" property="withGrantOption" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from global_grants
    where USER = #{user,jdbcType=CHAR}
      and HOST = #{host,jdbcType=CHAR}
      and PRIV = #{priv,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into global_grants (USER, HOST, PRIV, WITH_GRANT_OPTION
      )
    values (#{user,jdbcType=CHAR}, #{host,jdbcType=CHAR}, #{priv,jdbcType=CHAR}, #{withGrantOption,jdbcType=CHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update global_grants
    set WITH_GRANT_OPTION = #{withGrantOption,jdbcType=CHAR}
    where USER = #{user,jdbcType=CHAR}
      and HOST = #{host,jdbcType=CHAR}
      and PRIV = #{priv,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select USER, HOST, PRIV, WITH_GRANT_OPTION
    from global_grants
    where USER = #{user,jdbcType=CHAR}
      and HOST = #{host,jdbcType=CHAR}
      and PRIV = #{priv,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, HOST, PRIV, WITH_GRANT_OPTION
    from global_grants
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="object_schema" jdbcType="VARCHAR" property="objectSchema" />
    <result column="object_name" jdbcType="VARCHAR" property="objectName" />
    <result column="index_name" jdbcType="VARCHAR" property="indexName" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into schema_unused_indexes (object_schema, object_name, index_name
      )
    values (#{objectSchema,jdbcType=VARCHAR}, #{objectName,jdbcType=VARCHAR}, #{indexName,jdbcType=VARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select object_schema, object_name, index_name
    from schema_unused_indexes
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="mailId" jdbcType="BIGINT" property="mailid" />
    <result column="from_name" jdbcType="VARCHAR" property="fromName" />
    <result column="from_mail" jdbcType="VARCHAR" property="fromMail" />
    <result column="status" jdbcType="INTEGER" property="status" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Long">
    delete from mailinfo
    where mailId = #{mailid,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into mailinfo (mailId, from_name, from_mail, 
      status)
    values (#{mailid,jdbcType=BIGINT}, #{fromName,jdbcType=VARCHAR}, #{fromMail,jdbcType=VARCHAR}, 
      #{status,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update mailinfo
    set from_name = #{fromName,jdbcType=VARCHAR},
      from_mail = #{fromMail,jdbcType=VARCHAR},
      status = #{status,jdbcType=INTEGER}
    where mailId = #{mailid,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Long" resultMap="BaseResultMap">
    select mailId, from_name, from_mail, status
    from mailinfo
    where mailId = #{mailid,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select mailId, from_name, from_mail, status
    from mailinfo
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="USER" jdbcType="CHAR" property="user" />
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="ERROR_NUMBER" jdbcType="INTEGER" property="errorNumber" />
    <result column="ERROR_NAME" jdbcType="VARCHAR" property="errorName" />
    <result column="SQL_STATE" jdbcType="VARCHAR" property="sqlState" />
    <result column="SUM_ERROR_RAISED" jdbcType="BIGINT" property="sumErrorRaised" />
    <result column="SUM_ERROR_HANDLED" jdbcType="BIGINT" property="sumErrorHandled" />
    <result column="FIRST_SEEN" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="LAST_SEEN" jdbcType="TIMESTAMP" property="lastSeen" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_errors_summary_by_account_by_error (USER, HOST, ERROR_NUMBER, 
      ERROR_NAME, SQL_STATE, SUM_ERROR_RAISED, 
      SUM_ERROR_HANDLED, FIRST_SEEN, LAST_SEEN
      )
    values (#{user,jdbcType=CHAR}, #{host,jdbcType=CHAR}, #{errorNumber,jdbcType=INTEGER}, 
      #{errorName,jdbcType=VARCHAR}, #{sqlState,jdbcType=VARCHAR}, #{sumErrorRaised,jdbcType=BIGINT}, 
      #{sumErrorHandled,jdbcType=BIGINT}, #{firstSeen,jdbcType=TIMESTAMP}, #{lastSeen,jdbcType=TIMESTAMP}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select USER, HOST, ERROR_NUMBER, ERROR_NAME, SQL_STATE, SUM_ERROR_RAISED, SUM_ERROR_HANDLED, 
    FIRST_SEEN, LAST_SEEN
    from events_errors_summary_by_account_by_error
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="TABLE_CATALOG" jdbcType="VARCHAR" property="tableCatalog" />
    <result column="TABLE_SCHEMA" jdbcType="VARCHAR" property="tableSchema" />
    <result column="TABLE_NAME" jdbcType="VARCHAR" property="tableName" />
    <result column="SPECIFIC_CATALOG" jdbcType="VARCHAR" property="specificCatalog" />
    <result column="SPECIFIC_SCHEMA" jdbcType="VARCHAR" property="specificSchema" />
    <result column="SPECIFIC_NAME" jdbcType="VARCHAR" property="specificName" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into VIEW_ROUTINE_USAGE (TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, 
      SPECIFIC_CATALOG, SPECIFIC_SCHEMA, SPECIFIC_NAME
      )
    values (#{tableCatalog,jdbcType=VARCHAR}, #{tableSchema,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, 
      #{specificCatalog,jdbcType=VARCHAR}, #{specificSchema,jdbcType=VARCHAR}, #{specificName,jdbcType=VARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, SPECIFIC_CATALOG, SPECIFIC_SCHEMA, 
    SPECIFIC_NAME
    from VIEW_ROUTINE_USAGE
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="pid" jdbcType="INTEGER" property="pid" />
    <result column="pname" jdbcType="VARCHAR" property="pname" />
    <result column="type" jdbcType="VARCHAR" property="type" />
    <result column="price" jdbcType="REAL" property="price" />
    <result column="repertory" jdbcType="INTEGER" property="repertory" />
    <result column="describes" jdbcType="VARCHAR" property="describes" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from product
    where pid = #{pid,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into product (pid, pname, type, 
      price, repertory, describes
      )
    values (#{pid,jdbcType=INTEGER}, #{pname,jdbcType=VARCHAR}, #{type,jdbcType=VARCHAR}, 
      #{price,jdbcType=REAL}, #{repertory,jdbcType=INTEGER}, #{describes,jdbcType=VARCHAR}
      )
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update product
    set pname = #{pname,jdbcType=VARCHAR},
      type = #{type,jdbcType=VARCHAR},
      price = #{price,jdbcType=REAL},
      repertory = #{repertory,jdbcType=INTEGER},
      describes = #{describes,jdbcType=VARCHAR}
    where pid = #{pid,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select pid, pname, type, price, repertory, describes
    from product
    where pid = #{pid,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select pid, pname, type, price, repertory, describes
    from product
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="total" jdbcType="DECIMAL" property="total" />
    <result column="thread_id" jdbcType="BIGINT" property="threadId" />
    <result column="processlist_id" jdbcType="BIGINT" property="processlistId" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="min_latency" jdbcType="LONGVARCHAR" property="minLatency" />
    <result column="avg_latency" jdbcType="LONGVARCHAR" property="avgLatency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into io_by_thread_by_latency (user, total, thread_id, 
      processlist_id, total_latency, min_latency, 
      avg_latency, max_latency)
    values (#{user,jdbcType=VARCHAR}, #{total,jdbcType=DECIMAL}, #{threadId,jdbcType=BIGINT}, 
      #{processlistId,jdbcType=BIGINT}, #{totalLatency,jdbcType=LONGVARCHAR}, #{minLatency,jdbcType=LONGVARCHAR}, 
      #{avgLatency,jdbcType=LONGVARCHAR}, #{maxLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, total, thread_id, processlist_id, total_latency, min_latency, avg_latency, 
    max_latency
    from io_by_thread_by_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="id" jdbcType="INTEGER" property="id" />
    <result column="action" jdbcType="VARCHAR" property="action" />
    <result column="data" jdbcType="VARCHAR" property="data" />
    <result column="authorId" jdbcType="INTEGER" property="authorid" />
    <result column="ip" jdbcType="VARCHAR" property="ip" />
    <result column="created" jdbcType="INTEGER" property="created" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.Integer">
    delete from t_logs
    where id = #{id,jdbcType=INTEGER}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    <selectKey keyProperty="id" order="AFTER" resultType="java.lang.Integer">
      SELECT LAST_INSERT_ID()
    </selectKey>
    insert into t_logs (action, data, authorId, 
      ip, created)
    values (#{action,jdbcType=VARCHAR}, #{data,jdbcType=VARCHAR}, #{authorid,jdbcType=INTEGER}, 
      #{ip,jdbcType=VARCHAR}, #{created,jdbcType=INTEGER})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update t_logs
    set action = #{action,jdbcType=VARCHAR},
      data = #{data,jdbcType=VARCHAR},
      authorId = #{authorid,jdbcType=INTEGER},
      ip = #{ip,jdbcType=VARCHAR},
      created = #{created,jdbcType=INTEGER}
    where id = #{id,jdbcType=INTEGER}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap">
    select id, action, data, authorId, ip, created
    from t_logs
    where id = #{id,jdbcType=INTEGER}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select id, action, data, authorId, ip, created
    from t_logs
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="HOST" jdbcType="CHAR" property="host" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="COUNT_STAR" jdbcType="BIGINT" property="countStar" />
    <result column="SUM_TIMER_WAIT" jdbcType="BIGINT" property="sumTimerWait" />
    <result column="MIN_TIMER_WAIT" jdbcType="BIGINT" property="minTimerWait" />
    <result column="AVG_TIMER_WAIT" jdbcType="BIGINT" property="avgTimerWait" />
    <result column="MAX_TIMER_WAIT" jdbcType="BIGINT" property="maxTimerWait" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_waits_summary_by_host_by_event_name (HOST, EVENT_NAME, COUNT_STAR, 
      SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
      MAX_TIMER_WAIT)
    values (#{host,jdbcType=CHAR}, #{eventName,jdbcType=VARCHAR}, #{countStar,jdbcType=BIGINT}, 
      #{sumTimerWait,jdbcType=BIGINT}, #{minTimerWait,jdbcType=BIGINT}, #{avgTimerWait,jdbcType=BIGINT}, 
      #{maxTimerWait,jdbcType=BIGINT})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select HOST, EVENT_NAME, COUNT_STAR, SUM_TIMER_WAIT, MIN_TIMER_WAIT, AVG_TIMER_WAIT, 
    MAX_TIMER_WAIT
    from events_waits_summary_by_host_by_event_name
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="THREAD_ID" jdbcType="BIGINT" property="threadId" />
    <id column="EVENT_ID" jdbcType="BIGINT" property="eventId" />
    <result column="END_EVENT_ID" jdbcType="BIGINT" property="endEventId" />
    <result column="EVENT_NAME" jdbcType="VARCHAR" property="eventName" />
    <result column="STATE" jdbcType="CHAR" property="state" />
    <result column="TRX_ID" jdbcType="BIGINT" property="trxId" />
    <result column="GTID" jdbcType="VARCHAR" property="gtid" />
    <result column="XID_FORMAT_ID" jdbcType="INTEGER" property="xidFormatId" />
    <result column="XID_GTRID" jdbcType="VARCHAR" property="xidGtrid" />
    <result column="XID_BQUAL" jdbcType="VARCHAR" property="xidBqual" />
    <result column="XA_STATE" jdbcType="VARCHAR" property="xaState" />
    <result column="SOURCE" jdbcType="VARCHAR" property="source" />
    <result column="TIMER_START" jdbcType="BIGINT" property="timerStart" />
    <result column="TIMER_END" jdbcType="BIGINT" property="timerEnd" />
    <result column="TIMER_WAIT" jdbcType="BIGINT" property="timerWait" />
    <result column="ACCESS_MODE" jdbcType="CHAR" property="accessMode" />
    <result column="ISOLATION_LEVEL" jdbcType="VARCHAR" property="isolationLevel" />
    <result column="AUTOCOMMIT" jdbcType="CHAR" property="autocommit" />
    <result column="NUMBER_OF_SAVEPOINTS" jdbcType="BIGINT" property="numberOfSavepoints" />
    <result column="NUMBER_OF_ROLLBACK_TO_SAVEPOINT" jdbcType="BIGINT" property="numberOfRollbackToSavepoint" />
    <result column="NUMBER_OF_RELEASE_SAVEPOINT" jdbcType="BIGINT" property="numberOfReleaseSavepoint" />
    <result column="OBJECT_INSTANCE_BEGIN" jdbcType="BIGINT" property="objectInstanceBegin" />
    <result column="NESTING_EVENT_ID" jdbcType="BIGINT" property="nestingEventId" />
    <result column="NESTING_EVENT_TYPE" jdbcType="CHAR" property="nestingEventType" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="map">
    delete from events_transactions_current
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_transactions_current (THREAD_ID, EVENT_ID, END_EVENT_ID, 
      EVENT_NAME, STATE, TRX_ID, 
      GTID, XID_FORMAT_ID, XID_GTRID, 
      XID_BQUAL, XA_STATE, SOURCE, 
      TIMER_START, TIMER_END, TIMER_WAIT, 
      ACCESS_MODE, ISOLATION_LEVEL, AUTOCOMMIT, 
      NUMBER_OF_SAVEPOINTS, NUMBER_OF_ROLLBACK_TO_SAVEPOINT, 
      NUMBER_OF_RELEASE_SAVEPOINT, OBJECT_INSTANCE_BEGIN, 
      NESTING_EVENT_ID, NESTING_EVENT_TYPE)
    values (#{threadId,jdbcType=BIGINT}, #{eventId,jdbcType=BIGINT}, #{endEventId,jdbcType=BIGINT}, 
      #{eventName,jdbcType=VARCHAR}, #{state,jdbcType=CHAR}, #{trxId,jdbcType=BIGINT}, 
      #{gtid,jdbcType=VARCHAR}, #{xidFormatId,jdbcType=INTEGER}, #{xidGtrid,jdbcType=VARCHAR}, 
      #{xidBqual,jdbcType=VARCHAR}, #{xaState,jdbcType=VARCHAR}, #{source,jdbcType=VARCHAR}, 
      #{timerStart,jdbcType=BIGINT}, #{timerEnd,jdbcType=BIGINT}, #{timerWait,jdbcType=BIGINT}, 
      #{accessMode,jdbcType=CHAR}, #{isolationLevel,jdbcType=VARCHAR}, #{autocommit,jdbcType=CHAR}, 
      #{numberOfSavepoints,jdbcType=BIGINT}, #{numberOfRollbackToSavepoint,jdbcType=BIGINT}, 
      #{numberOfReleaseSavepoint,jdbcType=BIGINT}, #{objectInstanceBegin,jdbcType=BIGINT}, 
      #{nestingEventId,jdbcType=BIGINT}, #{nestingEventType,jdbcType=CHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update events_transactions_current
    set END_EVENT_ID = #{endEventId,jdbcType=BIGINT},
      EVENT_NAME = #{eventName,jdbcType=VARCHAR},
      STATE = #{state,jdbcType=CHAR},
      TRX_ID = #{trxId,jdbcType=BIGINT},
      GTID = #{gtid,jdbcType=VARCHAR},
      XID_FORMAT_ID = #{xidFormatId,jdbcType=INTEGER},
      XID_GTRID = #{xidGtrid,jdbcType=VARCHAR},
      XID_BQUAL = #{xidBqual,jdbcType=VARCHAR},
      XA_STATE = #{xaState,jdbcType=VARCHAR},
      SOURCE = #{source,jdbcType=VARCHAR},
      TIMER_START = #{timerStart,jdbcType=BIGINT},
      TIMER_END = #{timerEnd,jdbcType=BIGINT},
      TIMER_WAIT = #{timerWait,jdbcType=BIGINT},
      ACCESS_MODE = #{accessMode,jdbcType=CHAR},
      ISOLATION_LEVEL = #{isolationLevel,jdbcType=VARCHAR},
      AUTOCOMMIT = #{autocommit,jdbcType=CHAR},
      NUMBER_OF_SAVEPOINTS = #{numberOfSavepoints,jdbcType=BIGINT},
      NUMBER_OF_ROLLBACK_TO_SAVEPOINT = #{numberOfRollbackToSavepoint,jdbcType=BIGINT},
      NUMBER_OF_RELEASE_SAVEPOINT = #{numberOfReleaseSavepoint,jdbcType=BIGINT},
      OBJECT_INSTANCE_BEGIN = #{objectInstanceBegin,jdbcType=BIGINT},
      NESTING_EVENT_ID = #{nestingEventId,jdbcType=BIGINT},
      NESTING_EVENT_TYPE = #{nestingEventType,jdbcType=CHAR}
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </update>
  <select id="selectByPrimaryKey" parameterType="map" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, STATE, TRX_ID, GTID, XID_FORMAT_ID, 
    XID_GTRID, XID_BQUAL, XA_STATE, SOURCE, TIMER_START, TIMER_END, TIMER_WAIT, ACCESS_MODE, 
    ISOLATION_LEVEL, AUTOCOMMIT, NUMBER_OF_SAVEPOINTS, NUMBER_OF_ROLLBACK_TO_SAVEPOINT, 
    NUMBER_OF_RELEASE_SAVEPOINT, OBJECT_INSTANCE_BEGIN, NESTING_EVENT_ID, NESTING_EVENT_TYPE
    from events_transactions_current
    where THREAD_ID = #{threadId,jdbcType=BIGINT}
      and EVENT_ID = #{eventId,jdbcType=BIGINT}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select THREAD_ID, EVENT_ID, END_EVENT_ID, EVENT_NAME, STATE, TRX_ID, GTID, XID_FORMAT_ID, 
    XID_GTRID, XID_BQUAL, XA_STATE, SOURCE, TIMER_START, TIMER_END, TIMER_WAIT, ACCESS_MODE, 
    ISOLATION_LEVEL, AUTOCOMMIT, NUMBER_OF_SAVEPOINTS, NUMBER_OF_ROLLBACK_TO_SAVEPOINT, 
    NUMBER_OF_RELEASE_SAVEPOINT, OBJECT_INSTANCE_BEGIN, NESTING_EVENT_ID, NESTING_EVENT_TYPE
    from events_transactions_current
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="GRANTEE" jdbcType="VARCHAR" property="grantee" />
    <result column="TABLE_CATALOG" jdbcType="VARCHAR" property="tableCatalog" />
    <result column="TABLE_SCHEMA" jdbcType="VARCHAR" property="tableSchema" />
    <result column="PRIVILEGE_TYPE" jdbcType="VARCHAR" property="privilegeType" />
    <result column="IS_GRANTABLE" jdbcType="VARCHAR" property="isGrantable" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into SCHEMA_PRIVILEGES (GRANTEE, TABLE_CATALOG, TABLE_SCHEMA, 
      PRIVILEGE_TYPE, IS_GRANTABLE)
    values (#{grantee,jdbcType=VARCHAR}, #{tableCatalog,jdbcType=VARCHAR}, #{tableSchema,jdbcType=VARCHAR}, 
      #{privilegeType,jdbcType=VARCHAR}, #{isGrantable,jdbcType=VARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select GRANTEE, TABLE_CATALOG, TABLE_SCHEMA, PRIVILEGE_TYPE, IS_GRANTABLE
    from SCHEMA_PRIVILEGES
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="trx_id" jdbcType="VARCHAR" property="trxId" />
    <result column="trx_state" jdbcType="VARCHAR" property="trxState" />
    <result column="trx_started" jdbcType="TIMESTAMP" property="trxStarted" />
    <result column="trx_requested_lock_id" jdbcType="VARCHAR" property="trxRequestedLockId" />
    <result column="trx_wait_started" jdbcType="TIMESTAMP" property="trxWaitStarted" />
    <result column="trx_weight" jdbcType="BIGINT" property="trxWeight" />
    <result column="trx_mysql_thread_id" jdbcType="BIGINT" property="trxMysqlThreadId" />
    <result column="trx_query" jdbcType="VARCHAR" property="trxQuery" />
    <result column="trx_operation_state" jdbcType="VARCHAR" property="trxOperationState" />
    <result column="trx_tables_in_use" jdbcType="BIGINT" property="trxTablesInUse" />
    <result column="trx_tables_locked" jdbcType="BIGINT" property="trxTablesLocked" />
    <result column="trx_lock_structs" jdbcType="BIGINT" property="trxLockStructs" />
    <result column="trx_lock_memory_bytes" jdbcType="BIGINT" property="trxLockMemoryBytes" />
    <result column="trx_rows_locked" jdbcType="BIGINT" property="trxRowsLocked" />
    <result column="trx_rows_modified" jdbcType="BIGINT" property="trxRowsModified" />
    <result column="trx_concurrency_tickets" jdbcType="BIGINT" property="trxConcurrencyTickets" />
    <result column="trx_isolation_level" jdbcType="VARCHAR" property="trxIsolationLevel" />
    <result column="trx_unique_checks" jdbcType="INTEGER" property="trxUniqueChecks" />
    <result column="trx_foreign_key_checks" jdbcType="INTEGER" property="trxForeignKeyChecks" />
    <result column="trx_last_foreign_key_error" jdbcType="VARCHAR" property="trxLastForeignKeyError" />
    <result column="trx_adaptive_hash_latched" jdbcType="INTEGER" property="trxAdaptiveHashLatched" />
    <result column="trx_adaptive_hash_timeout" jdbcType="BIGINT" property="trxAdaptiveHashTimeout" />
    <result column="trx_is_read_only" jdbcType="INTEGER" property="trxIsReadOnly" />
    <result column="trx_autocommit_non_locking" jdbcType="INTEGER" property="trxAutocommitNonLocking" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_TRX (trx_id, trx_state, trx_started, 
      trx_requested_lock_id, trx_wait_started, trx_weight, 
      trx_mysql_thread_id, trx_query, trx_operation_state, 
      trx_tables_in_use, trx_tables_locked, trx_lock_structs, 
      trx_lock_memory_bytes, trx_rows_locked, trx_rows_modified, 
      trx_concurrency_tickets, trx_isolation_level, 
      trx_unique_checks, trx_foreign_key_checks, trx_last_foreign_key_error, 
      trx_adaptive_hash_latched, trx_adaptive_hash_timeout, 
      trx_is_read_only, trx_autocommit_non_locking)
    values (#{trxId,jdbcType=VARCHAR}, #{trxState,jdbcType=VARCHAR}, #{trxStarted,jdbcType=TIMESTAMP}, 
      #{trxRequestedLockId,jdbcType=VARCHAR}, #{trxWaitStarted,jdbcType=TIMESTAMP}, #{trxWeight,jdbcType=BIGINT}, 
      #{trxMysqlThreadId,jdbcType=BIGINT}, #{trxQuery,jdbcType=VARCHAR}, #{trxOperationState,jdbcType=VARCHAR}, 
      #{trxTablesInUse,jdbcType=BIGINT}, #{trxTablesLocked,jdbcType=BIGINT}, #{trxLockStructs,jdbcType=BIGINT}, 
      #{trxLockMemoryBytes,jdbcType=BIGINT}, #{trxRowsLocked,jdbcType=BIGINT}, #{trxRowsModified,jdbcType=BIGINT}, 
      #{trxConcurrencyTickets,jdbcType=BIGINT}, #{trxIsolationLevel,jdbcType=VARCHAR}, 
      #{trxUniqueChecks,jdbcType=INTEGER}, #{trxForeignKeyChecks,jdbcType=INTEGER}, #{trxLastForeignKeyError,jdbcType=VARCHAR}, 
      #{trxAdaptiveHashLatched,jdbcType=INTEGER}, #{trxAdaptiveHashTimeout,jdbcType=BIGINT}, 
      #{trxIsReadOnly,jdbcType=INTEGER}, #{trxAutocommitNonLocking,jdbcType=INTEGER})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select trx_id, trx_state, trx_started, trx_requested_lock_id, trx_wait_started, trx_weight, 
    trx_mysql_thread_id, trx_query, trx_operation_state, trx_tables_in_use, trx_tables_locked, 
    trx_lock_structs, trx_lock_memory_bytes, trx_rows_locked, trx_rows_modified, trx_concurrency_tickets, 
    trx_isolation_level, trx_unique_checks, trx_foreign_key_checks, trx_last_foreign_key_error, 
    trx_adaptive_hash_latched, trx_adaptive_hash_timeout, trx_is_read_only, trx_autocommit_non_locking
    from INNODB_TRX
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="thd_id" jdbcType="BIGINT" property="thdId" />
    <result column="conn_id" jdbcType="BIGINT" property="connId" />
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="command" jdbcType="VARCHAR" property="command" />
    <result column="state" jdbcType="VARCHAR" property="state" />
    <result column="time" jdbcType="BIGINT" property="time" />
    <result column="statement_latency" jdbcType="BIGINT" property="statementLatency" />
    <result column="progress" jdbcType="DECIMAL" property="progress" />
    <result column="lock_latency" jdbcType="BIGINT" property="lockLatency" />
    <result column="rows_examined" jdbcType="BIGINT" property="rowsExamined" />
    <result column="rows_sent" jdbcType="BIGINT" property="rowsSent" />
    <result column="rows_affected" jdbcType="BIGINT" property="rowsAffected" />
    <result column="tmp_tables" jdbcType="BIGINT" property="tmpTables" />
    <result column="tmp_disk_tables" jdbcType="BIGINT" property="tmpDiskTables" />
    <result column="full_scan" jdbcType="VARCHAR" property="fullScan" />
    <result column="last_statement_latency" jdbcType="BIGINT" property="lastStatementLatency" />
    <result column="current_memory" jdbcType="DECIMAL" property="currentMemory" />
    <result column="last_wait" jdbcType="VARCHAR" property="lastWait" />
    <result column="last_wait_latency" jdbcType="VARCHAR" property="lastWaitLatency" />
    <result column="source" jdbcType="VARCHAR" property="source" />
    <result column="trx_latency" jdbcType="BIGINT" property="trxLatency" />
    <result column="trx_state" jdbcType="CHAR" property="trxState" />
    <result column="trx_autocommit" jdbcType="CHAR" property="trxAutocommit" />
    <result column="pid" jdbcType="VARCHAR" property="pid" />
    <result column="program_name" jdbcType="VARCHAR" property="programName" />
    <result column="current_statement" jdbcType="LONGVARCHAR" property="currentStatement" />
    <result column="last_statement" jdbcType="LONGVARCHAR" property="lastStatement" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$session (thd_id, conn_id, user, 
      db, command, state, 
      time, statement_latency, progress, 
      lock_latency, rows_examined, rows_sent, 
      rows_affected, tmp_tables, tmp_disk_tables, 
      full_scan, last_statement_latency, current_memory, 
      last_wait, last_wait_latency, source, 
      trx_latency, trx_state, trx_autocommit, 
      pid, program_name, current_statement, 
      last_statement)
    values (#{thdId,jdbcType=BIGINT}, #{connId,jdbcType=BIGINT}, #{user,jdbcType=VARCHAR}, 
      #{db,jdbcType=VARCHAR}, #{command,jdbcType=VARCHAR}, #{state,jdbcType=VARCHAR}, 
      #{time,jdbcType=BIGINT}, #{statementLatency,jdbcType=BIGINT}, #{progress,jdbcType=DECIMAL}, 
      #{lockLatency,jdbcType=BIGINT}, #{rowsExamined,jdbcType=BIGINT}, #{rowsSent,jdbcType=BIGINT}, 
      #{rowsAffected,jdbcType=BIGINT}, #{tmpTables,jdbcType=BIGINT}, #{tmpDiskTables,jdbcType=BIGINT}, 
      #{fullScan,jdbcType=VARCHAR}, #{lastStatementLatency,jdbcType=BIGINT}, #{currentMemory,jdbcType=DECIMAL}, 
      #{lastWait,jdbcType=VARCHAR}, #{lastWaitLatency,jdbcType=VARCHAR}, #{source,jdbcType=VARCHAR}, 
      #{trxLatency,jdbcType=BIGINT}, #{trxState,jdbcType=CHAR}, #{trxAutocommit,jdbcType=CHAR}, 
      #{pid,jdbcType=VARCHAR}, #{programName,jdbcType=VARCHAR}, #{currentStatement,jdbcType=LONGVARCHAR}, 
      #{lastStatement,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select thd_id, conn_id, user, db, command, state, time, statement_latency, progress, 
    lock_latency, rows_examined, rows_sent, rows_affected, tmp_tables, tmp_disk_tables, 
    full_scan, last_statement_latency, current_memory, last_wait, last_wait_latency, 
    source, trx_latency, trx_state, trx_autocommit, pid, program_name, current_statement, 
    last_statement
    from x$session
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="database_name" jdbcType="VARCHAR" property="databaseName" />
    <result column="table_name" jdbcType="VARCHAR" property="tableName" />
    <result column="index_name" jdbcType="VARCHAR" property="indexName" />
    <result column="compress_ops" jdbcType="INTEGER" property="compressOps" />
    <result column="compress_ops_ok" jdbcType="INTEGER" property="compressOpsOk" />
    <result column="compress_time" jdbcType="INTEGER" property="compressTime" />
    <result column="uncompress_ops" jdbcType="INTEGER" property="uncompressOps" />
    <result column="uncompress_time" jdbcType="INTEGER" property="uncompressTime" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into INNODB_CMP_PER_INDEX_RESET (database_name, table_name, index_name, 
      compress_ops, compress_ops_ok, compress_time, 
      uncompress_ops, uncompress_time)
    values (#{databaseName,jdbcType=VARCHAR}, #{tableName,jdbcType=VARCHAR}, #{indexName,jdbcType=VARCHAR}, 
      #{compressOps,jdbcType=INTEGER}, #{compressOpsOk,jdbcType=INTEGER}, #{compressTime,jdbcType=INTEGER}, 
      #{uncompressOps,jdbcType=INTEGER}, #{uncompressTime,jdbcType=INTEGER})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select database_name, table_name, index_name, compress_ops, compress_ops_ok, compress_time, 
    uncompress_ops, uncompress_time
    from INNODB_CMP_PER_INDEX_RESET
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="exec_count" jdbcType="BIGINT" property="execCount" />
    <result column="errors" jdbcType="BIGINT" property="errors" />
    <result column="error_pct" jdbcType="DECIMAL" property="errorPct" />
    <result column="warnings" jdbcType="BIGINT" property="warnings" />
    <result column="warning_pct" jdbcType="DECIMAL" property="warningPct" />
    <result column="first_seen" jdbcType="TIMESTAMP" property="firstSeen" />
    <result column="last_seen" jdbcType="TIMESTAMP" property="lastSeen" />
    <result column="digest" jdbcType="VARCHAR" property="digest" />
    <result column="query" jdbcType="LONGVARCHAR" property="query" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$statements_with_errors_or_warnings (db, exec_count, errors, 
      error_pct, warnings, warning_pct, 
      first_seen, last_seen, digest, 
      query)
    values (#{db,jdbcType=VARCHAR}, #{execCount,jdbcType=BIGINT}, #{errors,jdbcType=BIGINT}, 
      #{errorPct,jdbcType=DECIMAL}, #{warnings,jdbcType=BIGINT}, #{warningPct,jdbcType=DECIMAL}, 
      #{firstSeen,jdbcType=TIMESTAMP}, #{lastSeen,jdbcType=TIMESTAMP}, #{digest,jdbcType=VARCHAR}, 
      #{query,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select db, exec_count, errors, error_pct, warnings, warning_pct, first_seen, last_seen, 
    digest, query
    from x$statements_with_errors_or_warnings
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="host" jdbcType="VARCHAR" property="host" />
    <result column="ios" jdbcType="DECIMAL" property="ios" />
    <result column="io_latency" jdbcType="LONGVARCHAR" property="ioLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into host_summary_by_file_io (host, ios, io_latency
      )
    values (#{host,jdbcType=VARCHAR}, #{ios,jdbcType=DECIMAL}, #{ioLatency,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select host, ios, io_latency
    from host_summary_by_file_io
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="user" jdbcType="VARCHAR" property="user" />
    <result column="ios" jdbcType="DECIMAL" property="ios" />
    <result column="io_latency" jdbcType="LONGVARCHAR" property="ioLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into user_summary_by_file_io (user, ios, io_latency
      )
    values (#{user,jdbcType=VARCHAR}, #{ios,jdbcType=DECIMAL}, #{ioLatency,jdbcType=LONGVARCHAR}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select user, ios, io_latency
    from user_summary_by_file_io
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="UserID" jdbcType="VARCHAR" property="userid" />
    <result column="UserName" jdbcType="VARCHAR" property="username" />
    <result column="PassWord" jdbcType="VARCHAR" property="password" />
    <result column="UserNo" jdbcType="VARCHAR" property="userno" />
    <result column="UserClass" jdbcType="INTEGER" property="userclass" />
    <result column="ClassroomID" jdbcType="VARCHAR" property="classroomid" />
    <result column="Tel" jdbcType="VARCHAR" property="tel" />
    <result column="IsLock" jdbcType="INTEGER" property="islock" />
    <result column="BAK" jdbcType="VARCHAR" property="bak" />
    <result column="IsDel" jdbcType="INTEGER" property="isdel" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into userbase (UserID, UserName, PassWord, 
      UserNo, UserClass, ClassroomID, 
      Tel, IsLock, BAK, IsDel
      )
    values (#{userid,jdbcType=VARCHAR}, #{username,jdbcType=VARCHAR}, #{password,jdbcType=VARCHAR}, 
      #{userno,jdbcType=VARCHAR}, #{userclass,jdbcType=INTEGER}, #{classroomid,jdbcType=VARCHAR}, 
      #{tel,jdbcType=VARCHAR}, #{islock,jdbcType=INTEGER}, #{bak,jdbcType=VARCHAR}, #{isdel,jdbcType=INTEGER}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select UserID, UserName, PassWord, UserNo, UserClass, ClassroomID, Tel, IsLock, BAK, 
    IsDel
    from userbase
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <id column="Channel_name" jdbcType="CHAR" property="channelName" />
    <result column="Number_of_lines" jdbcType="INTEGER" property="numberOfLines" />
    <result column="Master_log_pos" jdbcType="BIGINT" property="masterLogPos" />
    <result column="Host" jdbcType="CHAR" property="host" />
    <result column="Port" jdbcType="INTEGER" property="port" />
    <result column="Connect_retry" jdbcType="INTEGER" property="connectRetry" />
    <result column="Enabled_ssl" jdbcType="BIT" property="enabledSsl" />
    <result column="Ssl_verify_server_cert" jdbcType="BIT" property="sslVerifyServerCert" />
    <result column="Heartbeat" jdbcType="REAL" property="heartbeat" />
    <result column="Retry_count" jdbcType="BIGINT" property="retryCount" />
    <result column="Enabled_auto_position" jdbcType="BIT" property="enabledAutoPosition" />
    <result column="Get_public_key" jdbcType="BIT" property="getPublicKey" />
    <result column="Master_log_name" jdbcType="LONGVARCHAR" property="masterLogName" />
    <result column="User_name" jdbcType="LONGVARCHAR" property="userName" />
    <result column="User_password" jdbcType="LONGVARCHAR" property="userPassword" />
    <result column="Ssl_ca" jdbcType="LONGVARCHAR" property="sslCa" />
    <result column="Ssl_capath" jdbcType="LONGVARCHAR" property="sslCapath" />
    <result column="Ssl_cert" jdbcType="LONGVARCHAR" property="sslCert" />
    <result column="Ssl_cipher" jdbcType="LONGVARCHAR" property="sslCipher" />
    <result column="Ssl_key" jdbcType="LONGVARCHAR" property="sslKey" />
    <result column="Bind" jdbcType="LONGVARCHAR" property="bind" />
    <result column="Ignored_server_ids" jdbcType="LONGVARCHAR" property="ignoredServerIds" />
    <result column="Uuid" jdbcType="LONGVARCHAR" property="uuid" />
    <result column="Ssl_crl" jdbcType="LONGVARCHAR" property="sslCrl" />
    <result column="Ssl_crlpath" jdbcType="LONGVARCHAR" property="sslCrlpath" />
    <result column="Tls_version" jdbcType="LONGVARCHAR" property="tlsVersion" />
    <result column="Public_key_path" jdbcType="LONGVARCHAR" property="publicKeyPath" />
    <result column="Network_namespace" jdbcType="LONGVARCHAR" property="networkNamespace" />
  </resultMap>
  <delete id="deleteByPrimaryKey" parameterType="java.lang.String">
    delete from slave_master_info
    where Channel_name = #{channelName,jdbcType=CHAR}
  </delete>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into slave_master_info (Channel_name, Number_of_lines, Master_log_pos, 
      Host, Port, Connect_retry, 
      Enabled_ssl, Ssl_verify_server_cert, Heartbeat, 
      Retry_count, Enabled_auto_position, Get_public_key, 
      Master_log_name, User_name, User_password, 
      Ssl_ca, Ssl_capath, Ssl_cert, 
      Ssl_cipher, Ssl_key, Bind, 
      Ignored_server_ids, Uuid, Ssl_crl, 
      Ssl_crlpath, Tls_version, Public_key_path, 
      Network_namespace)
    values (#{channelName,jdbcType=CHAR}, #{numberOfLines,jdbcType=INTEGER}, #{masterLogPos,jdbcType=BIGINT}, 
      #{host,jdbcType=CHAR}, #{port,jdbcType=INTEGER}, #{connectRetry,jdbcType=INTEGER}, 
      #{enabledSsl,jdbcType=BIT}, #{sslVerifyServerCert,jdbcType=BIT}, #{heartbeat,jdbcType=REAL}, 
      #{retryCount,jdbcType=BIGINT}, #{enabledAutoPosition,jdbcType=BIT}, #{getPublicKey,jdbcType=BIT}, 
      #{masterLogName,jdbcType=LONGVARCHAR}, #{userName,jdbcType=LONGVARCHAR}, #{userPassword,jdbcType=LONGVARCHAR}, 
      #{sslCa,jdbcType=LONGVARCHAR}, #{sslCapath,jdbcType=LONGVARCHAR}, #{sslCert,jdbcType=LONGVARCHAR}, 
      #{sslCipher,jdbcType=LONGVARCHAR}, #{sslKey,jdbcType=LONGVARCHAR}, #{bind,jdbcType=LONGVARCHAR}, 
      #{ignoredServerIds,jdbcType=LONGVARCHAR}, #{uuid,jdbcType=LONGVARCHAR}, #{sslCrl,jdbcType=LONGVARCHAR}, 
      #{sslCrlpath,jdbcType=LONGVARCHAR}, #{tlsVersion,jdbcType=LONGVARCHAR}, #{publicKeyPath,jdbcType=LONGVARCHAR}, 
      #{networkNamespace,jdbcType=LONGVARCHAR})
  </insert>
  <update id="updateByPrimaryKey" parameterType="entity.LearnResource">
    update slave_master_info
    set Number_of_lines = #{numberOfLines,jdbcType=INTEGER},
      Master_log_pos = #{masterLogPos,jdbcType=BIGINT},
      Host = #{host,jdbcType=CHAR},
      Port = #{port,jdbcType=INTEGER},
      Connect_retry = #{connectRetry,jdbcType=INTEGER},
      Enabled_ssl = #{enabledSsl,jdbcType=BIT},
      Ssl_verify_server_cert = #{sslVerifyServerCert,jdbcType=BIT},
      Heartbeat = #{heartbeat,jdbcType=REAL},
      Retry_count = #{retryCount,jdbcType=BIGINT},
      Enabled_auto_position = #{enabledAutoPosition,jdbcType=BIT},
      Get_public_key = #{getPublicKey,jdbcType=BIT},
      Master_log_name = #{masterLogName,jdbcType=LONGVARCHAR},
      User_name = #{userName,jdbcType=LONGVARCHAR},
      User_password = #{userPassword,jdbcType=LONGVARCHAR},
      Ssl_ca = #{sslCa,jdbcType=LONGVARCHAR},
      Ssl_capath = #{sslCapath,jdbcType=LONGVARCHAR},
      Ssl_cert = #{sslCert,jdbcType=LONGVARCHAR},
      Ssl_cipher = #{sslCipher,jdbcType=LONGVARCHAR},
      Ssl_key = #{sslKey,jdbcType=LONGVARCHAR},
      Bind = #{bind,jdbcType=LONGVARCHAR},
      Ignored_server_ids = #{ignoredServerIds,jdbcType=LONGVARCHAR},
      Uuid = #{uuid,jdbcType=LONGVARCHAR},
      Ssl_crl = #{sslCrl,jdbcType=LONGVARCHAR},
      Ssl_crlpath = #{sslCrlpath,jdbcType=LONGVARCHAR},
      Tls_version = #{tlsVersion,jdbcType=LONGVARCHAR},
      Public_key_path = #{publicKeyPath,jdbcType=LONGVARCHAR},
      Network_namespace = #{networkNamespace,jdbcType=LONGVARCHAR}
    where Channel_name = #{channelName,jdbcType=CHAR}
  </update>
  <select id="selectByPrimaryKey" parameterType="java.lang.String" resultMap="BaseResultMap">
    select Channel_name, Number_of_lines, Master_log_pos, Host, Port, Connect_retry, 
    Enabled_ssl, Ssl_verify_server_cert, Heartbeat, Retry_count, Enabled_auto_position, 
    Get_public_key, Master_log_name, User_name, User_password, Ssl_ca, Ssl_capath, Ssl_cert, 
    Ssl_cipher, Ssl_key, Bind, Ignored_server_ids, Uuid, Ssl_crl, Ssl_crlpath, Tls_version, 
    Public_key_path, Network_namespace
    from slave_master_info
    where Channel_name = #{channelName,jdbcType=CHAR}
  </select>
  <select id="selectAll" resultMap="BaseResultMap">
    select Channel_name, Number_of_lines, Master_log_pos, Host, Port, Connect_retry, 
    Enabled_ssl, Ssl_verify_server_cert, Heartbeat, Retry_count, Enabled_auto_position, 
    Get_public_key, Master_log_name, User_name, User_password, Ssl_ca, Ssl_capath, Ssl_cert, 
    Ssl_cipher, Ssl_key, Bind, Ignored_server_ids, Uuid, Ssl_crl, Ssl_crlpath, Tls_version, 
    Public_key_path, Network_namespace
    from slave_master_info
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="event_class" jdbcType="VARCHAR" property="eventClass" />
    <result column="total" jdbcType="DECIMAL" property="total" />
    <result column="total_latency" jdbcType="DECIMAL" property="totalLatency" />
    <result column="min_latency" jdbcType="BIGINT" property="minLatency" />
    <result column="avg_latency" jdbcType="DECIMAL" property="avgLatency" />
    <result column="max_latency" jdbcType="BIGINT" property="maxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into x$wait_classes_global_by_avg_latency (event_class, total, total_latency, 
      min_latency, avg_latency, max_latency
      )
    values (#{eventClass,jdbcType=VARCHAR}, #{total,jdbcType=DECIMAL}, #{totalLatency,jdbcType=DECIMAL}, 
      #{minLatency,jdbcType=BIGINT}, #{avgLatency,jdbcType=DECIMAL}, #{maxLatency,jdbcType=BIGINT}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select event_class, total, total_latency, min_latency, avg_latency, max_latency
    from x$wait_classes_global_by_avg_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="start_time" jdbcType="TIMESTAMP" property="startTime" />
    <result column="query_time" jdbcType="TIME" property="queryTime" />
    <result column="lock_time" jdbcType="TIME" property="lockTime" />
    <result column="rows_sent" jdbcType="INTEGER" property="rowsSent" />
    <result column="rows_examined" jdbcType="INTEGER" property="rowsExamined" />
    <result column="db" jdbcType="VARCHAR" property="db" />
    <result column="last_insert_id" jdbcType="INTEGER" property="lastInsertId" />
    <result column="insert_id" jdbcType="INTEGER" property="insertId" />
    <result column="server_id" jdbcType="INTEGER" property="serverId" />
    <result column="thread_id" jdbcType="BIGINT" property="threadId" />
    <result column="user_host" jdbcType="LONGVARCHAR" property="userHost" />
    <result column="sql_text" jdbcType="LONGVARBINARY" property="sqlText" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into slow_log (start_time, query_time, lock_time, 
      rows_sent, rows_examined, db, 
      last_insert_id, insert_id, server_id, 
      thread_id, user_host, sql_text
      )
    values (#{startTime,jdbcType=TIMESTAMP}, #{queryTime,jdbcType=TIME}, #{lockTime,jdbcType=TIME}, 
      #{rowsSent,jdbcType=INTEGER}, #{rowsExamined,jdbcType=INTEGER}, #{db,jdbcType=VARCHAR}, 
      #{lastInsertId,jdbcType=INTEGER}, #{insertId,jdbcType=INTEGER}, #{serverId,jdbcType=INTEGER}, 
      #{threadId,jdbcType=BIGINT}, #{userHost,jdbcType=LONGVARCHAR}, #{sqlText,jdbcType=LONGVARBINARY}
      )
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select start_time, query_time, lock_time, rows_sent, rows_examined, db, last_insert_id, 
    insert_id, server_id, thread_id, user_host, sql_text
    from slow_log
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="events" jdbcType="VARCHAR" property="events" />
    <result column="total" jdbcType="BIGINT" property="total" />
    <result column="total_latency" jdbcType="LONGVARCHAR" property="totalLatency" />
    <result column="avg_latency" jdbcType="LONGVARCHAR" property="avgLatency" />
    <result column="max_latency" jdbcType="LONGVARCHAR" property="maxLatency" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into waits_global_by_latency (events, total, total_latency, 
      avg_latency, max_latency)
    values (#{events,jdbcType=VARCHAR}, #{total,jdbcType=BIGINT}, #{totalLatency,jdbcType=LONGVARCHAR}, 
      #{avgLatency,jdbcType=LONGVARCHAR}, #{maxLatency,jdbcType=LONGVARCHAR})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select events, total, total_latency, avg_latency, max_latency
    from waits_global_by_latency
    order by age desc,username asc
  </select>
  <resultMap id="BaseResultMap" type="entity.LearnResource">
    <result column="SCHEMA_NAME" jdbcType="VARCHAR" property="schemaName" />
    <result column="DIGEST" jdbcType="VARCHAR" property="digest" />
    <result column="BUCKET_NUMBER" jdbcType="INTEGER" property="bucketNumber" />
    <result column="BUCKET_TIMER_LOW" jdbcType="BIGINT" property="bucketTimerLow" />
    <result column="BUCKET_TIMER_HIGH" jdbcType="BIGINT" property="bucketTimerHigh" />
    <result column="COUNT_BUCKET" jdbcType="BIGINT" property="countBucket" />
    <result column="COUNT_BUCKET_AND_LOWER" jdbcType="BIGINT" property="countBucketAndLower" />
    <result column="BUCKET_QUANTILE" jdbcType="DOUBLE" property="bucketQuantile" />
  </resultMap>
  <insert id="insert" parameterType="entity.LearnResource">
    insert into events_statements_histogram_by_digest (SCHEMA_NAME, DIGEST, BUCKET_NUMBER, 
      BUCKET_TIMER_LOW, BUCKET_TIMER_HIGH, COUNT_BUCKET, 
      COUNT_BUCKET_AND_LOWER, BUCKET_QUANTILE)
    values (#{schemaName,jdbcType=VARCHAR}, #{digest,jdbcType=VARCHAR}, #{bucketNumber,jdbcType=INTEGER}, 
      #{bucketTimerLow,jdbcType=BIGINT}, #{bucketTimerHigh,jdbcType=BIGINT}, #{countBucket,jdbcType=BIGINT}, 
      #{countBucketAndLower,jdbcType=BIGINT}, #{bucketQuantile,jdbcType=DOUBLE})
  </insert>
  <select id="selectAll" resultMap="BaseResultMap">
    select SCHEMA_NAME, DIGEST, BUCKET_NUMBER, BUCKET_TIMER_LOW, BUCKET_TIMER_HIGH, COUNT_BUCKET, 
    COUNT_BUCKET_AND_LOWER, BUCKET_QUANTILE
    from events_statements_histogram_by_digest
    order by age desc,username asc
  </select>
</mapper>